<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acetabular Wear Analysis System</title>
    <link rel="icon" type="image/png" href="attached_assets/favicon_1763986228549.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Optimization libraries for large 3D models -->
    <script src="geometry-optimizer.js" defer></script>
    <script src="performance-dashboard.js" defer></script>
    <script src="optimization-tests.js" defer></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.05), transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(124, 58, 237, 0.05), transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(59, 130, 246, 0.05), transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            max-width: 1920px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        #viewer-container {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #sphere-viewer-container {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #volumetric-viewer-container {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel {
            background: #ffffff;
            border-radius: 20px;
            padding: 28px;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(226, 232, 240, 0.8);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 30px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 
                0 10px 30px rgba(102, 126, 234, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
        }
        
        .metric-card:hover::before {
            opacity: 1;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 15px rgba(102, 126, 234, 0.4),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }
        
        .btn-primary:hover::before {
            left: 100%;
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            padding: 14px 28px;
            border-radius: 12px;
            border: 2px solid #667eea;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }
        
        .btn-secondary:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px currentColor;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .status-ready { background: #48bb78; box-shadow: 0 0 15px #48bb78; }
        .status-processing { background: #ed8936; box-shadow: 0 0 15px #ed8936; }
        .status-complete { background: #4299e1; box-shadow: 0 0 15px #4299e1; }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            background: rgba(102, 126, 234, 0.05);
            transform: translateX(4px);
        }
        
        .legend-color {
            width: 36px;
            height: 24px;
            border-radius: 6px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .loading-overlay::after {
            content: '';
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .hidden { display: none; }
        
        h1 {
            color: #0f172a;
            font-weight: 800;
        }
        
        h2 {
            color: #1e293b;
            font-weight: 700;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        input[type="file"] {
            padding: 12px;
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            transition: all 0.3s ease;
            background: #f8fafc;
            color: #475569;
        }
        
        input[type="file"]:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }
        
        p {
            color: #64748b;
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-6">
        <!-- Header -->
        <div class="panel mb-6 fade-in">
            <div class="flex items-center gap-4 mb-3">
                <svg class="w-12 h-12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" fill="url(#grad1)"/>
                    <circle cx="12" cy="12" r="4" fill="url(#grad1)" opacity="0.6"/>
                </svg>
                <div>
                    <h1 class="text-4xl font-bold mb-1">Acetabular Wear Analysis System</h1>
                    <p class="text-lg" style="color: #64748b;">Professional volumetric and linear wear measurement for hip prosthesis components</p>
                </div>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Panel: Controls -->
            <div class="lg:col-span-1">
                <div class="panel mb-6 fade-in" style="animation-delay: 0.1s;">
                    <h2 class="text-2xl font-bold mb-4">
                        <span class="flex items-center gap-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <defs>
                                    <linearGradient id="grad2" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <path stroke="url(#grad2)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            File Upload
                        </span>
                    </h2>
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2" style="color: #475569;">
                            Upload STL File
                        </label>
                        <input type="file" id="file-input" accept=".stl" class="w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                    <div class="text-sm mb-4 flex items-center" style="color: #64748b;">
                        <span class="status-indicator status-ready" id="status-indicator"></span>
                        <span id="status-text">Ready to load file</span>
                    </div>
                    
                    <!-- Progress Bar for File Loading -->
                    <div id="progress-container" class="hidden mb-4">
                        <div class="flex justify-between items-center mb-2">
                            <div>
                                <span class="text-xs font-medium" style="color: #667eea;">Importing Model</span>
                                <span class="text-xs ml-2" id="progress-speed" style="color: #94a3b8;"></span>
                            </div>
                            <div class="flex gap-4 text-xs" style="color: #94a3b8;">
                                <span id="progress-time">0s / --s</span>
                                <span id="progress-percent">0%</span>
                            </div>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden" style="background: #e2e8f0;">
                            <div id="progress-bar" class="h-full bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-300 rounded-full" style="width: 0%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);"></div>
                        </div>
                        <div class="flex justify-between mt-2">
                            <span id="progress-loaded" class="text-xs" style="color: #94a3b8;">0 MB</span>
                            <span id="progress-total" class="text-xs" style="color: #94a3b8;">-- MB</span>
                        </div>
                        <div class="mt-2 p-2 bg-blue-50 rounded text-xs" style="color: #3b82f6; display: none;" id="progress-eta">
                            ⏱️ <span id="eta-text">Calculating ETA...</span>
                        </div>
                    </div>

                    <div class="mt-4 p-3 bg-gray-50 border border-gray-200 rounded-lg">
                        <div class="flex items-center justify-between gap-3 mb-2">
                            <div>
                                <p class="text-sm font-semibold text-gray-700">Performance Tools</p>
                                <p class="text-xs text-gray-500" id="precompress-hint">Applies quantization and vertex deduplication.</p>
                            </div>
                            <button id="btn-precompress" class="btn-secondary text-xs px-3 py-2" disabled>Manual Precompression</button>
                        </div>
                        <div class="text-xs text-gray-500" id="precompress-summary">Waiting for STL...</div>
                    </div>
                </div>

                <div class="panel mb-6 fade-in" style="animation-delay: 0.2s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Pipeline</h2>
                    <div class="space-y-3">
                        <button id="btn-isolate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                            </svg>
                            <span>1. Isolate Inner Surface</span>
                        </button>
                        <button id="btn-detect-wear" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                            </svg>
                            <span>2. Detect Wear Zones</span>
                        </button>
                        <button id="btn-fit-sphere" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                            </svg>
                            <span>3. Fit Reference Sphere</span>
                        </button>
                        <button id="btn-calculate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                            </svg>
                            <span>4. Calculate Wear</span>
                        </button>
                    </div>
                    
                    <!-- Analysis Options -->
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h3 class="text-sm font-semibold mb-2 text-gray-700">Detection Method</h3>
                        <select id="detection-method" class="w-full p-2 border border-gray-300 rounded-lg text-sm mb-2">
                            <option value="dual-sphere" selected>Dual Sphere (normal convergence)</option>
                            <option value="hemisphere">Hemisphere (axis dispersion)</option>
                        </select>
                        <p id="detection-method-desc" class="text-xs text-gray-500 mb-3">Uses ray-based clustering to find convergence centers of worn and unworn zones.</p>
                        
                        <div id="dual-sphere-options" class="hidden mb-3 p-3 bg-gray-50 rounded-lg border border-gray-200">
                            <p class="text-xs text-gray-600">
                                <strong>Ray-Based Clustering (v3.1):</strong> Uses k-means clustering on vertex normal rays to find two convergence centers. 
                                The cluster whose center is farther from the reference sphere is classified as UNWORN (true sphere center), 
                                while the closer cluster is WORN (displaced center due to material loss).
                            </p>
                        </div>
                        
                        <h3 class="text-sm font-semibold mb-2 text-gray-700">Surface Shape</h3>
                        <select id="fitting-shape" class="w-full p-2 border border-gray-300 rounded-lg text-sm mb-3">
                            <option value="sphere">Spherical (4 params: cx, cy, cz, r)</option>
                            <option value="ellipsoid">Ellipsoidal (6 params: cx, cy, cz, rx, ry, rz)</option>
                        </select>
                        
                        <h3 class="text-sm font-semibold mb-2 text-gray-700">Optimization Method</h3>
                        <select id="fitting-method" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                            <option value="gauss-newton">Gauss-Newton + LM (Fast)</option>
                            <option value="ransac">RANSAC + LM (Robust)</option>
                        </select>
                        
                        <h3 class="text-sm font-semibold mb-2 mt-3 text-gray-700">Commercial Radius (optional)</h3>
                        <select id="commercial-radius" class="w-full p-2 border border-gray-300 rounded-lg text-sm mb-2">
                            <option value="auto">Auto-detect (nearest commercial size)</option>
                            <option value="14">14 mm</option>
                            <option value="16">16 mm</option>
                            <option value="18">18 mm</option>
                            <option value="20">20 mm</option>
                        </select>
                        <p id="commercial-radius-desc" class="text-xs text-gray-500 mb-3">Select the known commercial radius or let the system detect the nearest standard size (14, 16, 18, or 20 mm).</p>
                        <div id="radius-warning" class="hidden mb-3 p-2 bg-yellow-50 rounded-lg border border-yellow-300">
                            <p class="text-xs text-yellow-700"><strong>Warning:</strong> <span id="radius-warning-text"></span></p>
                        </div>
                        
                        <h3 class="text-sm font-semibold mb-2 mt-3 text-gray-700">Visualization</h3>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="show-inflection-markers" class="rounded">
                            <span>Show inflection point markers</span>
                        </label>
                    </div>
                </div>

                <div class="panel fade-in" style="animation-delay: 0.3s;">
                    <h2 class="text-2xl font-bold mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <defs>
                                <linearGradient id="grad3" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <path stroke="url(#grad3)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                        </svg>
                        Legend
                    </h2>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4299e1;"></div>
                        <span>Original Component</span>
                    </div>
                    <div class="legend-item" id="legend-unworn-zone">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span><strong>Unworn Zone</strong> <span id="legend-unworn-desc">(closer to centroid)</span></span>
                    </div>
                    <div class="legend-item" id="legend-worn-zone">
                        <div class="legend-color" style="background: #f56565;"></div>
                        <span><strong>Worn Zone</strong> <span id="legend-worn-desc">(farther from centroid)</span></span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: transparent; border: 1px solid #ffff00; position: relative; overflow: hidden;">
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 5px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 9px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 13px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 17px;"></div>
                        </div>
                        <span>Unworn Reference Sphere (yellow wireframe)</span>
                    </div>
                    <div class="legend-item" id="legend-worn-sphere" style="display: none;">
                        <div class="legend-color" style="background: transparent; border: 1px solid #ff4444; position: relative; overflow: hidden;">
                            <div style="position: absolute; width: 100%; height: 1px; background: #ff4444; top: 5px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ff4444; top: 9px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ff4444; top: 13px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ff4444; top: 17px;"></div>
                        </div>
                        <span>Worn Sphere (red wireframe, dual-sphere mode)</span>
                    </div>
                    <div class="legend-item" id="legend-unworn-center" style="display: none;">
                        <div class="legend-color" style="background: #00ff88; border-radius: 50%; width: 24px; height: 24px; box-shadow: 0 0 12px rgba(0, 255, 136, 0.8);"></div>
                        <span><strong>Unworn Center</strong> (green sphere, from normals)</span>
                    </div>
                    <div class="legend-item" id="legend-worn-center" style="display: none;">
                        <div class="legend-color" style="background: #ff3366; border-radius: 50%; width: 24px; height: 24px; box-shadow: 0 0 12px rgba(255, 51, 102, 0.8);"></div>
                        <span><strong>Worn Center</strong> (red sphere, from normals)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6600;"></div>
                        <span><strong>Volumetric Wear Zone</strong> (orange highlight)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ffff 0%, #ff00ff 50%, #ff00ff 100%);"></div>
                        <span><strong>Max Linear Wear</strong> (cyan→magenta line)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffff00; box-shadow: 0 0 10px rgba(255, 255, 0, 0.6);"></div>
                        <span><strong>Inflection Markers</strong> (yellow spheres, transition zone)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ffff; border-radius: 50%; width: 20px; height: 20px; box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);"></div>
                        <span style="margin-left: 8px;"><strong>Sphere Surface Point</strong> (cyan marker)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff00ff; border-radius: 50%; width: 20px; height: 20px; box-shadow: 0 0 8px rgba(255, 0, 255, 0.6);"></div>
                        <span style="margin-left: 8px;"><strong>Deepest Worn Point</strong> (magenta marker)</span>
                    </div>
                    <div class="mt-4 p-4 rounded-xl text-sm" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(124, 58, 237, 0.08) 100%); border: 1px solid rgba(102, 126, 234, 0.15); color: #475569;">
                        <p class="font-semibold mb-2 flex items-center gap-2">
                            <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            Important:
                        </p>
                        <p class="mb-1"><strong class="text-red-600">Worn zone</strong> = hemisphere farthest from geometric centroid</p>
                        <p class="mb-1"><strong class="text-green-600">Unworn zone</strong> = hemisphere closest to geometric centroid</p>
                        <p class="text-xs mt-2" style="color: #64748b;"><strong>Sphere Viewer:</strong> Orange area shows volumetric wear volume. Cyan-to-magenta line marks maximum penetration depth with fine markers.</p>
                    </div>
                </div>
            </div>

            <!-- Middle/Right Panel: 3D Viewers -->
            <div class="lg:col-span-2">
                <!-- Main Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.4s;">
                    <h2 class="text-2xl font-bold mb-4">3D Model Viewer</h2>
                    <div id="viewer-container">
                        <div id="loading-overlay" class="loading-overlay hidden">
                            <div>Processing...</div>
                        </div>
                    </div>
                    <div class="mt-4 text-sm" style="color: #64748b;">
                        <p><strong style="color: #475569;">Controls:</strong> Left click + drag to rotate | Right click + drag to pan | Scroll to zoom</p>
                    </div>
                </div>

                <!-- Sphere Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.5s;">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Reference Sphere Visualization</h2>
                        <button id="btn-download-sphere-view" class="btn-secondary hidden" title="Download sphere visualization elements (STL, sphere, plane, inflection points)">
                            Download Elements
                        </button>
                    </div>
                    <div id="sphere-viewer-container">
                        <div id="sphere-loading-overlay" class="loading-overlay">
                            <div>Waiting for analysis...</div>
                        </div>
                    </div>
                </div>

                <!-- Volumetric Wear Viewer (Third Viewer) -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.55s;">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Volumetric Wear Visualization</h2>
                    </div>
                    <div id="volumetric-viewer-container">
                        <div id="volumetric-loading-overlay" class="loading-overlay">
                            <div>Waiting for analysis...</div>
                        </div>
                    </div>
                    <div class="mt-4 text-sm" style="color: #64748b;">
                        <p><strong style="color: #475569;">View:</strong> Transparent original STL + Orange volumetric wear surface (no reference elements)</p>
                    </div>
                </div>

                <!-- Results Panel -->
                <div class="panel fade-in" style="animation-delay: 0.6s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Results</h2>
                    <div id="results-container">
                        <div class="text-center py-8" style="color: #94a3b8;">
                            No analysis completed yet. Upload an STL file and run the analysis pipeline.
                        </div>
                    </div>
                    <div id="results-data" class="hidden">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Volumetric Wear</div>
                                <div class="text-3xl font-bold" id="metric-volume">0.00 mm³</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Mean Linear Wear</div>
                                <div class="text-3xl font-bold" id="metric-linear-mean">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Maximum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-max">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Minimum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-min">0.00 mm</div>
                            </div>
                        </div>
                        <div class="space-y-2 mb-4">
                            <p><strong>Detection Method:</strong> <span id="detection-method-used">-</span></p>
                            <p><strong>Unworn Sphere Center:</strong> <span id="sphere-center">-</span></p>
                            <p><strong>Unworn Sphere Radius:</strong> <span id="sphere-radius">-</span></p>
                            <p id="worn-sphere-info" class="hidden"><strong>Worn Sphere Center:</strong> <span id="worn-sphere-center">-</span></p>
                            <p id="worn-sphere-radius-info" class="hidden"><strong>Worn Sphere Radius:</strong> <span id="worn-sphere-radius">-</span></p>
                            <p id="center-distance-info" class="hidden"><strong>Distance Between Centers:</strong> <span id="center-distance">-</span></p>
                            <p><strong>Worn Zone Area:</strong> <span id="worn-area">-</span></p>
                            <p><strong>Unworn Zone Area:</strong> <span id="unworn-area">-</span></p>
                        </div>
                        
                        <!-- Quality Diagnostics Panel -->
                        <div id="quality-diagnostics" class="hidden mb-4 p-4 rounded-xl" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(124, 58, 237, 0.08) 100%); border: 1px solid rgba(102, 126, 234, 0.15);">
                            <h3 class="font-bold mb-3 text-lg">Quality Diagnostics</h3>
                            <div class="space-y-2 text-sm">
                                <p><strong>Fitting Method:</strong> <span id="diag-method">-</span></p>
                                <p><strong>RMS Error:</strong> <span id="diag-rms">-</span> mm</p>
                                <p><strong>Iterations:</strong> <span id="diag-iterations">-</span></p>
                                <p><strong>Inlier Count:</strong> <span id="diag-inliers">-</span></p>
                                <p><strong>Residual Range:</strong> <span id="diag-residual-range">-</span> mm</p>
                                <p><strong>Convergence:</strong> <span id="diag-convergence">-</span></p>
                                <p><strong>Unworn Area Match:</strong> <span id="diag-unworn-match">-</span></p>
                                <p id="diag-sphericity-container" class="hidden"><strong>Sphericity:</strong> <span id="diag-sphericity">-</span>%</p>
                                <p id="diag-ellipsoidality-container" class="hidden"><strong>Ellipsoidality:</strong> <span id="diag-ellipsoidality">-</span>%</p>
                                <p id="diag-radii-container" class="hidden"><strong>Semi-axes (rx, ry, rz):</strong> <span id="diag-radii">-</span> mm</p>
                            </div>
                        </div>
                        
                        <div class="flex gap-3 flex-wrap">
                            <button id="btn-export-csv" class="btn-secondary">Export CSV</button>
                            <button id="btn-export-json" class="btn-secondary">Export JSON</button>
                            <button id="btn-export-pdf" class="btn-secondary">Export PDF Report</button>
                            <button id="btn-export-html" class="btn-secondary">Export Interactive HTML</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="relative mt-8 py-8 overflow-hidden" style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);">
        <div class="absolute inset-0 opacity-15" style="background-image: url('attached_assets/logo-gbm_1764248868188.png'); background-size: 60% auto; background-repeat: no-repeat; background-position: right center;"></div>
        <div class="relative z-10 container mx-auto px-6">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="text-center md:text-left">
                    <p class="text-white font-semibold text-lg">Grupo de Biomateriales - Universidad de Zaragoza & I3A</p>
                    <p class="text-gray-300 text-sm mt-1">
                        <a href="mailto:gbmunizar@gmail.com" class="hover:text-white transition-colors">gbmunizar@gmail.com</a>
                    </p>
                </div>
                <div class="text-center md:text-right">
                    <p class="text-gray-400 text-sm">&copy; 2025 GBM UNIZAR - I3A. All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        // ========================================
        // APPLICATION STATE
        // ========================================
        const state = {
            geometry: null,
            mesh: null,
            innerSurfaceVertices: [],
            wornVertices: [],
            unwornVertices: [],
            rimVertices: [],  // Rim excluded vertices (rendered transparent)
            rimBoundaryPoints: [],  // Boundary between rim and non-rim (for transition plane)
            inflectionPoints: [],  // Detected inflection/boundary points
            inflectionMarkers: [],  // Interactive 3D markers
            unwornCenterMarker: null,  // Marker for unworn zone center (dual-sphere method)
            wornCenterMarker: null,  // Marker for worn zone center (dual-sphere method)
            referenceSphere: null,
            unwornSphere: null,
            wornSphere: null,  // NEW: Worn sphere for dual-sphere method
            transitionPlane: null,
            wearData: null,
            fittingDiagnostics: null,  // Quality diagnostics
            octree: null,  // Spatial optimization structure
            maxWearLineObjects: [],
            detectionMethod: 'dual-sphere',  // NEW: 'hemisphere' or 'dual-sphere'
            centerDistance: null,  // NEW: Distance between worn and unworn sphere centers
            // OPTIMIZATION FIELDS
            memoryManager: null,
            stlWorker: null,
            performanceMonitor: null,
            compressionInfo: null
        };

        // ========================================
        // OPTIMIZATION INITIALIZATION
        // ========================================
        function initializeOptimizations() {
            // Initialize memory manager
            state.memoryManager = new MemoryManager();
            
            // Initialize performance monitor
            state.performanceMonitor = new PerformanceMonitor();
            
            // Initialize Web Worker for STL processing
            try {
                state.stlWorker = new Worker('stl-processor-worker.js');
                state.stlWorker.onmessage = handleWorkerMessage;
                console.log('Web Worker initialized for STL processing');
            } catch (error) {
                console.warn('Web Worker not available, falling back to main thread:', error);
                state.stlWorker = null;
            }
        }

        function handleWorkerMessage(event) {
            const { type, data, error, progress } = event.data;
            
            if (error) {
                console.error(`Worker error (${type}):`, error);
                updateStatus('complete', `Error: ${error}`);
                return;
            }

            switch (type) {
                case 'parseProgress':
                    updateStatus('processing', `Loading STL: ${progress.toFixed(1)}%`);
                    break;
                case 'parseSTL':
                    if (data) {
                        console.log(`STL parsed: ${data.vertexCount} vertices, ${data.faceCount} faces`);
                        updateStatus('complete', 'STL parsed in worker thread');
                    }
                    break;
                case 'isolateProgress':
                    updateStatus('processing', `Isolating surface: ${progress.toFixed(1)}%`);
                    break;
                default:
                    console.log(`Worker message:`, event.data);
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeOptimizations();
        });

        // ========================================
        // MODULE: GEOMETRY SERVICE
        // ========================================
        const GeometryService = {
            // Build vertex adjacency (1-ring neighborhood)
            buildAdjacency(vertices, faces) {
                const adjacency = new Map();
                vertices.forEach(v => adjacency.set(v.index, new Set()));
                
                faces.forEach(face => {
                    const [i1, i2, i3] = face.indices;
                    if (adjacency.has(i1)) {
                        adjacency.get(i1).add(i2);
                        adjacency.get(i1).add(i3);
                    }
                    if (adjacency.has(i2)) {
                        adjacency.get(i2).add(i1);
                        adjacency.get(i2).add(i3);
                    }
                    if (adjacency.has(i3)) {
                        adjacency.get(i3).add(i1);
                        adjacency.get(i3).add(i2);
                    }
                });
                
                return adjacency;
            },
            
            // Calculate triangle area using Heron's formula
            triangleArea(p1, p2, p3) {
                const a = p1.distanceTo(p2);
                const b = p2.distanceTo(p3);
                const c = p3.distanceTo(p1);
                const s = (a + b + c) / 2;
                return Math.sqrt(Math.max(0, s * (s - a) * (s - b) * (s - c)));
            },
            
            // Calculate angle between two vectors
            angleBetween(v1, v2) {
                const dot = v1.dot(v2);
                const lengths = v1.length() * v2.length();
                if (lengths < 1e-10) return 0;
                return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
            }
        };

        // ========================================
        // MODULE: CURVATURE ANALYZER
        // ========================================
        const CurvatureAnalyzer = {
            // Calculate Gaussian curvature using Meyer et al. 2003
            calculateGaussianCurvature(vertexIdx, vertexPos, adjacentFaces) {
                if (!adjacentFaces || adjacentFaces.length === 0) return 0;
                
                // Meyer 2003: K = (2π - Σθⱼ) / A_mixed
                let angleSum = 0;
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    angleSum += GeometryService.angleBetween(e1, e2);
                });
                
                const mixedArea = this.calculateMixedArea(vertexIdx, vertexPos, adjacentFaces);
                return (2 * Math.PI - angleSum) / mixedArea;
            },
            
            // Calculate mixed Voronoi area (Meyer 2003)
            calculateMixedArea(vertexIdx, vertexPos, adjacentFaces) {
                let mixedArea = 0;
                
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    const triangleArea = 0.5 * new THREE.Vector3().crossVectors(e1, e2).length();
                    
                    const angle0 = GeometryService.angleBetween(e1, e2);
                    const e1neg = e1.clone().negate();
                    const e12 = new THREE.Vector3().subVectors(v2, v1);
                    const angle1 = GeometryService.angleBetween(e1neg, e12);
                    const e2neg = e2.clone().negate();
                    const e21 = new THREE.Vector3().subVectors(v1, v2);
                    const angle2 = GeometryService.angleBetween(e2neg, e21);
                    
                    // Meyer 2003: Different area calc based on triangle type
                    if (angle0 > Math.PI / 2) {
                        mixedArea += triangleArea / 2;
                    } else if (angle1 > Math.PI / 2 || angle2 > Math.PI / 2) {
                        mixedArea += triangleArea / 4;
                    } else {
                        mixedArea += triangleArea / 3;
                    }
                });
                
                return Math.max(mixedArea, 1e-10);
            }
        };

        // ========================================
        // MODULE: PCA SERVICE
        // ========================================
        const PCAService = {
            // Compute PCA-based plane from point cloud
            computePlane(points, weights = null) {
                if (points.length < 3) {
                    console.warn('PCA: Less than 3 points, using fallback');
                    return null;
                }
                
                // Calculate weighted centroid
                // OPTIMIZED: Use for-loop for large point arrays
                const centroid = new THREE.Vector3();
                let totalWeight = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const w = weights ? weights[i] : 1.0;
                    centroid.x += p.x * w;
                    centroid.y += p.y * w;
                    centroid.z += p.z * w;
                    totalWeight += w;
                }
                centroid.divideScalar(totalWeight);
                
                // Build covariance matrix
                // OPTIMIZED: Use for-loop for large point arrays
                let xx = 0, xy = 0, xz = 0;
                let yy = 0, yz = 0, zz = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const w = weights ? weights[i] : 1.0;
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dz = p.z - centroid.z;
                    
                    xx += w * dx * dx;
                    xy += w * dx * dy;
                    xz += w * dx * dz;
                    yy += w * dy * dy;
                    yz += w * dy * dz;
                    zz += w * dz * dz;
                }
                
                // Normalize
                xx /= totalWeight;
                xy /= totalWeight;
                xz /= totalWeight;
                yy /= totalWeight;
                yz /= totalWeight;
                zz /= totalWeight;
                
                // Find the eigenvector corresponding to the SMALLEST eigenvalue
                // This is the normal direction to the best-fit plane (minimum variance direction)
                // Method: Analytic solution for 3x3 symmetric matrix eigenvalues + iterative eigenvector
                
                // Solve characteristic equation det(C - λI) = 0 for 3x3 symmetric matrix
                // λ³ - I₁λ² + I₂λ - I₃ = 0
                // where I₁ = trace, I₂ = sum of principal minors, I₃ = determinant
                
                const I1 = xx + yy + zz;  // trace
                const I2 = xx*yy + yy*zz + xx*zz - xy*xy - yz*yz - xz*xz;  // sum of 2x2 principal minors
                const I3 = xx*yy*zz + 2*xy*yz*xz - xx*yz*yz - yy*xz*xz - zz*xy*xy;  // determinant
                
                // Use Cardano's method to solve cubic: t³ + pt + q = 0 (after depressing)
                // Substitution: λ = t + I₁/3
                const p = I2 - I1*I1/3;
                const q = 2*I1*I1*I1/27 - I1*I2/3 + I3;
                
                const discriminant = q*q/4 + p*p*p/27;
                
                let eigenvalues = [];
                if (Math.abs(discriminant) < 1e-10 || discriminant >= 0) {
                    // One real root or three real roots with discriminant ~0
                    // Use trigonometric solution for real roots
                    const r = Math.sqrt(-p/3);
                    const theta = Math.acos(-q / (2 * r * r * r)) / 3;
                    eigenvalues = [
                        2 * r * Math.cos(theta) + I1/3,
                        2 * r * Math.cos(theta + 2*Math.PI/3) + I1/3,
                        2 * r * Math.cos(theta + 4*Math.PI/3) + I1/3
                    ];
                } else {
                    // Three distinct real roots
                    const r = Math.sqrt(-p/3);
                    const theta = Math.acos(-q / (2 * r * r * r)) / 3;
                    eigenvalues = [
                        2 * r * Math.cos(theta) + I1/3,
                        2 * r * Math.cos(theta + 2*Math.PI/3) + I1/3,
                        2 * r * Math.cos(theta + 4*Math.PI/3) + I1/3
                    ];
                }
                
                // Sort eigenvalues to find the smallest
                eigenvalues.sort((a, b) => a - b);
                const lambda_min = eigenvalues[0];
                
                console.log(`PCA eigenvalues: [${eigenvalues[0].toFixed(6)}, ${eigenvalues[1].toFixed(6)}, ${eigenvalues[2].toFixed(6)}]`);
                
                // Find eigenvector for λ_min by solving (C - λ_min·I)v = 0
                // Use null space computation via cross products of rows
                const A11 = xx - lambda_min;
                const A12 = xy;
                const A13 = xz;
                const A22 = yy - lambda_min;
                const A23 = yz;
                const A33 = zz - lambda_min;
                
                const row0 = new THREE.Vector3(A11, A12, A13);
                const row1 = new THREE.Vector3(A12, A22, A23);
                const row2 = new THREE.Vector3(A13, A23, A33);
                
                // Cross products of rows give vectors in the null space
                const n0 = new THREE.Vector3().crossVectors(row0, row1);
                const n1 = new THREE.Vector3().crossVectors(row1, row2);
                const n2 = new THREE.Vector3().crossVectors(row2, row0);
                
                // Choose the one with largest magnitude (most stable)
                let normal;
                const len0 = n0.length();
                const len1 = n1.length();
                const len2 = n2.length();
                
                if (len0 >= len1 && len0 >= len2 && len0 > 1e-10) {
                    normal = n0.normalize();
                } else if (len1 >= len2 && len1 > 1e-10) {
                    normal = n1.normalize();
                } else if (len2 > 1e-10) {
                    normal = n2.normalize();
                } else {
                    // Degenerate case: use axis with smallest diagonal element
                    console.warn('PCA: Degenerate covariance matrix, using fallback normal');
                    if (xx <= yy && xx <= zz) {
                        normal = new THREE.Vector3(1, 0, 0);
                    } else if (yy <= zz) {
                        normal = new THREE.Vector3(0, 1, 0);
                    } else {
                        normal = new THREE.Vector3(0, 0, 1);
                    }
                }
                
                // Ensure normal points away from sphere center if available
                // (this ensures consistent orientation)
                if (state.unwornSphere && state.unwornSphere.center) {
                    const toSphere = new THREE.Vector3().subVectors(state.unwornSphere.center, centroid);
                    if (normal.dot(toSphere) < 0) {
                        normal.negate();
                    }
                }
                
                // Plane equation: normal · (p - centroid) = 0
                // Or: normal · p = d, where d = normal · centroid
                const d = normal.dot(centroid);
                
                console.log(`PCA plane calculated: normal=(${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}), centroid=(${centroid.x.toFixed(4)}, ${centroid.y.toFixed(4)}, ${centroid.z.toFixed(4)})`);
                
                return { normal, d, centroid };
            }
        };

        // ========================================
        // MODULE: FITTING SERVICE
        // ========================================
        const FittingService = {
            // Fit sphere using Gauss-Newton with LM damping
            fitSphereGaussNewton(vertices) {
                // Initialize center (geometric centroid)
                let center = new THREE.Vector3();
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Initialize radius
                let radius = 0;
                vertices.forEach(p => radius += p.distanceTo(center));
                radius /= vertices.length;
                
                const maxIterations = 20;
                const tolerance = 1e-6;
                let lambda = 0.001;
                let prevResidual = Infinity;
                let iterations = 0;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    iterations++;
                    const n = vertices.length;
                    const J = [];
                    const residuals = [];
                    let residualSum = 0;
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        const residual = dist - radius;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        if (dist > 1e-10) {
                            J.push([-dx/dist, -dy/dist, -dz/dist, -1]);
                        } else {
                            J.push([0, 0, 0, -1]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        break;
                    }
                    
                    // Compute J^T * J
                    const JTJ = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add LM damping
                    for (let i = 0; i < 4; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r
                    const JTr = [0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    const delta = this.solveLinearSystem4x4(JTJ, JTr.map(x => -x));
                    if (!delta) {
                        lambda *= 10;
                        continue;
                    }
                    
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadius = radius + delta[3];
                    
                    if (newRadius > 0) {
                        center = newCenter;
                        radius = newRadius;
                        lambda *= 0.1;
                    } else {
                        lambda *= 10;
                    }
                    
                    prevResidual = currentResidual;
                }
                
                // Calculate final diagnostics
                const residuals = [];
                let rmsError = 0;
                vertices.forEach(p => {
                    const dist = p.distanceTo(center);
                    const residual = Math.abs(dist - radius);
                    residuals.push(residual);
                    rmsError += residual * residual;
                });
                rmsError = Math.sqrt(rmsError / vertices.length);
                
                return {
                    center,
                    radius,
                    method: 'Gauss-Newton + LM',
                    iterations,
                    rmsError,
                    residuals,
                    inliers: vertices.length
                };
            },
            
            // Fit sphere using RANSAC + LM refinement
            fitSphereRANSAC(vertices) {
                const maxIterations = 100;
                // FIXED: Threshold must match typical acetabular cup scale (30-50mm radius)
                // Use 1.5mm tolerance (about 3-5% of radius) instead of 0.5mm
                const threshold = 1.5;  // mm tolerance for inliers
                const minSampleSize = Math.min(20, Math.floor(vertices.length * 0.1));
                
                let bestFit = null;
                let bestInlierCount = 0;
                let bestInliers = [];  // FIXED: Initialize bestInliers array
                
                console.log(`RANSAC: Starting with ${vertices.length} points, ${maxIterations} iterations, threshold=${threshold}mm`);
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Random sample
                    const sample = [];
                    const usedIndices = new Set();
                    while (sample.length < minSampleSize && usedIndices.size < vertices.length) {
                        const idx = Math.floor(Math.random() * vertices.length);
                        if (!usedIndices.has(idx)) {
                            sample.push(vertices[idx]);
                            usedIndices.add(idx);
                        }
                    }
                    
                    if (sample.length < 4) continue;  // Need at least 4 points
                    
                    // Fit to sample
                    const fit = this.fitSphereGaussNewton(sample);
                    
                    // Count inliers
                    const inliers = [];
                    vertices.forEach(p => {
                        const dist = p.distanceTo(fit.center);
                        const residual = Math.abs(dist - fit.radius);
                        if (residual < threshold) {
                            inliers.push(p);
                        }
                    });
                    
                    // FIXED: Proper comparison and storage
                    if (inliers.length > bestInlierCount) {
                        bestInlierCount = inliers.length;
                        bestFit = fit;
                        bestInliers = inliers;
                    }
                }
                
                console.log(`RANSAC: Best consensus has ${bestInlierCount} inliers (${(bestInlierCount/vertices.length*100).toFixed(1)}%)`);
                
                // FIXED: Guard against failure cases
                if (bestInliers.length < minSampleSize) {
                    console.warn(`RANSAC failed to find consensus, falling back to Gauss-Newton on all points`);
                    return this.fitSphereGaussNewton(vertices);
                }
                
                // Refine with all inliers
                const refinedFit = this.fitSphereGaussNewton(bestInliers);
                refinedFit.method = 'RANSAC + LM';
                refinedFit.inliers = bestInlierCount;
                return refinedFit;
            },
            
            // Solve 4x4 linear system using Gaussian elimination
            solveLinearSystem4x4(A, b) {
                // Create augmented matrix [A|b]
                const aug = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination
                for (let i = 0; i < 4; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < 4; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    // Check for singular matrix
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    // Eliminate
                    for (let k = i + 1; k < 4; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j < 5; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                // Back substitution
                const x = [0, 0, 0, 0];
                for (let i = 3; i >= 0; i--) {
                    x[i] = aug[i][4];
                    for (let j = i + 1; j < 4; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            },
            
            // Solve 6x6 linear system using Gaussian elimination (for ellipsoid fitting)
            solveLinearSystem6x6(A, b) {
                const aug = A.map((row, i) => [...row, b[i]]);
                
                for (let i = 0; i < 6; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < 6; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    for (let k = i + 1; k < 6; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j < 7; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                const x = [0, 0, 0, 0, 0, 0];
                for (let i = 5; i >= 0; i--) {
                    x[i] = aug[i][6];
                    for (let j = i + 1; j < 6; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            },
            
            // Fit ellipsoid using Gauss-Newton with LM damping
            // Parameters: center (cx, cy, cz) + semi-axes (rx, ry, rz)
            // Ellipsoid equation: (x-cx)²/rx² + (y-cy)²/ry² + (z-cz)²/rz² = 1
            fitEllipsoidGaussNewton(vertices) {
                // Initialize center (geometric centroid)
                let center = new THREE.Vector3();
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Initialize radii from PCA of point cloud
                const centered = vertices.map(p => new THREE.Vector3(p.x - center.x, p.y - center.y, p.z - center.z));
                
                // Simple PCA: compute variance along each axis
                let vx = 0, vy = 0, vz = 0;
                centered.forEach(p => {
                    vx += p.x * p.x;
                    vy += p.y * p.y;
                    vz += p.z * p.z;
                });
                vx = Math.sqrt(vx / vertices.length);
                vy = Math.sqrt(vy / vertices.length);
                vz = Math.sqrt(vz / vertices.length);
                
                let radii = { x: vx, y: vy, z: vz };
                
                const maxIterations = 30;
                const tolerance = 1e-6;
                let lambda = 0.001;
                let prevResidual = Infinity;
                let iterations = 0;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    iterations++;
                    const n = vertices.length;
                    const J = [];
                    const residuals = [];
                    let residualSum = 0;
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        
                        // Ellipsoid distance: f(p) = sqrt((dx/rx)² + (dy/ry)² + (dz/rz)²) - 1
                        const term_x = dx / radii.x;
                        const term_y = dy / radii.y;
                        const term_z = dz / radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const residual = f - 1.0;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        // Jacobian: ∂f/∂params
                        // params = [cx, cy, cz, rx, ry, rz]
                        if (f > 1e-10) {
                            const df_dcx = -term_x / (radii.x * f);
                            const df_dcy = -term_y / (radii.y * f);
                            const df_dcz = -term_z / (radii.z * f);
                            const df_drx = -dx * term_x / (radii.x * radii.x * f);
                            const df_dry = -dy * term_y / (radii.y * radii.y * f);
                            const df_drz = -dz * term_z / (radii.z * radii.z * f);
                            
                            J.push([df_dcx, df_dcy, df_dcz, df_drx, df_dry, df_drz]);
                        } else {
                            J.push([0, 0, 0, 0, 0, 0]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        break;
                    }
                    
                    // Compute J^T * J
                    const JTJ = [];
                    for (let i = 0; i < 6; i++) {
                        JTJ[i] = [];
                        for (let j = 0; j < 6; j++) {
                            JTJ[i][j] = 0;
                        }
                    }
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 6; j++) {
                            for (let k = 0; k < 6; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add LM damping
                    for (let i = 0; i < 6; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r
                    const JTr = [0, 0, 0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 6; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    const delta = this.solveLinearSystem6x6(JTJ, JTr.map(x => -x));
                    if (!delta) {
                        lambda *= 10;
                        continue;
                    }
                    
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadii = {
                        x: radii.x + delta[3],
                        y: radii.y + delta[4],
                        z: radii.z + delta[5]
                    };
                    
                    if (newRadii.x > 0 && newRadii.y > 0 && newRadii.z > 0) {
                        center = newCenter;
                        radii = newRadii;
                        lambda *= 0.1;
                    } else {
                        lambda *= 10;
                    }
                    
                    prevResidual = currentResidual;
                }
                
                // Calculate final diagnostics
                const finalResiduals = [];
                let rmsError = 0;
                vertices.forEach(p => {
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    const dz = p.z - center.z;
                    const term_x = dx / radii.x;
                    const term_y = dy / radii.y;
                    const term_z = dz / radii.z;
                    const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                    const residual = Math.abs(f - 1.0);
                    finalResiduals.push(residual);
                    rmsError += residual * residual;
                });
                rmsError = Math.sqrt(rmsError / vertices.length);
                
                // Calculate sphericity index (how close to a perfect sphere)
                const avgRadius = (radii.x + radii.y + radii.z) / 3;
                const minRadius = Math.min(radii.x, radii.y, radii.z);
                const maxRadius = Math.max(radii.x, radii.y, radii.z);
                const sphericity = minRadius / maxRadius; // 1.0 = perfect sphere, <1.0 = ellipsoidal
                const sphericityPercent = sphericity * 100;
                const ellipsoidalityPercent = (1 - sphericity) * 100;
                
                return {
                    center,
                    radii,
                    radius: avgRadius,
                    method: 'Ellipsoid Gauss-Newton + LM',
                    iterations,
                    rmsError,
                    residuals: finalResiduals,
                    inliers: vertices.length,
                    sphericity,
                    sphericityPercent,
                    ellipsoidalityPercent,
                    isEllipsoid: true
                };
            },
            
            // Fit ellipsoid using RANSAC + LM refinement
            fitEllipsoidRANSAC(vertices) {
                const maxIterations = 100;
                const threshold = 1.5;
                const minSampleSize = Math.min(30, Math.floor(vertices.length * 0.1));
                
                let bestFit = null;
                let bestInlierCount = 0;
                let bestInliers = [];
                
                console.log(`RANSAC Ellipsoid: Starting with ${vertices.length} points, ${maxIterations} iterations`);
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    const sample = [];
                    const usedIndices = new Set();
                    while (sample.length < minSampleSize && usedIndices.size < vertices.length) {
                        const idx = Math.floor(Math.random() * vertices.length);
                        if (!usedIndices.has(idx)) {
                            sample.push(vertices[idx]);
                            usedIndices.add(idx);
                        }
                    }
                    
                    if (sample.length < 6) continue;
                    
                    const fit = this.fitEllipsoidGaussNewton(sample);
                    
                    const inliers = [];
                    vertices.forEach(p => {
                        const dx = p.x - fit.center.x;
                        const dy = p.y - fit.center.y;
                        const dz = p.z - fit.center.z;
                        const term_x = dx / fit.radii.x;
                        const term_y = dy / fit.radii.y;
                        const term_z = dz / fit.radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const residual = Math.abs(f - 1.0);
                        if (residual < threshold) {
                            inliers.push(p);
                        }
                    });
                    
                    if (inliers.length > bestInlierCount) {
                        bestInlierCount = inliers.length;
                        bestFit = fit;
                        bestInliers = inliers;
                    }
                }
                
                console.log(`RANSAC Ellipsoid: Best consensus has ${bestInlierCount} inliers (${(bestInlierCount/vertices.length*100).toFixed(1)}%)`);
                
                if (bestInliers.length < minSampleSize) {
                    console.warn(`RANSAC Ellipsoid failed, falling back to Gauss-Newton`);
                    return this.fitEllipsoidGaussNewton(vertices);
                }
                
                const refinedFit = this.fitEllipsoidGaussNewton(bestInliers);
                refinedFit.method = 'Ellipsoid RANSAC + LM';
                refinedFit.inliers = bestInlierCount;
                return refinedFit;
            }
        };

        // Initialize Main Viewer
        const viewerContainer = document.getElementById('viewer-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            viewerContainer.clientWidth / viewerContainer.clientHeight,
            0.1,
            10000
        );
        camera.position.set(50, 50, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        const w = Math.max(viewerContainer.clientWidth, 600);
        const h = Math.max(viewerContainer.clientHeight, 600);
        renderer.setSize(w, h);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.domElement.style.display = 'block';
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        console.log(`Renderer initialized: ${w}x${h}, canvas=`, renderer.domElement);
        viewerContainer.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(50, 50, 50);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-50, -50, -50);
        scene.add(directionalLight2);

        // Initialize Sphere Viewer
        const sphereScene = new THREE.Scene();
        sphereScene.background = new THREE.Color(0x1a202c);
        
        const sphereCamera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('sphere-viewer-container').clientWidth / 
            document.getElementById('sphere-viewer-container').clientHeight,
            0.1,
            1000
        );
        sphereCamera.position.set(50, 50, 50);

        const sphereRenderer = new THREE.WebGLRenderer({ antialias: true });
        sphereRenderer.setSize(
            document.getElementById('sphere-viewer-container').clientWidth,
            document.getElementById('sphere-viewer-container').clientHeight
        );
        document.getElementById('sphere-viewer-container').appendChild(sphereRenderer.domElement);

        const sphereControls = new OrbitControls(sphereCamera, sphereRenderer.domElement);
        sphereControls.enableDamping = true;
        sphereControls.dampingFactor = 0.05;

        // Lighting for sphere viewer
        const sphereAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
        sphereScene.add(sphereAmbientLight);

        const sphereDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sphereDirectionalLight.position.set(50, 50, 50);
        sphereScene.add(sphereDirectionalLight);

        // Initialize Volumetric Wear Viewer (Third Viewer)
        const volumetricScene = new THREE.Scene();
        volumetricScene.background = new THREE.Color(0x1a202c);
        
        const volumetricCamera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('volumetric-viewer-container').clientWidth / 
            document.getElementById('volumetric-viewer-container').clientHeight,
            0.1,
            1000
        );
        volumetricCamera.position.set(50, 50, 50);

        const volumetricRenderer = new THREE.WebGLRenderer({ antialias: true });
        volumetricRenderer.setSize(
            document.getElementById('volumetric-viewer-container').clientWidth,
            document.getElementById('volumetric-viewer-container').clientHeight
        );
        document.getElementById('volumetric-viewer-container').appendChild(volumetricRenderer.domElement);

        const volumetricControls = new OrbitControls(volumetricCamera, volumetricRenderer.domElement);
        volumetricControls.enableDamping = true;
        volumetricControls.dampingFactor = 0.05;

        // Lighting for volumetric viewer
        const volumetricAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
        volumetricScene.add(volumetricAmbientLight);

        const volumetricDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        volumetricDirectionalLight.position.set(50, 50, 50);
        volumetricScene.add(volumetricDirectionalLight);

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            sphereControls.update();
            volumetricControls.update();
            renderer.render(scene, camera);
            sphereRenderer.render(sphereScene, sphereCamera);
            volumetricRenderer.render(volumetricScene, volumetricCamera);
        }
        animate();
        console.log('Animation loop started');

        // Handle Window Resize
        window.addEventListener('resize', () => {
            const viewerWidth = document.getElementById('viewer-container').clientWidth;
            const viewerHeight = document.getElementById('viewer-container').clientHeight;
            camera.aspect = viewerWidth / viewerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerWidth, viewerHeight);

            const sphereViewerWidth = document.getElementById('sphere-viewer-container').clientWidth;
            const sphereViewerHeight = document.getElementById('sphere-viewer-container').clientHeight;
            sphereCamera.aspect = sphereViewerWidth / sphereViewerHeight;
            sphereCamera.updateProjectionMatrix();
            sphereRenderer.setSize(sphereViewerWidth, sphereViewerHeight);

            const volumetricViewerWidth = document.getElementById('volumetric-viewer-container').clientWidth;
            const volumetricViewerHeight = document.getElementById('volumetric-viewer-container').clientHeight;
            volumetricCamera.aspect = volumetricViewerWidth / volumetricViewerHeight;
            volumetricCamera.updateProjectionMatrix();
            volumetricRenderer.setSize(volumetricViewerWidth, volumetricViewerHeight);
        });

        // Detection Method Change Handler
        document.getElementById('detection-method').addEventListener('change', (e) => {
            const method = e.target.value;
            state.detectionMethod = method;
            const desc = document.getElementById('detection-method-desc');
            const legendWornSphere = document.getElementById('legend-worn-sphere');
            const dualSphereOptions = document.getElementById('dual-sphere-options');
            const legendUnwornDesc = document.getElementById('legend-unworn-desc');
            const legendWornDesc = document.getElementById('legend-worn-desc');
            
            if (method === 'hemisphere') {
                desc.textContent = 'Divides surface into hemispheres based on axis of maximum geometric dispersion.';
                legendWornSphere.style.display = 'none';
                dualSphereOptions.classList.add('hidden');
                legendUnwornDesc.textContent = '(closer to centroid)';
                legendWornDesc.textContent = '(farther from centroid)';
            } else if (method === 'dual-sphere') {
                desc.textContent = 'Uses vertex normal convergence to fit two independent spheres (worn and unworn) with different centers.';
                legendWornSphere.style.display = 'flex';
                dualSphereOptions.classList.remove('hidden');
                legendUnwornDesc.textContent = '(normals converge farther from ref)';
                legendWornDesc.textContent = '(normals converge closer to ref)';
            }
        });

        // Cleanup function to reset all state and visualizations when loading new file
        function cleanupPreviousAnalysis() {
            console.log('=== Cleaning up previous analysis ===');
            
            // Remove mesh completely and dispose resources
            if (state.mesh) {
                scene.remove(state.mesh);
                if (state.mesh.geometry) {
                    state.mesh.geometry.dispose();
                }
                if (state.mesh.material) {
                    if (Array.isArray(state.mesh.material)) {
                        state.mesh.material.forEach(m => m.dispose?.());
                    } else {
                        state.mesh.material.dispose();
                    }
                }
                state.mesh = null;
            }
            
            // Dispose old geometry
            if (state.geometry && state.geometry !== state.mesh?.geometry) {
                state.geometry.dispose?.();
            }
            
            // Remove bounding box helper
            if (state.bboxHelper) {
                scene.remove(state.bboxHelper);
                state.bboxHelper = null;
            }
            
            // Remove center markers (from dual-sphere method)
            if (state.unwornCenterMarker) {
                scene.remove(state.unwornCenterMarker);
                state.unwornCenterMarker = null;
            }
            if (state.wornCenterMarker) {
                scene.remove(state.wornCenterMarker);
                state.wornCenterMarker = null;
            }
            
            // Remove sphere visualizations
            if (state.sphereMesh) {
                scene.remove(state.sphereMesh);
                state.sphereMesh = null;
            }
            if (state.wornSphereMesh) {
                scene.remove(state.wornSphereMesh);
                state.wornSphereMesh = null;
            }
            
            // Remove wear volume visualization
            if (state.wearVolumeMesh) {
                scene.remove(state.wearVolumeMesh);
                state.wearVolumeMesh = null;
            }
            
            // Remove max wear line visualization
            if (state.maxWearLine) {
                scene.remove(state.maxWearLine);
                state.maxWearLine = null;
            }
            if (state.maxWearMarkerWorn) {
                scene.remove(state.maxWearMarkerWorn);
                state.maxWearMarkerWorn = null;
            }
            if (state.maxWearMarkerSphere) {
                scene.remove(state.maxWearMarkerSphere);
                state.maxWearMarkerSphere = null;
            }
            
            // Remove inflection markers
            if (state.inflectionMarkers) {
                state.inflectionMarkers.forEach(marker => scene.remove(marker));
                state.inflectionMarkers = [];
            }
            
            // Remove transition plane
            if (state.transitionPlaneMesh) {
                scene.remove(state.transitionPlaneMesh);
                state.transitionPlaneMesh = null;
            }
            
            // Remove center distance line
            if (state.centerDistanceLine) {
                scene.remove(state.centerDistanceLine);
                state.centerDistanceLine = null;
            }
            
            // Clear sphere viewer
            while (sphereScene.children.length > 0) {
                sphereScene.remove(sphereScene.children[0]);
            }
            // Re-add lights to sphere scene
            const sphereAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            const sphereDirectional = new THREE.DirectionalLight(0xffffff, 0.8);
            sphereDirectional.position.set(5, 10, 7.5);
            sphereScene.add(sphereAmbient);
            sphereScene.add(sphereDirectional);
            
            // Clear volumetric viewer
            while (volumetricScene.children.length > 0) {
                volumetricScene.remove(volumetricScene.children[0]);
            }
            // Re-add lights to volumetric scene
            const volumetricAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            const volumetricDirectional = new THREE.DirectionalLight(0xffffff, 0.8);
            volumetricDirectional.position.set(5, 10, 7.5);
            volumetricScene.add(volumetricAmbient);
            volumetricScene.add(volumetricDirectional);
            
            // Show loading overlays for both viewers
            document.getElementById('volumetric-loading-overlay').classList.remove('hidden');
            
            // Reset state variables
            state.innerSurfaceVertices = null;
            state.outerSurfaceVertices = null;
            state.adjacency = null;
            state.wornVertices = null;
            state.unwornVertices = null;
            state.rimVertices = null;
            state.rimBoundaryPoints = null;
            state.inflectionPoints = null;
            state.unwornSphere = null;
            state.wornSphere = null;
            state.transitionPlane = null;
            state.fittingDiagnostics = null;
            state.wearMetrics = null;
            state.centerDistance = null;
            state.preliminaryWornCenter = null;
            state.preliminaryUnwornCenter = null;
            
            // Hide legend items for dual-sphere specific elements
            document.getElementById('legend-worn-sphere').style.display = 'none';
            document.getElementById('legend-unworn-center').style.display = 'none';
            document.getElementById('legend-worn-center').style.display = 'none';
            
            // Reset diagnostics panel
            document.getElementById('diag-method').textContent = '-';
            document.getElementById('diag-rms').textContent = '-';
            document.getElementById('diag-iterations').textContent = '-';
            document.getElementById('diag-inliers').textContent = '-';
            document.getElementById('diag-residual-range').textContent = '-';
            document.getElementById('diag-convergence').textContent = '-';
            document.getElementById('diag-unworn-match').textContent = '-';
            
            // Reset results panel
            document.getElementById('metric-volume').textContent = '0.00 mm³';
            document.getElementById('metric-linear-mean').textContent = '0.00 mm';
            document.getElementById('metric-linear-max').textContent = '0.00 mm';
            document.getElementById('metric-linear-min').textContent = '0.00 mm';
            document.getElementById('sphere-radius').textContent = '-';
            document.getElementById('sphere-center').textContent = '-';
            document.getElementById('worn-area').textContent = '-';
            document.getElementById('unworn-area').textContent = '-';
            document.getElementById('detection-method-used').textContent = '-';
            
            // Hide optional result fields
            document.getElementById('worn-sphere-info').classList.add('hidden');
            document.getElementById('worn-sphere-radius-info').classList.add('hidden');
            document.getElementById('center-distance-info').classList.add('hidden');
            document.getElementById('quality-diagnostics').classList.add('hidden');
            document.getElementById('results-data').classList.add('hidden');
            document.getElementById('results-container').classList.remove('hidden');
            
            // Disable buttons for subsequent steps
            enableButton('btn-detect-wear', false);
            enableButton('btn-fit-sphere', false);
            enableButton('btn-calculate', false);
            enableButton('btn-precompress', false);
            setPrecompressSummary('Waiting for STL...');
            document.getElementById('precompress-hint').textContent = 'Applies quantization and vertex deduplication.';
            
            console.log('Cleanup complete');
        }

        // ========================================
        // PROGRESS TRACKING
        // ========================================
        const progressState = {
            startTime: null,
            lastUpdateTime: null,
            lastLoadedBytes: 0,
            totalBytes: 0,
            loadedBytes: 0,
            updateInterval: null
        };

        function showProgressBar(totalBytes) {
            const container = document.getElementById('progress-container');
            container.classList.remove('hidden');
            
            progressState.totalBytes = totalBytes;
            progressState.loadedBytes = 0;
            progressState.startTime = Date.now();
            progressState.lastUpdateTime = Date.now();
            progressState.lastLoadedBytes = 0;
            
            document.getElementById('progress-total').textContent = (totalBytes / (1024 * 1024)).toFixed(1) + ' MB';
            document.getElementById('progress-eta').style.display = 'block';
        }

        function hideProgressBar() {
            const container = document.getElementById('progress-container');
            container.classList.add('hidden');
            if (progressState.updateInterval) {
                clearInterval(progressState.updateInterval);
            }
        }

        function setPrecompressSummary(text) {
            const summary = document.getElementById('precompress-summary');
            if (summary) {
                summary.textContent = text;
            }
        }

        function updateProgressBar(loadedBytes) {
            progressState.loadedBytes = loadedBytes;
            const percent = (loadedBytes / progressState.totalBytes) * 100;
            
            const elapsed = (Date.now() - progressState.startTime) / 1000;
            const speed = loadedBytes / (1024 * 1024) / elapsed; // MB/s
            const remainingBytes = progressState.totalBytes - loadedBytes;
            const eta = remainingBytes / (1024 * 1024) / (speed || 0.001); // seconds
            
            // Update UI
            document.getElementById('progress-bar').style.width = percent + '%';
            document.getElementById('progress-percent').textContent = Math.round(percent) + '%';
            document.getElementById('progress-loaded').textContent = (loadedBytes / (1024 * 1024)).toFixed(1) + ' MB';
            document.getElementById('progress-speed').textContent = speed.toFixed(2) + ' MB/s';
            
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = Math.floor(elapsed % 60);
            const etaMin = Math.floor(eta / 60);
            const etaSec = Math.floor(eta % 60);
            
            const timeStr = (elapsedMin > 0 ? elapsedMin + 'm ' : '') + elapsedSec + 's' + 
                            ' / ' + (etaMin > 0 ? etaMin + 'm ' : '') + etaSec + 's';
            document.getElementById('progress-time').textContent = timeStr;
            
            // Format ETA display
            let etaDisplay = '';
            if (eta < 60) {
                etaDisplay = `⏱️ Estimated time: ${Math.ceil(eta)}s remaining`;
            } else if (eta < 3600) {
                const min = Math.floor(eta / 60);
                const sec = Math.floor(eta % 60);
                etaDisplay = `⏱️ Estimated time: ${min}m ${sec}s remaining`;
            } else {
                const hours = Math.floor(eta / 3600);
                const min = Math.floor((eta % 3600) / 60);
                etaDisplay = `⏱️ Estimated time: ${hours}h ${min}m remaining`;
            }
            
            document.getElementById('eta-text').textContent = etaDisplay;
        }

        function simplifyGeometryForPreview(geometry, targetVertices = 200000) {
            const positions = geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            if (vertexCount <= targetVertices) {
                return geometry;
            }

            // Sample triangles uniformly to keep topology visually coherent
            const triangleCount = positions.length / 9;
            const targetTriangles = Math.max(1, Math.floor(targetVertices / 3));
            const strideTriangles = Math.max(1, Math.floor(triangleCount / targetTriangles));
            const sampled = [];
            for (let i = 0; i < positions.length; i += strideTriangles * 9) {
                sampled.push(
                    positions[i], positions[i + 1], positions[i + 2],
                    positions[i + 3], positions[i + 4], positions[i + 5],
                    positions[i + 6], positions[i + 7], positions[i + 8]
                );
            }

            const simplifiedGeometry = new THREE.BufferGeometry();
            simplifiedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(sampled), 3));
            simplifiedGeometry.computeVertexNormals();
            simplifiedGeometry.computeBoundingBox();
            simplifiedGeometry.computeBoundingSphere();
            simplifiedGeometry.userData.previewSimplified = {
                originalVertices: vertexCount,
                retainedVertices: sampled.length / 3,
                stride: strideTriangles
            };
            return simplifiedGeometry;
        }

        async function runManualPrecompression() {
            if (!state.geometry) {
                updateStatus('complete', 'Load an STL before running precompression');
                return;
            }

            const positions = state.geometry.attributes.position.array;
            const originalVertices = positions.length / 3;
            if (originalVertices === 0) {
                updateStatus('complete', 'No geometry data available for precompression');
                return;
            }

            showLoading(true);
            updateStatus('processing', 'Applying manual precompression...');

            const tolerance = 0.0005; // quantization grid size
            const precision = 1 / tolerance;
            const keyToVertex = new Map();
            const newPositions = [];

            const startTime = performance.now();

            try {
                for (let i = 0; i < positions.length; i += 9) {
                    const v1 = {
                        x: positions[i],
                        y: positions[i + 1],
                        z: positions[i + 2]
                    };
                    const v2 = {
                        x: positions[i + 3],
                        y: positions[i + 4],
                        z: positions[i + 5]
                    };
                    const v3 = {
                        x: positions[i + 6],
                        y: positions[i + 7],
                        z: positions[i + 8]
                    };

                    const getQuantized = (v) => {
                        const key = `${Math.round(v.x * precision)},${Math.round(v.y * precision)},${Math.round(v.z * precision)}`;
                        if (!keyToVertex.has(key)) {
                            keyToVertex.set(key, { x: v.x, y: v.y, z: v.z });
                        }
                        return keyToVertex.get(key);
                    };

                    const q1 = getQuantized(v1);
                    const q2 = getQuantized(v2);
                    const q3 = getQuantized(v3);

                    // Skip degenerate triangles created by quantization collapse
                    if ((q1 === q2) || (q1 === q3) || (q2 === q3)) {
                        continue;
                    }

                    newPositions.push(
                        q1.x, q1.y, q1.z,
                        q2.x, q2.y, q2.z,
                        q3.x, q3.y, q3.z
                    );
                }

                if (newPositions.length === 0) {
                    updateStatus('complete', 'Precompression skipped: geometry collapsed with current tolerance');
                    return;
                }

                const compressedGeometry = new THREE.BufferGeometry();
                compressedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                compressedGeometry.computeVertexNormals();
                compressedGeometry.computeBoundingBox();
                compressedGeometry.computeBoundingSphere();

                if (state.mesh) {
                    state.mesh.geometry.dispose?.();
                    state.mesh.geometry = compressedGeometry;
                } else {
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x4299e1,
                        flatShading: false,
                        side: THREE.DoubleSide
                    });
                    state.mesh = new THREE.Mesh(compressedGeometry, material);
                    scene.add(state.mesh);
                }

                if (state.geometry && state.geometry.dispose) {
                    state.geometry.dispose();
                }
                state.geometry = compressedGeometry;

                const reducedVertices = newPositions.length / 3;
                const reductionPercent = ((1 - reducedVertices / originalVertices) * 100).toFixed(1);
                const duration = performance.now() - startTime;

                state.compressionInfo = {
                    originalVertices,
                    reducedVertices,
                    reductionPercent,
                    tolerance
                };

                setPrecompressSummary(`Compressed ${originalVertices.toLocaleString()} → ${reducedVertices.toLocaleString()} vertices (${reductionPercent}% reduction)`);
                document.getElementById('precompress-hint').textContent = 'Precompression applied (quantization + collapsed degenerate triangles).';

                updateStatus('complete', `Precompression done in ${duration.toFixed(1)} ms (${reductionPercent}% fewer vertices)`);
                window.dashboard?.logOperation?.('Precompression', duration);
            } catch (error) {
                console.error('Precompression failed:', error);
                updateStatus('complete', `Precompression failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        // File Upload Handler with Progress Tracking
        document.getElementById('file-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            state.performanceMonitor?.startMeasure('STL-loading');
            updateStatus('processing', 'Loading STL file...');
            showLoading(true);
            
            // Show progress bar
            showProgressBar(file.size);
            
            // Clean up previous analysis before loading new file
            cleanupPreviousAnalysis();

            try {
                // For large files (>50MB), use streaming loader with progress
                let arrayBuffer;
                if (file.size > 50 * 1024 * 1024) {
                    console.log(`Large file detected (${(file.size / (1024 * 1024)).toFixed(1)}MB), using streaming loader...`);
                    
                    arrayBuffer = await new Promise((resolve, reject) => {
                        const chunkSize = 1024 * 1024; // 1MB chunks
                        let offset = 0;
                        const chunks = [];
                        const reader = new FileReader();

                        const readChunk = () => {
                            if (offset >= file.size) {
                                const combinedArray = new Uint8Array(file.size);
                                let pos = 0;
                                for (const chunk of chunks) {
                                    combinedArray.set(chunk, pos);
                                    pos += chunk.length;
                                }
                                // STLLoader expects a true ArrayBuffer; Uint8Array triggers DataView errors
                                resolve(combinedArray.buffer);
                                return;
                            }

                            const chunk = file.slice(offset, offset + chunkSize);
                            reader.onload = (e) => {
                                const chunkData = new Uint8Array(e.target.result);
                                chunks.push(chunkData);
                                offset += chunkSize;
                                
                                // Update progress
                                updateProgressBar(offset);

                                readChunk();
                            };

                            reader.onerror = () => reject(reader.error);
                            reader.readAsArrayBuffer(chunk);
                        };

                        readChunk();
                    });
                } else {
                    // For smaller files, use standard FileReader with progress
                    arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onprogress = (e) => {
                            if (e.lengthComputable) {
                                updateProgressBar(e.loaded);
                            }
                        };
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    });
                }

                // Validate ArrayBuffer integrity
                console.log(`ArrayBuffer size: ${arrayBuffer.byteLength} bytes, expected: ${file.size}`);
                if (arrayBuffer.byteLength === 0) {
                    throw new Error('ArrayBuffer is empty after loading');
                }

                const loader = new STLLoader();
                let geometry = null;
                try {
                    geometry = loader.parse(arrayBuffer);
                } catch (parseError) {
                    throw new Error(`STL parsing failed: ${parseError.message}`);
                }

                if (!geometry || !geometry.attributes.position) {
                    throw new Error('Parsed geometry is invalid or missing position attributes');
                }

                console.log(`Raw geometry: ${geometry.attributes.position.count} vertices`);

                // Auto-simplify extremely large models for rendering stability
                let renderGeometry = geometry;
                if (geometry.attributes.position.count > 400000) {
                    renderGeometry = simplifyGeometryForPreview(geometry, 200000);
                    console.warn(`Preview simplified: ${geometry.attributes.position.count} → ${renderGeometry.attributes.position.count} vertices (stride ${renderGeometry.userData.previewSimplified?.stride})`);
                    // Dispose original if simplified
                    if (geometry !== renderGeometry) {
                        geometry.dispose?.();
                    }
                }
                
                // Center and scale geometry
                renderGeometry.computeBoundingBox();
                const center = new THREE.Vector3();
                renderGeometry.boundingBox.getCenter(center);
                renderGeometry.translate(-center.x, -center.y, -center.z);
                
                // Compute normals
                renderGeometry.computeVertexNormals();
                
                // Store geometry
                state.geometry = renderGeometry;
                window.appState = state; // expose for dashboard and debugging
                
                // Create mesh and add to scene
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide
                });
                
                if (state.mesh) {
                    scene.remove(state.mesh);
                }
                
                state.mesh = new THREE.Mesh(renderGeometry, material);
                scene.add(state.mesh);
                
                // Log mesh details for debugging
                console.log(`Mesh created: vertices=${renderGeometry.attributes.position.count}, meshPosition=${state.mesh.position.toArray()}, meshVisible=${state.mesh.visible}, sceneChildren=${scene.children.length}`);

                // Add bounding box helper for visibility on huge models
                if (state.bboxHelper) {
                    scene.remove(state.bboxHelper);
                    state.bboxHelper = null;
                }
                if (renderGeometry.boundingBox) {
                    console.log(`Bounding box: min=${renderGeometry.boundingBox.min.toArray()}, max=${renderGeometry.boundingBox.max.toArray()}`);
                    const boxHelper = new THREE.Box3Helper(renderGeometry.boundingBox, 0x7c3aed);
                    state.bboxHelper = boxHelper;
                    scene.add(boxHelper);
                }
                
                // Force renderer update
                renderer.render(scene, camera);
                console.log(`Render forced, scene updated`);

                
                // Adjust camera
                const size = new THREE.Vector3();
                renderGeometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 2.5;
                camera.position.set(distance, distance * 0.8, distance);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
                
                console.log(`Camera positioned: pos=${camera.position.toArray()}, far=${camera.far}`);
                
                const perf = state.performanceMonitor?.endMeasure('STL-loading');
                const memUsage = state.memoryManager?.getMemoryUsage();
                const summaryVertices = renderGeometry.userData.previewSimplified ? `${renderGeometry.attributes.position.count.toLocaleString()} (preview)` : renderGeometry.attributes.position.count.toLocaleString();
                updateStatus('complete', `STL loaded: ${summaryVertices} vertices (${perf?.duration}) - Memory: ${memUsage}MB`);
                if (renderGeometry.userData.previewSimplified) {
                    setPrecompressSummary(`Preview simplified ${renderGeometry.userData.previewSimplified.originalVertices.toLocaleString()} → ${renderGeometry.userData.previewSimplified.retainedVertices.toLocaleString()} vertices (stride ${renderGeometry.userData.previewSimplified.stride}). Run manual precompression to reduce further.`);
                }
                showLoading(false);
                hideProgressBar();
                enableButton('btn-precompress', true);
                if (!renderGeometry.userData.previewSimplified) {
                    setPrecompressSummary(`Ready: ${renderGeometry.attributes.position.count.toLocaleString()} vertices. You can precompress before isolating.`);
                }
                enableButton('btn-isolate', true);
            } catch (error) {
                console.error('Failed to load STL:', error);
                updateStatus('complete', `Error loading STL: ${error.message}`);
                showLoading(false);
                hideProgressBar();
            }
        });

        document.getElementById('btn-precompress').addEventListener('click', runManualPrecompression);

        // Utility Functions
        function updateStatus(type, text) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            indicator.className = 'status-indicator';
            if (type === 'ready') indicator.classList.add('status-ready');
            else if (type === 'processing') indicator.classList.add('status-processing');
            else if (type === 'complete') indicator.classList.add('status-complete');
            
            statusText.textContent = text;
        }

        function showLoading(show) {
            document.getElementById('loading-overlay').classList.toggle('hidden', !show);
        }

        function enableButton(buttonId, enabled) {
            const button = document.getElementById(buttonId);
            button.disabled = !enabled;
            if (enabled) {
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                button.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // ALGORITHM 1: Isolate Inner Surface
        // IMPROVED: Robust normal vector analysis with connectivity filtering
        // NOW WITH TRANSPARENCY: Non-selected surfaces are made 75% transparent
        document.getElementById('btn-isolate').addEventListener('click', async () => {
            if (!state.geometry) return;
            
            updateStatus('processing', 'Isolating inner bowl surface with robust filtering...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const positions = state.geometry.attributes.position.array;
            const normals = state.geometry.attributes.normal.array;
            
            // Step 1: Calculate geometric centroid
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexCount = positions.length / 3;
            
            for (let i = 0; i < positions.length; i += 3) {
                centroid.x += positions[i];
                centroid.y += positions[i + 1];
                centroid.z += positions[i + 2];
            }
            centroid.divideScalar(vertexCount);
            
            console.log(`Centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)}, ${centroid.z.toFixed(2)})`);
            
            // Step 2: Calculate distances to centroid for all faces
            const faceCount = positions.length / 9;
            const faceData = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                const faceCenter = new THREE.Vector3()
                    .add(v1).add(v2).add(v3)
                    .divideScalar(3);
                
                const n = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
                const toCentroid = new THREE.Vector3().subVectors(centroid, faceCenter).normalize();
                const dot = n.dot(toCentroid);
                const distanceToCentroid = faceCenter.distanceTo(centroid);
                
                faceData.push({
                    index: i / 9,
                    vertices: [v1, v2, v3],
                    indices: [i / 3, i / 3 + 1, i / 3 + 2],
                    dot,
                    distance: distanceToCentroid,
                    center: faceCenter
                });
            }
            
            // Step 3: Filter inner surface using multiple criteria
            // Inner surface should be: concave (dot > threshold) AND within distance range
            const distances = faceData.map(f => f.distance);
            distances.sort((a, b) => a - b);
            const medianDist = distances[Math.floor(distances.length / 2)];
            const q1Dist = distances[Math.floor(distances.length * 0.25)];
            const q3Dist = distances[Math.floor(distances.length * 0.75)];
            
            // Inner surface of concave bowl should be close to centroid (not far)
            // For acetabulum, the centroid is inside the bowl, so inner surface is closer
            const maxDistance = q3Dist;
            
            let candidateFaces = faceData.filter(f => 
                f.dot > 0.5 &&  // Stricter: normal points strongly toward centroid (concave)
                f.distance <= maxDistance  // Inner surface is closer to centroid for concave geometry
            );
            
            console.log(`Initial candidates: ${candidateFaces.length} faces (strict normal + distance filter)`);
            
            // Step 4: Keep only the largest connected component (OPTIMIZED)
            // This eliminates small isolated regions (like the green spots at the bottom)
            console.log(`Building adjacency graph for ${candidateFaces.length} faces...`);
            
            // Helper: convert vertex position to unique key (round to avoid floating point issues)
            const vertexKey = (v) => {
                const precision = 1000; // 0.001mm precision
                return `${Math.round(v.x * precision)},${Math.round(v.y * precision)},${Math.round(v.z * precision)}`;
            };
            
            // Build vertex-to-faces map using position-based keys
            const vertexToFaces = new Map();
            candidateFaces.forEach(f => {
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (!vertexToFaces.has(key)) {
                        vertexToFaces.set(key, []);
                    }
                    vertexToFaces.get(key).push(f.index);
                });
            });
            
            // Build adjacency list: faces are adjacent if they share a vertex position
            const adjacency = new Map();
            candidateFaces.forEach(f => {
                adjacency.set(f.index, new Set());
            });
            
            candidateFaces.forEach(f => {
                // For each vertex in this face, find all other faces that share the same position
                const neighbors = new Set();
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (vertexToFaces.has(key)) {
                        vertexToFaces.get(key).forEach(neighborIdx => {
                            if (neighborIdx !== f.index) {
                                neighbors.add(neighborIdx);
                            }
                        });
                    }
                });
                
                // Add to adjacency list
                neighbors.forEach(n => adjacency.get(f.index).add(n));
            });
            
            // Find connected components using BFS
            const visited = new Set();
            const components = [];
            
            candidateFaces.forEach(f => {
                if (visited.has(f.index)) return;
                
                const component = [];
                const queue = [f.index];
                visited.add(f.index);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    
                    if (adjacency.has(current)) {
                        for (let neighbor of adjacency.get(current)) {
                            if (!visited.has(neighbor)) {
                                visited.add(neighbor);
                                queue.push(neighbor);
                            }
                        }
                    }
                }
                
                components.push(component);
            });
            
            // Select largest connected component
            components.sort((a, b) => b.length - a.length);
            const largestComponent = components.length > 0 ? components[0] : [];
            
            console.log(`Connected components: ${components.length}, largest has ${largestComponent.length} faces`);
            
            // Step 5: Build final inner surface from largest component
            const innerFaceSet = new Set(largestComponent);
            const innerFaces = largestComponent;
            state.innerSurfaceVertices = [];
            const vertexMap = new Map();
            
            candidateFaces.forEach(f => {
                if (!innerFaceSet.has(f.index)) return;
                
                f.vertices.forEach((v, i) => {
                    const idx = f.indices[i];
                    if (!vertexMap.has(idx)) {
                        const vData = { pos: v.clone(), index: idx };
                        vertexMap.set(idx, vData);
                        state.innerSurfaceVertices.push(vData);
                    }
                });
            });
            
            console.log(`Inner surface isolated: ${innerFaces.length} faces, ${state.innerSurfaceVertices.length} unique vertices`);
            console.log(`Algorithm: Robust normal analysis + connectivity filtering (largest component)`);
            
            // CRITICAL FIX v3.6: Store filtered inner surface triangles for consistent use
            // This ensures volumetric calculation and visualization use the exact same triangle set
            state.filteredInnerTriangles = [];
            for (const faceIdx of innerFaces) {
                const baseIdx = faceIdx * 9;
                const triangle = {
                    faceIndex: faceIdx,
                    p1: new THREE.Vector3(positions[baseIdx], positions[baseIdx + 1], positions[baseIdx + 2]),
                    p2: new THREE.Vector3(positions[baseIdx + 3], positions[baseIdx + 4], positions[baseIdx + 5]),
                    p3: new THREE.Vector3(positions[baseIdx + 6], positions[baseIdx + 7], positions[baseIdx + 8]),
                    vertexIndices: [faceIdx * 3, faceIdx * 3 + 1, faceIdx * 3 + 2]
                };
                state.filteredInnerTriangles.push(triangle);
            }
            console.log(`Stored ${state.filteredInnerTriangles.length} filtered inner triangles for volumetric calculation`);
            
            // Step 6: Apply transparency to non-selected surfaces (75% transparent = 0.25 opacity)
            // Build index buffer with inner faces first, then outer faces
            const innerIndices = [];
            const outerIndices = [];
            
            for (let faceIdx = 0; faceIdx < faceCount; faceIdx++) {
                const baseIdx = faceIdx * 3; // Each face has 3 vertices
                if (innerFaceSet.has(faceIdx)) {
                    // Inner surface vertices - add to inner list
                    innerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                } else {
                    // Outer surface vertices - add to outer list (will be 75% transparent)
                    outerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                }
            }
            
            console.log(`Inner indices: ${innerIndices.length}, Outer indices: ${outerIndices.length}`);
            
            // Combine indices: inner first, then outer
            const combinedIndices = [...innerIndices, ...outerIndices];
            
            // Apply new index buffer to geometry
            const geometry = state.geometry;
            geometry.setIndex(combinedIndices);
            
            // Clear existing groups
            geometry.clearGroups();
            
            // Add group for inner surface (opaque) - starts at 0
            if (innerIndices.length > 0) {
                geometry.addGroup(0, innerIndices.length, 0);
                console.log(`Inner group: start=0, count=${innerIndices.length}, materialIndex=0 (opaque)`);
            }
            
            // Add group for outer surface (75% transparent) - starts after inner
            if (outerIndices.length > 0) {
                geometry.addGroup(innerIndices.length, outerIndices.length, 1);
                console.log(`Outer group: start=${innerIndices.length}, count=${outerIndices.length}, materialIndex=1 (75% transparent)`);
            }
            
            // Create materials array: [0] opaque for inner, [1] 75% transparent for outer
            const materials = [
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: false
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // 75% transparent = 25% opaque
                    depthWrite: false
                })
            ];
            
            // Update mesh with multi-material
            state.mesh.material = materials;
            state.mesh.renderOrder = 1; // Ensure proper transparency rendering
            
            updateStatus('complete', `Inner surface isolated: ${innerFaces.length} faces (${((innerFaces.length/faceCount)*100).toFixed(1)}% of mesh), ${state.innerSurfaceVertices.length} vertices`);
            showLoading(false);
            enableButton('btn-detect-wear', true);
        });

        // ALGORITHM 2: Detect Worn/Unworn Zones
        // NEW v3.1: Lateral Spherical Displacement Detection
        // Detects asymmetric wear pattern where femoral head displaces laterally to one side
        // Key concept: Worn zone = vertices displaced in PRIMARY DISPLACEMENT DIRECTION
        // Unworn zone = vertices maintaining original spherical geometry
        document.getElementById('btn-detect-wear').addEventListener('click', async () => {
            if (state.innerSurfaceVertices.length === 0) {
                alert('Please isolate inner surface first');
                return;
            }
            
            updateStatus('processing', 'Detecting lateral spherical displacement pattern...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const allVertices = state.innerSurfaceVertices;
            console.log(`=== LATERAL SPHERICAL DISPLACEMENT DETECTION (v3.1) ===`);
            console.log(`Processing ${allVertices.length} inner surface vertices`);
            
            // Step 1: Build vertex adjacency structure
            console.log('Building mesh topology...');
            const positions = state.geometry.attributes.position.array;
            
            // Build vertex neighborhood (1-ring adjacency)
            const vertexNeighbors = new Map();
            const innerVertexIndices = new Set(allVertices.map(v => v.index));
            
            // Initialize neighbor sets
            allVertices.forEach(v => {
                vertexNeighbors.set(v.index, new Set());
            });
            
            // Build adjacency from triangle faces
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = i / 3;
                const idx2 = i / 3 + 1;
                const idx3 = i / 3 + 2;
                
                // Only process inner surface triangles
                if (!innerVertexIndices.has(idx1) || !innerVertexIndices.has(idx2) || !innerVertexIndices.has(idx3)) {
                    continue;
                }
                
                // Add bidirectional edges
                vertexNeighbors.get(idx1).add(idx2);
                vertexNeighbors.get(idx1).add(idx3);
                vertexNeighbors.get(idx2).add(idx1);
                vertexNeighbors.get(idx2).add(idx3);
                vertexNeighbors.get(idx3).add(idx1);
                vertexNeighbors.get(idx3).add(idx2);
            }
            
            // Store adjacency in state for later use
            state.adjacency = vertexNeighbors;
            console.log(`Built adjacency graph for ${allVertices.length} vertices`);
            
            // Step 2: Detect rim/edge vertices (exclude 15% closest to the acetabular border)
            console.log('Detecting rim vertices (15% furthest from centroid = circular band at rim)...');
            const rimVertices = new Set();
            
            // Calculate centroid of all vertices
            const rimCentroid = new THREE.Vector3(0, 0, 0);
            allVertices.forEach(v => rimCentroid.add(v.pos));
            rimCentroid.divideScalar(allVertices.length);
            
            console.log(`Centroid: (${rimCentroid.x.toFixed(2)}, ${rimCentroid.y.toFixed(2)}, ${rimCentroid.z.toFixed(2)})`);
            
            // Calculate distance from each vertex to centroid
            // Rim vertices are those FURTHEST from centroid (forming circular band at opening)
            const distances = allVertices.map(v => {
                return {
                    index: v.index,
                    distance: v.pos.distanceTo(rimCentroid)
                };
            });
            
            // Sort by distance - highest distance = rim vertices (at the edge/opening)
            distances.sort((a, b) => b.distance - a.distance);
            
            // Mark top 15% as rim vertices
            const rimCount = Math.floor(allVertices.length * 0.15);
            for (let i = 0; i < rimCount; i++) {
                rimVertices.add(distances[i].index);
            }
            
            const minRimDist = distances[rimCount - 1].distance;
            const maxRimDist = distances[0].distance;
            console.log(`Rim distance range: ${minRimDist.toFixed(2)} - ${maxRimDist.toFixed(2)} mm from centroid`);
            console.log(`Detected ${rimVertices.size} rim vertices (${(rimVertices.size/allVertices.length*100).toFixed(1)}% furthest from centroid = circular band at border)`);
            
            // Step 3: Fit reference sphere to ALL non-rim vertices
            // This sphere represents the average geometry across the entire surface
            console.log('Fitting reference sphere to entire inner surface...');
            const nonRimVertices = allVertices.filter(v => !rimVertices.has(v.index));
            
            // Initialize sphere center (centroid of non-rim vertices)
            let sphereCenter = new THREE.Vector3(0, 0, 0);
            for (let i = 0; i < nonRimVertices.length; i++) {
                sphereCenter.add(nonRimVertices[i].pos);
            }
            sphereCenter.divideScalar(nonRimVertices.length);
            
            // Initialize radius (average distance to center)
            let sphereRadius = 0;
            for (let i = 0; i < nonRimVertices.length; i++) {
                sphereRadius += nonRimVertices[i].pos.distanceTo(sphereCenter);
            }
            sphereRadius /= nonRimVertices.length;
            
            // Refine sphere fit with 10 iterations
            for (let iter = 0; iter < 10; iter++) {
                const newCenter = new THREE.Vector3(0, 0, 0);
                let newRadius = 0;
                
                for (let i = 0; i < nonRimVertices.length; i++) {
                    const v = nonRimVertices[i];
                    const dir = new THREE.Vector3().subVectors(v.pos, sphereCenter).normalize();
                    const pointOnSphere = sphereCenter.clone().add(dir.multiplyScalar(sphereRadius));
                    newCenter.add(pointOnSphere);
                }
                newCenter.divideScalar(nonRimVertices.length);
                
                for (let i = 0; i < nonRimVertices.length; i++) {
                    newRadius += nonRimVertices[i].pos.distanceTo(newCenter);
                }
                newRadius /= nonRimVertices.length;
                
                sphereCenter = newCenter;
                sphereRadius = newRadius;
            }
            
            console.log(`Reference sphere: center=(${sphereCenter.x.toFixed(2)}, ${sphereCenter.y.toFixed(2)}, ${sphereCenter.z.toFixed(2)}), radius=${sphereRadius.toFixed(2)}`);
            
            // Get selected detection method
            const detectionMethod = document.getElementById('detection-method').value;
            state.detectionMethod = detectionMethod;
            console.log(`Detection method: ${detectionMethod}`);
            
            // Calculate geometric centroid (used by both methods)
            const centroid = new THREE.Vector3(0, 0, 0);
            for (let i = 0; i < nonRimVertices.length; i++) {
                centroid.add(nonRimVertices[i].pos);
            }
            centroid.divideScalar(nonRimVertices.length);
            console.log(`Geometric centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)}, ${centroid.z.toFixed(2)})`);
            
            state.wornVertices = [];
            state.unwornVertices = [];
            
            if (detectionMethod === 'dual-sphere') {
                // ========================================
                // DUAL-SPHERE METHOD v3.0: Ray-Based Least-Squares Clustering
                // ========================================
                console.log('=== DUAL-SPHERE METHOD: Ray-Based Clustering (v3.0) ===');
                console.log('Using least-squares ray intersection to find convergence centers...');
                console.log(`Reference sphere center: (${sphereCenter.x.toFixed(3)}, ${sphereCenter.y.toFixed(3)}, ${sphereCenter.z.toFixed(3)})`);
                console.log(`Reference sphere radius: ${sphereRadius.toFixed(3)} mm`);
                
                // Get vertex normals from geometry
                const normals = state.geometry.attributes.normal.array;
                
                // Step 1: Create rays for all vertices
                // Each ray is defined by: origin (vertex position) and direction (inward normal)
                const rays = [];
                
                for (let i = 0; i < nonRimVertices.length; i++) {
                    const v = nonRimVertices[i];
                    const idx = v.index;
                    
                    // Get stored normal
                    const nx = normals[idx * 3];
                    const ny = normals[idx * 3 + 1];
                    const nz = normals[idx * 3 + 2];
                    const normal = new THREE.Vector3(nx, ny, nz).normalize();
                    
                    // Calculate vector from vertex toward sphere center
                    const toCenter = sphereCenter.clone().sub(v.pos).normalize();
                    
                    // Ensure normal points inward (toward interior of cup)
                    let direction;
                    if (normal.dot(toCenter) < 0) {
                        direction = normal.clone().negate();
                    } else {
                        direction = normal.clone();
                    }
                    
                    rays.push({
                        vertex: v,
                        origin: v.pos.clone(),
                        direction: direction,
                        cluster: -1
                    });
                }
                
                console.log(`Created ${rays.length} normal rays from vertices`);
                
                // Function to compute least-squares center for a set of rays
                // Minimizes sum of squared perpendicular distances from point to all rays
                // Solution: P = (Σ(I - D⊗D))^(-1) * Σ((I - D⊗D) * O)
                function computeRayConvergenceCenter(raySubset) {
                    if (raySubset.length === 0) return new THREE.Vector3(0, 0, 0);
                    
                    // Build matrix A = Σ(I - D⊗D) and vector b = Σ((I - D⊗D) * O)
                    // Using simplified 3x3 matrix representation
                    let A = [[0,0,0], [0,0,0], [0,0,0]];
                    let b = [0, 0, 0];
                    
                    for (const ray of raySubset) {
                        const d = ray.direction;
                        const o = ray.origin;
                        
                        // (I - D⊗D) where D⊗D is outer product
                        const Idd = [
                            [1 - d.x*d.x, -d.x*d.y, -d.x*d.z],
                            [-d.y*d.x, 1 - d.y*d.y, -d.y*d.z],
                            [-d.z*d.x, -d.z*d.y, 1 - d.z*d.z]
                        ];
                        
                        // Accumulate A
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                A[i][j] += Idd[i][j];
                            }
                        }
                        
                        // Accumulate b = (I - D⊗D) * O
                        const ov = [o.x, o.y, o.z];
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                b[i] += Idd[i][j] * ov[j];
                            }
                        }
                    }
                    
                    // Solve A * P = b using Gaussian elimination with partial pivoting
                    // Create augmented matrix
                    const aug = [
                        [A[0][0], A[0][1], A[0][2], b[0]],
                        [A[1][0], A[1][1], A[1][2], b[1]],
                        [A[2][0], A[2][1], A[2][2], b[2]]
                    ];
                    
                    // Forward elimination
                    for (let col = 0; col < 3; col++) {
                        // Find pivot
                        let maxRow = col;
                        for (let row = col + 1; row < 3; row++) {
                            if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
                                maxRow = row;
                            }
                        }
                        // Swap rows
                        [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];
                        
                        // Check for singularity
                        if (Math.abs(aug[col][col]) < 1e-10) continue;
                        
                        // Eliminate
                        for (let row = col + 1; row < 3; row++) {
                            const factor = aug[row][col] / aug[col][col];
                            for (let j = col; j < 4; j++) {
                                aug[row][j] -= factor * aug[col][j];
                            }
                        }
                    }
                    
                    // Back substitution
                    const solution = [0, 0, 0];
                    for (let i = 2; i >= 0; i--) {
                        if (Math.abs(aug[i][i]) < 1e-10) {
                            solution[i] = 0;
                            continue;
                        }
                        solution[i] = aug[i][3];
                        for (let j = i + 1; j < 3; j++) {
                            solution[i] -= aug[i][j] * solution[j];
                        }
                        solution[i] /= aug[i][i];
                    }
                    
                    return new THREE.Vector3(solution[0], solution[1], solution[2]);
                }
                
                // Function to compute perpendicular distance from point to ray
                function pointToRayDistance(point, ray) {
                    const v = point.clone().sub(ray.origin);
                    const projection = ray.direction.clone().multiplyScalar(v.dot(ray.direction));
                    const perpendicular = v.clone().sub(projection);
                    return perpendicular.length();
                }
                
                // Step 2: Initialize two cluster centers
                // Center 1: Reference sphere center (likely unworn)
                // Center 2: Estimate worn center by looking at deepest wear (farthest inside the sphere)
                let clusterCenters = [
                    sphereCenter.clone(),
                    sphereCenter.clone()  // Will be refined
                ];
                
                // Find vertex deepest inside sphere (most worn)
                let maxPenetration = 0;
                let deepestVertex = rays[0].origin;
                for (const ray of rays) {
                    const distToCenter = ray.origin.distanceTo(sphereCenter);
                    const penetration = sphereRadius - distToCenter; // Positive if inside sphere
                    if (penetration > maxPenetration) {
                        maxPenetration = penetration;
                        deepestVertex = ray.origin;
                    }
                }
                // Initialize worn center estimate along the direction of deepest wear
                const wornDirection = deepestVertex.clone().sub(sphereCenter).normalize();
                clusterCenters[1] = sphereCenter.clone().add(wornDirection.multiplyScalar(maxPenetration * 2));
                
                console.log(`  Initial cluster centers:`);
                console.log(`    Unworn (0): (${clusterCenters[0].x.toFixed(2)}, ${clusterCenters[0].y.toFixed(2)}, ${clusterCenters[0].z.toFixed(2)})`);
                console.log(`    Worn (1):   (${clusterCenters[1].x.toFixed(2)}, ${clusterCenters[1].y.toFixed(2)}, ${clusterCenters[1].z.toFixed(2)})`);
                
                // Step 3: Iterative ray clustering
                const maxIterations = 30;
                let converged = false;
                let iteration = 0;
                
                while (!converged && iteration < maxIterations) {
                    iteration++;
                    let changed = false;
                    
                    // Assignment: assign each ray to cluster with nearest center (by perpendicular distance)
                    for (const ray of rays) {
                        const dist0 = pointToRayDistance(clusterCenters[0], ray);
                        const dist1 = pointToRayDistance(clusterCenters[1], ray);
                        const newCluster = dist0 <= dist1 ? 0 : 1;
                        
                        if (ray.cluster !== newCluster) {
                            ray.cluster = newCluster;
                            changed = true;
                        }
                    }
                    
                    // Update: recompute cluster centers using least-squares on assigned rays
                    const cluster0Rays = rays.filter(r => r.cluster === 0);
                    const cluster1Rays = rays.filter(r => r.cluster === 1);
                    
                    if (cluster0Rays.length > 10) {
                        clusterCenters[0] = computeRayConvergenceCenter(cluster0Rays);
                    }
                    if (cluster1Rays.length > 10) {
                        clusterCenters[1] = computeRayConvergenceCenter(cluster1Rays);
                    }
                    
                    if (!changed) {
                        converged = true;
                    }
                }
                
                console.log(`  Ray clustering converged after ${iteration} iterations`);
                
                // Count vertices in each cluster
                const cluster0Rays_final = rays.filter(r => r.cluster === 0);
                const cluster1Rays_final = rays.filter(r => r.cluster === 1);
                const cluster0Count = cluster0Rays_final.length;
                const cluster1Count = cluster1Rays_final.length;
                
                console.log(`  Cluster 0: ${cluster0Count} vertices, center at (${clusterCenters[0].x.toFixed(3)}, ${clusterCenters[0].y.toFixed(3)}, ${clusterCenters[0].z.toFixed(3)})`);
                console.log(`  Cluster 1: ${cluster1Count} vertices, center at (${clusterCenters[1].x.toFixed(3)}, ${clusterCenters[1].y.toFixed(3)}, ${clusterCenters[1].z.toFixed(3)})`);
                
                // Validate: centers should be inside/near the cup geometry
                const center0DistFromRef = clusterCenters[0].distanceTo(sphereCenter);
                const center1DistFromRef = clusterCenters[1].distanceTo(sphereCenter);
                console.log(`  Cluster 0 center: ${center0DistFromRef.toFixed(2)}mm from reference sphere center`);
                console.log(`  Cluster 1 center: ${center1DistFromRef.toFixed(2)}mm from reference sphere center`);
                
                // Step 4: Determine which cluster is UNWORN vs WORN
                // IMPROVED LOGIC (v3.5): Use commercial radius to classify clusters when available
                // 
                // The cluster whose vertices best fit a sphere with the commercial radius is UNWORN
                // because the unworn surface should match the original prosthesis geometry (commercial size)
                
                const commercialRadiusSetting = document.getElementById('commercial-radius').value;
                const commercialRadii = [14, 16, 18, 20];
                let targetRadius = null;
                
                // Determine target radius for classification
                if (commercialRadiusSetting !== 'auto') {
                    targetRadius = parseFloat(commercialRadiusSetting);
                    console.log(`Using user-specified commercial radius for classification: ${targetRadius}mm`);
                } else {
                    // Auto-detect: find nearest commercial radius to the initial sphere fit
                    let minDiff = Infinity;
                    for (const cr of commercialRadii) {
                        const diff = Math.abs(sphereRadius - cr);
                        if (diff < minDiff) {
                            minDiff = diff;
                            targetRadius = cr;
                        }
                    }
                    console.log(`Auto-detected commercial radius for classification: ${targetRadius}mm (nearest to ${sphereRadius.toFixed(2)}mm)`);
                }
                
                // Evaluate each cluster: compute residual when fitting a sphere with target radius
                // The cluster with lower residual (better fit to commercial radius) is UNWORN
                function computeClusterRadiusFit(clusterRays, clusterCenter, targetRadius) {
                    if (clusterRays.length === 0) return Infinity;
                    
                    let residualSum = 0;
                    for (const ray of clusterRays) {
                        const dist = ray.origin.distanceTo(clusterCenter);
                        const residual = Math.abs(dist - targetRadius);
                        residualSum += residual * residual;
                    }
                    return Math.sqrt(residualSum / clusterRays.length);
                }
                
                const cluster0Residual = computeClusterRadiusFit(cluster0Rays_final, clusterCenters[0], targetRadius);
                const cluster1Residual = computeClusterRadiusFit(cluster1Rays_final, clusterCenters[1], targetRadius);
                
                console.log(`Cluster 0: RMS residual to commercial radius ${targetRadius}mm = ${cluster0Residual.toFixed(4)}mm`);
                console.log(`Cluster 1: RMS residual to commercial radius ${targetRadius}mm = ${cluster1Residual.toFixed(4)}mm`);
                
                // The cluster with LOWER residual better matches the commercial radius = UNWORN
                // If residuals are very similar (< 0.5mm difference), fall back to distance-based logic
                let unwornCluster, wornCluster;
                const residualDifference = Math.abs(cluster0Residual - cluster1Residual);
                
                if (residualDifference > 0.5) {
                    // Significant difference: use residual-based classification
                    unwornCluster = cluster0Residual <= cluster1Residual ? 0 : 1;
                    wornCluster = 1 - unwornCluster;
                    console.log(`\nCluster classification (v3.5 - commercial radius match):`);
                    console.log(`  Using commercial radius criterion (residual difference: ${residualDifference.toFixed(4)}mm)`);
                } else {
                    // Residuals are similar: fall back to distance-based logic
                    const dist0ToSphere = clusterCenters[0].distanceTo(sphereCenter);
                    const dist1ToSphere = clusterCenters[1].distanceTo(sphereCenter);
                    unwornCluster = dist0ToSphere >= dist1ToSphere ? 0 : 1;
                    wornCluster = 1 - unwornCluster;
                    console.log(`\nCluster classification (v3.5 - fallback to distance):`);
                    console.log(`  Residuals too similar (${residualDifference.toFixed(4)}mm), using distance-based criterion`);
                }
                
                console.log(`  Cluster ${unwornCluster} → UNWORN (RMS residual: ${(unwornCluster === 0 ? cluster0Residual : cluster1Residual).toFixed(4)}mm)`);
                console.log(`  Cluster ${wornCluster} → WORN (RMS residual: ${(wornCluster === 0 ? cluster0Residual : cluster1Residual).toFixed(4)}mm)`);
                
                // Step 5: Classify vertices based on their cluster
                state.wornVertices = [];
                state.unwornVertices = [];
                
                for (const ray of rays) {
                    if (ray.cluster === unwornCluster) {
                        state.unwornVertices.push(ray.vertex);
                    } else {
                        state.wornVertices.push(ray.vertex);
                    }
                }
                
                // Get the final centers
                const unwornCenter = clusterCenters[unwornCluster];
                const wornCenter = clusterCenters[wornCluster];
                
                // Store preliminary sphere centers for later fitting
                state.preliminaryWornCenter = wornCenter.clone();
                state.preliminaryUnwornCenter = unwornCenter.clone();
                
                // Calculate distance between centers
                state.centerDistance = wornCenter.distanceTo(unwornCenter);
                
                console.log(`\nFinal ray convergence centers:`);
                console.log(`  Unworn center: (${unwornCenter.x.toFixed(3)}, ${unwornCenter.y.toFixed(3)}, ${unwornCenter.z.toFixed(3)})`);
                console.log(`  Distance from reference sphere: ${unwornCenter.distanceTo(sphereCenter).toFixed(4)} mm`);
                console.log(`  Worn center: (${wornCenter.x.toFixed(3)}, ${wornCenter.y.toFixed(3)}, ${wornCenter.z.toFixed(3)})`);
                console.log(`  Distance from reference sphere: ${wornCenter.distanceTo(sphereCenter).toFixed(4)} mm`);
                console.log(`  Linear wear (center displacement): ${state.centerDistance.toFixed(4)} mm`);
                
                console.log(`\nClassification results:`);
                console.log(`  Unworn vertices: ${state.unwornVertices.length} (${(state.unwornVertices.length / nonRimVertices.length * 100).toFixed(1)}%)`);
                console.log(`  Worn vertices: ${state.wornVertices.length} (${(state.wornVertices.length / nonRimVertices.length * 100).toFixed(1)}%)`);
                
                // Visualize the centers derived from k-means clustering
                // Remove existing center markers if any
                if (state.unwornCenterMarker) {
                    scene.remove(state.unwornCenterMarker);
                    state.unwornCenterMarker = null;
                }
                if (state.wornCenterMarker) {
                    scene.remove(state.wornCenterMarker);
                    state.wornCenterMarker = null;
                }
                
                // Create unworn center marker (bright green sphere)
                const unwornCenterGeom = new THREE.SphereGeometry(1.5, 32, 32);
                const unwornCenterMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                state.unwornCenterMarker = new THREE.Mesh(unwornCenterGeom, unwornCenterMat);
                state.unwornCenterMarker.position.copy(unwornCenter);
                scene.add(state.unwornCenterMarker);
                
                // Create worn center marker (bright red sphere)
                const wornCenterGeom = new THREE.SphereGeometry(1.5, 32, 32);
                const wornCenterMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff3366,
                    transparent: true,
                    opacity: 0.9
                });
                state.wornCenterMarker = new THREE.Mesh(wornCenterGeom, wornCenterMat);
                state.wornCenterMarker.position.copy(wornCenter);
                scene.add(state.wornCenterMarker);
                
                // Show legend items for center markers
                document.getElementById('legend-unworn-center').style.display = 'flex';
                document.getElementById('legend-worn-center').style.display = 'flex';
                
                console.log(`Added center markers: unworn (green) at (${unwornCenter.x.toFixed(2)}, ${unwornCenter.y.toFixed(2)}, ${unwornCenter.z.toFixed(2)}), worn (red) at (${wornCenter.x.toFixed(2)}, ${wornCenter.y.toFixed(2)}, ${wornCenter.z.toFixed(2)})`);
                
            } else {
                // ========================================
                // HEMISPHERE METHOD: Axis Dispersion (Original)
                // ========================================
                console.log('=== HEMISPHERE METHOD: Axis Dispersion ===');
                console.log('Analyzing hemispheric asymmetry to detect lateral displacement...');
                
                // Step 5: TEST MULTIPLE HEMISPHERE DIVISIONS
                // Try different division axes to find the one with maximum asymmetry
                console.log('Testing hemisphere divisions to find maximum asymmetry...');
                
                const testDirections = [
                    new THREE.Vector3(1, 0, 0),   // X axis
                    new THREE.Vector3(0, 1, 0),   // Y axis
                    new THREE.Vector3(0, 0, 1),   // Z axis
                    new THREE.Vector3(1, 1, 0).normalize(),   // XY diagonal
                    new THREE.Vector3(1, 0, 1).normalize(),   // XZ diagonal
                    new THREE.Vector3(0, 1, 1).normalize(),   // YZ diagonal
                    new THREE.Vector3(1, 1, 1).normalize(),   // XYZ diagonal
                    new THREE.Vector3(-1, 1, 0).normalize(),  // -XY diagonal
                ];
                
                let bestDirection = null;
                let maxAsymmetry = 0;
                let bestPositiveAvg = 0;
                let bestNegativeAvg = 0;
                
                for (let d = 0; d < testDirections.length; d++) {
                    const dir = testDirections[d];
                    
                    // Divide vertices into two hemispheres based on dot product with direction
                    const positiveHemisphere = []; // Vertices in direction of axis
                    const negativeHemisphere = []; // Vertices opposite to axis
                    
                    for (let i = 0; i < nonRimVertices.length; i++) {
                        const v = nonRimVertices[i];
                        const vecFromCentroid = new THREE.Vector3().subVectors(v.pos, centroid);
                        const dotProduct = vecFromCentroid.dot(dir);
                        
                        if (dotProduct > 0) {
                            positiveHemisphere.push(v);
                        } else {
                            negativeHemisphere.push(v);
                        }
                    }
                    
                    // Calculate average radial distance for each hemisphere
                    let positiveAvgDist = 0;
                    for (let i = 0; i < positiveHemisphere.length; i++) {
                        positiveAvgDist += positiveHemisphere[i].pos.distanceTo(centroid);
                    }
                    positiveAvgDist /= positiveHemisphere.length;
                    
                    let negativeAvgDist = 0;
                    for (let i = 0; i < negativeHemisphere.length; i++) {
                        negativeAvgDist += negativeHemisphere[i].pos.distanceTo(centroid);
                    }
                    negativeAvgDist /= negativeHemisphere.length;
                    
                    // Asymmetry = difference in average distances
                    // Worn hemisphere should be FARTHER from centroid (larger distance)
                    const asymmetry = Math.abs(positiveAvgDist - negativeAvgDist);
                    
                    if (asymmetry > maxAsymmetry) {
                        maxAsymmetry = asymmetry;
                        bestDirection = dir.clone();
                        bestPositiveAvg = positiveAvgDist;
                        bestNegativeAvg = negativeAvgDist;
                    }
                }
                
                console.log(`Best division axis: (${bestDirection.x.toFixed(3)}, ${bestDirection.y.toFixed(3)}, ${bestDirection.z.toFixed(3)})`);
                console.log(`Asymmetry: ${maxAsymmetry.toFixed(3)} mm (positive avg: ${bestPositiveAvg.toFixed(2)}, negative avg: ${bestNegativeAvg.toFixed(2)})`);
                
                // Step 6: CLASSIFY BASED ON HEMISPHERIC ASYMMETRY
                // Rule: Hemisphere FARTHER from centroid = WORN
                //       Hemisphere CLOSER to centroid = UNWORN
                console.log('Classifying worn/unworn based on hemispheric distance...');
                
                // Determine which hemisphere is worn (the one with LARGER average distance - farther from centroid)
                const wornIsPositive = (bestPositiveAvg > bestNegativeAvg);
                
                console.log(`Worn hemisphere: ${wornIsPositive ? 'POSITIVE' : 'NEGATIVE'} side (FARTHER from centroid)`);
                
                // Classify all non-rim vertices
                for (let i = 0; i < nonRimVertices.length; i++) {
                    const v = nonRimVertices[i];
                    const vecFromCentroid = new THREE.Vector3().subVectors(v.pos, centroid);
                    const dotProduct = vecFromCentroid.dot(bestDirection);
                    
                    const isPositiveSide = (dotProduct > 0);
                    
                    if (isPositiveSide === wornIsPositive) {
                        state.wornVertices.push(v);
                    } else {
                        state.unwornVertices.push(v);
                    }
                }
                
                // Clear dual-sphere specific state
                state.wornSphere = null;
                state.centerDistance = null;
                state.preliminaryWornCenter = null;
                state.preliminaryUnwornCenter = null;
                
                // Remove center markers if they exist (from previous dual-sphere run)
                if (state.unwornCenterMarker) {
                    scene.remove(state.unwornCenterMarker);
                    state.unwornCenterMarker = null;
                }
                if (state.wornCenterMarker) {
                    scene.remove(state.wornCenterMarker);
                    state.wornCenterMarker = null;
                }
                
                // Hide legend items for center markers
                document.getElementById('legend-unworn-center').style.display = 'none';
                document.getElementById('legend-worn-center').style.display = 'none';
            }
            
            // Store rim vertices separately (will be rendered transparent)
            state.rimVertices = [];
            for (let i = 0; i < allVertices.length; i++) {
                if (rimVertices.has(allVertices[i].index)) {
                    state.rimVertices.push(allVertices[i]);
                }
            }
            
            const wornPercent = (state.wornVertices.length / allVertices.length * 100).toFixed(1);
            const unwornPercent = (state.unwornVertices.length / allVertices.length * 100).toFixed(1);
            
            console.log(`Classification complete:`);
            console.log(`  - Worn zone: ${state.wornVertices.length} vertices (${wornPercent}%)`);
            console.log(`  - Unworn zone: ${state.unwornVertices.length} vertices (${unwornPercent}%)`);
            
            // Step 7: Detect RIM BOUNDARY POINTS (for transition plane)
            // Rim boundary = BOTH sides of the rim/non-rim interface
            // Includes: rim vertices with non-rim neighbors AND non-rim vertices with rim neighbors
            console.log('Detecting rim boundary points (exact edge between rim and non-rim on BOTH sides)...');
            
            const rimBoundaryPoints = [];
            const nonRimIndicesSet = new Set(nonRimVertices.map(v => v.index));
            
            // Side 1: Non-rim vertices that have rim neighbors (inner side of boundary)
            for (let i = 0; i < nonRimVertices.length; i++) {
                const v = nonRimVertices[i];
                const neighbors = vertexNeighbors.get(v.index);
                if (!neighbors) continue;
                
                let hasRimNeighbor = false;
                for (const nIdx of neighbors) {
                    if (rimVertices.has(nIdx)) {
                        hasRimNeighbor = true;
                        break;
                    }
                }
                
                if (hasRimNeighbor) {
                    rimBoundaryPoints.push(v);
                }
            }
            
            // Side 2: Rim vertices that have non-rim neighbors (outer side of boundary)
            for (let i = 0; i < state.rimVertices.length; i++) {
                const v = state.rimVertices[i];
                const neighbors = vertexNeighbors.get(v.index);
                if (!neighbors) continue;
                
                let hasNonRimNeighbor = false;
                for (const nIdx of neighbors) {
                    if (nonRimIndicesSet.has(nIdx)) {
                        hasNonRimNeighbor = true;
                        break;
                    }
                }
                
                if (hasNonRimNeighbor) {
                    rimBoundaryPoints.push(v);
                }
            }
            
            // Store rim boundary points for transition plane calculation
            state.rimBoundaryPoints = rimBoundaryPoints;
            
            console.log(`Detected ${rimBoundaryPoints.length} rim boundary points (BOTH sides of rim/non-rim interface - exact border)`);
            
            // Step 8: Also detect inflection points at hemispheric boundary (for reference)
            console.log('Detecting inflection points at worn/unworn hemispheric boundary...');
            
            const wornIndices = new Set(state.wornVertices.map(v => v.index));
            const inflectionPoints = [];
            
            for (let i = 0; i < state.wornVertices.length; i++) {
                const v = state.wornVertices[i];
                const neighbors = vertexNeighbors.get(v.index);
                if (!neighbors) continue;
                
                let hasUnwornNeighbor = false;
                for (const nIdx of neighbors) {
                    if (!wornIndices.has(nIdx) && !rimVertices.has(nIdx)) {
                        hasUnwornNeighbor = true;
                        break;
                    }
                }
                
                if (hasUnwornNeighbor) {
                    inflectionPoints.push(v);
                }
            }
            
            for (let i = 0; i < state.unwornVertices.length; i++) {
                const v = state.unwornVertices[i];
                const neighbors = vertexNeighbors.get(v.index);
                if (!neighbors) continue;
                
                let hasWornNeighbor = false;
                for (const nIdx of neighbors) {
                    if (wornIndices.has(nIdx)) {
                        hasWornNeighbor = true;
                        break;
                    }
                }
                
                if (hasWornNeighbor) {
                    inflectionPoints.push(v);
                }
            }
            
            // Store inflection points (for visualization reference only, not used for plane)
            state.inflectionPoints = inflectionPoints;
            
            console.log(`Detected ${inflectionPoints.length} inflection points at worn/unworn hemispheric boundary (for reference)`);
            
            // Step 9: Apply colors and transparency to geometry
            const colors = new Float32Array(state.geometry.attributes.position.count * 3);
            const alphas = new Float32Array(state.geometry.attributes.position.count);
            
            // Default color (blue) and alpha (opaque)
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259;
                colors[i + 1] = 0.6;
                colors[i + 2] = 0.882;
            }
            for (let i = 0; i < alphas.length; i++) {
                alphas[i] = 1.0;  // Opaque by default
            }
            
            // Worn vertices (red, opaque)
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96;
                colors[idx + 1] = 0.396;
                colors[idx + 2] = 0.396;
                alphas[v.index] = 1.0;
            });
            
            // Unworn vertices (green, opaque)
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282;
                colors[idx + 1] = 0.733;
                colors[idx + 2] = 0.471;
                alphas[v.index] = 1.0;
            });
            
            // Rim vertices (gray, transparent like outer surface)
            state.rimVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.259;
                colors[idx + 1] = 0.6;
                colors[idx + 2] = 0.882;
                alphas[v.index] = 0.25;  // Transparent like outer surface
            });
            
            state.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            state.geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            
            // Keep multi-material: inner surface uses vertex colors + alpha, outer surface 75% transparent
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // Use vertex colors for worn/unworn/rim visualization
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,  // Enable transparency for rim vertices
                    opacity: 1.0,  // Base opacity (vertex alpha will modulate this)
                    alphaTest: 0.01,  // Prevent z-fighting
                    depthWrite: true
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent
                    depthWrite: false
                })
            ];
            
            state.mesh.material = materials;
            state.mesh.renderOrder = 1;
            
            console.log(`=== CLASSIFICATION RESULTS ===`);
            console.log(`Worn: ${state.wornVertices.length} (${wornPercent}%), Unworn: ${state.unwornVertices.length} (${unwornPercent}%)`);
            console.log(`Rim excluded: ${rimVertices.size} vertices (rendered transparent)`);
            console.log(`Rim boundary points: ${rimBoundaryPoints.length} edge vertices (for transition plane)`);
            console.log(`Inflection points: ${inflectionPoints.length} worn/unworn boundary vertices (for reference)`);
            console.log(`Algorithm: Hemispheric asymmetry analysis (v3.3)`);
            
            updateStatus('complete', `Wear zones detected: ${state.wornVertices.length} worn (${wornPercent}%), ${state.unwornVertices.length} unworn (${unwornPercent}%), rim excluded: ${rimVertices.size} (transparent)`);
            showLoading(false);
            enableButton('btn-fit-sphere', true);
        });

        // ALGORITHM 3: Fit Unworn Sphere and Detect Transition Plane
        // IMPROVED: Fits sphere ONLY to unworn zone (reference geometry)
        // Generates transition plane containing boundary points between worn/unworn
        document.getElementById('btn-fit-sphere').addEventListener('click', async () => {
            if (state.unwornVertices.length === 0 || state.wornVertices.length === 0) {
                alert('Please detect wear zones first');
                return;
            }
            
            // Reset commercial radius warning at start of each fitting run
            document.getElementById('radius-warning').classList.add('hidden');
            document.getElementById('radius-warning-text').textContent = '';
            
            updateStatus('processing', 'Fitting unworn sphere and detecting transition boundary...');
            showLoading(true);
            document.getElementById('sphere-loading-overlay').classList.remove('hidden');
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // IMPROVED Helper function: Gauss-Newton with Levenberg-Marquardt fallback
            function fitSphereRobust(vertices) {
                // Step 1: Initialize center (geometric centroid)
                let center = new THREE.Vector3(0, 0, 0);
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Step 2: Initialize radius (average distance to center)
                let radius = 0;
                vertices.forEach(p => radius += p.distanceTo(center));
                radius /= vertices.length;
                
                console.log(`Initial sphere: center=(${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius=${radius.toFixed(2)}`);
                
                // Step 3: Gauss-Newton iterations with adaptive damping
                const maxIterations = 20;
                const tolerance = 1e-6;
                let lambda = 0.001; // LM damping factor
                let prevResidual = Infinity;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Compute residuals: r_i = ||p_i - c|| - R
                    let residualSum = 0;
                    const n = vertices.length;
                    
                    // Jacobian matrix: J is n x 4 (partial derivatives w.r.t. cx, cy, cz, R)
                    // For each point p_i: residual = sqrt((px-cx)^2 + (py-cy)^2 + (pz-cz)^2) - R
                    // ∂r/∂cx = -(px-cx)/d, ∂r/∂cy = -(py-cy)/d, ∂r/∂cz = -(pz-cz)/d, ∂r/∂R = -1
                    
                    const J = []; // Jacobian matrix (n x 4)
                    const residuals = []; // Residual vector (n x 1)
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        const residual = dist - radius;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        // Jacobian row: [∂r/∂cx, ∂r/∂cy, ∂r/∂cz, ∂r/∂R]
                        if (dist > 1e-10) {
                            J.push([-dx/dist, -dy/dist, -dz/dist, -1]);
                        } else {
                            J.push([0, 0, 0, -1]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    console.log(`Iteration ${iter}: RMSE = ${currentResidual.toFixed(6)}, lambda = ${lambda.toFixed(6)}`);
                    
                    // Check convergence
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        console.log(`Converged after ${iter} iterations`);
                        break;
                    }
                    
                    // Compute J^T * J (4x4 matrix)
                    const JTJ = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add Levenberg-Marquardt damping: JTJ + lambda * I
                    for (let i = 0; i < 4; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r (4x1 vector)
                    const JTr = [0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    // Solve (JTJ) * delta = -JTr using Gauss elimination
                    const delta = solveLinearSystem4x4(JTJ, JTr.map(x => -x));
                    
                    if (!delta) {
                        console.log('Singular matrix, increasing lambda');
                        lambda *= 10;
                        continue;
                    }
                    
                    // Update parameters
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadius = radius + delta[3];
                    
                    // Check if update improves residual
                    let newResidualSum = 0;
                    vertices.forEach(p => {
                        const r = p.distanceTo(newCenter) - newRadius;
                        newResidualSum += r * r;
                    });
                    const newResidual = Math.sqrt(newResidualSum / n);
                    
                    if (newResidual < currentResidual) {
                        // Accept update, decrease damping
                        center = newCenter;
                        radius = newRadius;
                        prevResidual = currentResidual;
                        lambda = Math.max(lambda / 10, 1e-10);
                    } else {
                        // Reject update, increase damping (Levenberg-Marquardt)
                        lambda *= 10;
                        if (lambda > 1e6) {
                            console.log('Lambda too large, stopping');
                            break;
                        }
                    }
                }
                
                console.log(`Final sphere: center=(${center.x.toFixed(4)}, ${center.y.toFixed(4)}, ${center.z.toFixed(4)}), radius=${radius.toFixed(4)}`);
                
                return { center, radius };
            }
            
            // Helper: Solve 4x4 linear system using Gauss elimination
            function solveLinearSystem4x4(A, b) {
                // Create augmented matrix
                const n = 4;
                const aug = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    // Check for singular matrix
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    // Eliminate column
                    for (let k = i + 1; k < n; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j <= n; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                // Back substitution
                const x = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = aug[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            }
            
            // Fit ONLY unworn surface (reference geometry for ideal unworn surface)
            // Use selected shape and method: Sphere/Ellipsoid and Gauss-Newton/RANSAC
            const fittingShape = document.getElementById('fitting-shape').value;
            const fittingMethod = document.getElementById('fitting-method').value;
            const isEllipsoid = fittingShape === 'ellipsoid';
            
            // FIXED: Guard against missing wear detection step
            if (!state.wornVertices || !state.unwornVertices || !state.adjacency) {
                alert('Please complete Detect Wear Zones step first. The surface fitting requires worn/unworn classification to be completed.');
                showLoading(false);
                document.getElementById('sphere-loading-overlay').classList.add('hidden');
                return;
            }
            
            console.log(`=== Fitting UNWORN ${fittingShape.toUpperCase()} using ${fittingMethod.toUpperCase()} ===`);
            
            // CRITICAL FIX v3.6: Filter unworn vertices to exclude rim and transition vertices
            // This ensures the sphere fitting uses only pure unworn interior vertices
            const wornIndexSet = new Set();
            for (let i = 0; i < state.wornVertices.length; i++) {
                wornIndexSet.add(state.wornVertices[i].index);
            }
            
            // Build set of unworn vertex indices for quick lookup
            const unwornIndexSet = new Set();
            for (let i = 0; i < state.unwornVertices.length; i++) {
                unwornIndexSet.add(state.unwornVertices[i].index);
            }
            
            // Filter out unworn vertices that have worn neighbors (transition vertices)
            const pureUnwornPositions = [];
            let transitionVerticesExcluded = 0;
            
            for (let i = 0; i < state.unwornVertices.length; i++) {
                const v = state.unwornVertices[i];
                const neighbors = state.adjacency.get(v.index);
                
                // Check if this vertex has any worn neighbors
                let hasWornNeighbor = false;
                if (neighbors) {
                    for (const nIdx of neighbors) {
                        if (wornIndexSet.has(nIdx)) {
                            hasWornNeighbor = true;
                            break;
                        }
                    }
                }
                
                // Only include vertices that are NOT at the transition boundary
                if (!hasWornNeighbor) {
                    pureUnwornPositions.push(v.pos);
                } else {
                    transitionVerticesExcluded++;
                }
            }
            
            console.log(`Filtered unworn vertices: ${pureUnwornPositions.length} pure interior (excluded ${transitionVerticesExcluded} transition edge vertices)`);
            
            // Fall back to all unworn vertices if too few pure interior vertices
            const unwornPositions = pureUnwornPositions.length >= 100 ? pureUnwornPositions : 
                state.unwornVertices.map(v => v.pos);
            
            if (pureUnwornPositions.length < 100) {
                console.warn(`Too few pure interior vertices (${pureUnwornPositions.length}), using all ${state.unwornVertices.length} unworn vertices`);
            }
            
            console.log(`Prepared ${unwornPositions.length} unworn vertex positions for ${fittingShape} fitting`);
            
            let fittingResult;
            try {
                if (isEllipsoid) {
                    // Ellipsoid fitting (6 parameters: cx, cy, cz, rx, ry, rz)
                    if (fittingMethod === 'ransac') {
                        console.log('Using RANSAC + LM refinement for ellipsoid fitting (robust against outliers)...');
                        fittingResult = FittingService.fitEllipsoidRANSAC(unwornPositions);
                    } else {
                        console.log('Using Gauss-Newton + LM for ellipsoid fitting (fast convergence)...');
                        fittingResult = FittingService.fitEllipsoidGaussNewton(unwornPositions);
                    }
                } else {
                    // Sphere fitting (4 parameters: cx, cy, cz, r)
                    if (fittingMethod === 'ransac') {
                        console.log('Using RANSAC + LM refinement for sphere fitting (robust against outliers)...');
                        fittingResult = FittingService.fitSphereRANSAC(unwornPositions);
                    } else {
                        console.log('Using Gauss-Newton + LM for sphere fitting (fast convergence)...');
                        fittingResult = FittingService.fitSphereGaussNewton(unwornPositions);
                    }
                }
                
                // FIXED: Guard against null results
                if (!fittingResult || !fittingResult.center || !fittingResult.radius) {
                    throw new Error('Surface fitting failed to produce valid results');
                }
                
                // COMMERCIAL RADIUS CONSTRAINT
                // Available commercial radii for acetabular cups (in mm)
                const commercialRadii = [14, 16, 18, 20];
                const commercialRadiusSetting = document.getElementById('commercial-radius').value;
                const rawFittedRadius = fittingResult.radius;
                let constrainedRadius = rawFittedRadius;
                let selectedCommercialRadius = null;
                
                // Hide any previous warning
                document.getElementById('radius-warning').classList.add('hidden');
                
                if (!isEllipsoid) {
                    // Only apply commercial radius constraint for spherical fitting
                    if (commercialRadiusSetting === 'auto') {
                        // Find nearest commercial radius
                        let minDiff = Infinity;
                        for (const cr of commercialRadii) {
                            const diff = Math.abs(rawFittedRadius - cr);
                            if (diff < minDiff) {
                                minDiff = diff;
                                selectedCommercialRadius = cr;
                            }
                        }
                        constrainedRadius = selectedCommercialRadius;
                        
                        console.log(`Commercial radius auto-detection: raw=${rawFittedRadius.toFixed(4)}mm, nearest commercial=${selectedCommercialRadius}mm, difference=${minDiff.toFixed(4)}mm`);
                        
                        // Show warning if difference > 1mm
                        if (minDiff > 1.0) {
                            const warningText = `The fitted radius (${rawFittedRadius.toFixed(2)} mm) differs from the nearest commercial size (${selectedCommercialRadius} mm) by ${minDiff.toFixed(2)} mm. This may indicate measurement issues or a non-standard implant.`;
                            document.getElementById('radius-warning-text').textContent = warningText;
                            document.getElementById('radius-warning').classList.remove('hidden');
                            console.warn(`RADIUS WARNING: Difference of ${minDiff.toFixed(2)}mm exceeds 1mm threshold`);
                        }
                    } else {
                        // User specified a commercial radius
                        selectedCommercialRadius = parseFloat(commercialRadiusSetting);
                        constrainedRadius = selectedCommercialRadius;
                        const diff = Math.abs(rawFittedRadius - selectedCommercialRadius);
                        
                        console.log(`Commercial radius specified: ${selectedCommercialRadius}mm, raw fitted=${rawFittedRadius.toFixed(4)}mm, difference=${diff.toFixed(4)}mm`);
                        
                        // Show warning if difference > 1mm
                        if (diff > 1.0) {
                            const warningText = `The fitted radius (${rawFittedRadius.toFixed(2)} mm) differs from the selected commercial size (${selectedCommercialRadius} mm) by ${diff.toFixed(2)} mm. Please verify the commercial radius selection is correct.`;
                            document.getElementById('radius-warning-text').textContent = warningText;
                            document.getElementById('radius-warning').classList.remove('hidden');
                            console.warn(`RADIUS WARNING: Difference of ${diff.toFixed(2)}mm exceeds 1mm threshold`);
                        }
                    }
                    
                    // Apply the constrained radius
                    fittingResult.rawRadius = rawFittedRadius;
                    fittingResult.radius = constrainedRadius;
                    fittingResult.commercialRadius = selectedCommercialRadius;
                    console.log(`Radius constrained from ${rawFittedRadius.toFixed(4)}mm to commercial ${constrainedRadius}mm`);
                }
                
                state.unwornSphere = {
                    center: fittingResult.center,
                    radius: fittingResult.radius,
                    rawRadius: fittingResult.rawRadius || fittingResult.radius,
                    commercialRadius: fittingResult.commercialRadius || null,
                    radii: fittingResult.radii || null,
                    isEllipsoid: isEllipsoid
                };
                state.fittingDiagnostics = fittingResult;
                
                if (isEllipsoid) {
                    console.log(`Final ellipsoid: center=(${fittingResult.center.x.toFixed(4)}, ${fittingResult.center.y.toFixed(4)}, ${fittingResult.center.z.toFixed(4)}), radii=(${fittingResult.radii.x.toFixed(4)}, ${fittingResult.radii.y.toFixed(4)}, ${fittingResult.radii.z.toFixed(4)})`);
                    console.log(`Sphericity: ${fittingResult.sphericityPercent.toFixed(2)}%, Ellipsoidality: ${fittingResult.ellipsoidalityPercent.toFixed(2)}%`);
                } else {
                    console.log(`Final sphere: center=(${fittingResult.center.x.toFixed(4)}, ${fittingResult.center.y.toFixed(4)}, ${fittingResult.center.z.toFixed(4)}), radius=${fittingResult.radius.toFixed(4)}`);
                }
                console.log(`Method: ${fittingResult.method}, RMS Error: ${fittingResult.rmsError.toFixed(6)} mm, Iterations: ${fittingResult.iterations}, Inliers: ${fittingResult.inliers}`);
                
                // CRITICAL: Check if residuals array exists and has reasonable size
                if (!fittingResult.residuals || !Array.isArray(fittingResult.residuals)) {
                    console.warn('No residuals array found in fitting result, skipping diagnostics');
                    fittingResult.residuals = [0]; // Fallback to avoid errors
                }
                console.log(`Processing ${fittingResult.residuals.length} residuals for diagnostics`);
                
                // Update diagnostics panel
                document.getElementById('diag-method').textContent = fittingResult.method;
                document.getElementById('diag-rms').textContent = fittingResult.rmsError.toFixed(6);
                document.getElementById('diag-iterations').textContent = fittingResult.iterations;
                document.getElementById('diag-inliers').textContent = `${fittingResult.inliers} / ${unwornPositions.length}`;
                
                // FIXED: Calculate min/max iteratively to avoid stack overflow with large arrays
                let minResidual = 0;
                let maxResidual = 0;
                if (fittingResult.residuals.length > 0) {
                    minResidual = Infinity;
                    maxResidual = -Infinity;
                    for (let i = 0; i < fittingResult.residuals.length; i++) {
                        if (fittingResult.residuals[i] < minResidual) minResidual = fittingResult.residuals[i];
                        if (fittingResult.residuals[i] > maxResidual) maxResidual = fittingResult.residuals[i];
                    }
                }
                console.log(`Residual range calculated: [${minResidual}, ${maxResidual}]`);
                
                document.getElementById('diag-residual-range').textContent = 
                    `[${minResidual.toFixed(4)}, ${maxResidual.toFixed(4)}]`;
                document.getElementById('diag-convergence').textContent = 
                    fittingResult.iterations < 30 ? 'Converged' : 'Max iterations';
                
                // Calculate unworn area match metric
                // Metric: percentage of unworn vertices within tolerance of fitted surface
                const tolerance = fittingResult.rmsError * 2; // 2x RMS error as tolerance
                let matchingVertices = 0;
                
                if (isEllipsoid) {
                    // For ellipsoid: check distance using ellipsoid equation
                    for (let i = 0; i < unwornPositions.length; i++) {
                        const p = unwornPositions[i];
                        const dx = p.x - fittingResult.center.x;
                        const dy = p.y - fittingResult.center.y;
                        const dz = p.z - fittingResult.center.z;
                        const term_x = dx / fittingResult.radii.x;
                        const term_y = dy / fittingResult.radii.y;
                        const term_z = dz / fittingResult.radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const deviation = Math.abs(f - 1.0);
                        if (deviation <= tolerance) {
                            matchingVertices++;
                        }
                    }
                } else {
                    // For sphere: check radial distance
                    for (let i = 0; i < unwornPositions.length; i++) {
                        const dist = unwornPositions[i].distanceTo(fittingResult.center);
                        const deviation = Math.abs(dist - fittingResult.radius);
                        if (deviation <= tolerance) {
                            matchingVertices++;
                        }
                    }
                }
                
                const matchPercentage = (matchingVertices / unwornPositions.length) * 100;
                document.getElementById('diag-unworn-match').textContent = 
                    `${matchPercentage.toFixed(1)}% (within ${tolerance.toFixed(3)}mm)`;
                console.log(`Unworn area match: ${matchPercentage.toFixed(1)}% of ${unwornPositions.length} vertices within ${tolerance.toFixed(3)}mm tolerance`);
                
                // Show/hide ellipsoid-specific metrics
                if (isEllipsoid && fittingResult.isEllipsoid) {
                    document.getElementById('diag-sphericity-container').classList.remove('hidden');
                    document.getElementById('diag-ellipsoidality-container').classList.remove('hidden');
                    document.getElementById('diag-radii-container').classList.remove('hidden');
                    document.getElementById('diag-sphericity').textContent = fittingResult.sphericityPercent.toFixed(2);
                    document.getElementById('diag-ellipsoidality').textContent = fittingResult.ellipsoidalityPercent.toFixed(2);
                    document.getElementById('diag-radii').textContent = 
                        `(${fittingResult.radii.x.toFixed(3)}, ${fittingResult.radii.y.toFixed(3)}, ${fittingResult.radii.z.toFixed(3)})`;
                } else {
                    document.getElementById('diag-sphericity-container').classList.add('hidden');
                    document.getElementById('diag-ellipsoidality-container').classList.add('hidden');
                    document.getElementById('diag-radii-container').classList.add('hidden');
                }
                
                document.getElementById('quality-diagnostics').classList.remove('hidden');
                console.log('Diagnostics panel updated successfully');
                
                // DUAL-SPHERE MODE: Also fit sphere to worn vertices
                if (state.detectionMethod === 'dual-sphere' && state.wornVertices.length > 0) {
                    console.log('=== DUAL-SPHERE MODE: Fitting sphere to WORN zone ===');
                    
                    const wornPositions = [];
                    for (let i = 0; i < state.wornVertices.length; i++) {
                        wornPositions.push(state.wornVertices[i].pos);
                    }
                    console.log(`Prepared ${wornPositions.length} worn vertex positions for sphere fitting`);
                    
                    let wornFittingResult;
                    if (fittingMethod === 'ransac') {
                        console.log('Using RANSAC + LM for worn sphere fitting...');
                        wornFittingResult = FittingService.fitSphereRANSAC(wornPositions);
                    } else {
                        console.log('Using Gauss-Newton + LM for worn sphere fitting...');
                        wornFittingResult = FittingService.fitSphereGaussNewton(wornPositions);
                    }
                    
                    if (wornFittingResult && wornFittingResult.center && wornFittingResult.radius) {
                        // NOTE: Worn sphere is NOT constrained to commercial radius
                        // It fits freely to the actual worn surface to measure true wear
                        // The wear is measured as difference between unworn (commercial) and worn (actual) spheres
                        
                        state.wornSphere = {
                            center: wornFittingResult.center,
                            radius: wornFittingResult.radius,
                            isEllipsoid: false
                        };
                        
                        // Calculate final distance between centers
                        state.centerDistance = state.unwornSphere.center.distanceTo(state.wornSphere.center);
                        
                        // Calculate radius difference (indicator of wear depth)
                        const radiusDifference = state.unwornSphere.radius - state.wornSphere.radius;
                        
                        console.log(`Worn sphere: center=(${wornFittingResult.center.x.toFixed(4)}, ${wornFittingResult.center.y.toFixed(4)}, ${wornFittingResult.center.z.toFixed(4)}), radius=${wornFittingResult.radius.toFixed(4)}`);
                        console.log(`Unworn sphere (commercial): center=(${state.unwornSphere.center.x.toFixed(4)}, ${state.unwornSphere.center.y.toFixed(4)}, ${state.unwornSphere.center.z.toFixed(4)}), radius=${state.unwornSphere.radius.toFixed(4)}`);
                        console.log(`DISTANCE BETWEEN SPHERE CENTERS: ${state.centerDistance.toFixed(4)} mm`);
                        console.log(`RADIUS DIFFERENCE (unworn - worn): ${radiusDifference.toFixed(4)} mm`);
                        console.log(`Worn sphere RMS Error: ${wornFittingResult.rmsError.toFixed(6)} mm`);
                    } else {
                        console.warn('Worn sphere fitting failed, using preliminary center');
                        state.wornSphere = {
                            center: state.preliminaryWornCenter || state.unwornSphere.center.clone(),
                            radius: state.unwornSphere.radius,
                            isEllipsoid: false
                        };
                        state.centerDistance = state.unwornSphere.center.distanceTo(state.wornSphere.center);
                    }
                } else {
                    state.wornSphere = null;
                }
                
            } catch (error) {
                console.error('Sphere fitting error:', error);
                alert(`Sphere fitting failed: ${error.message}. Please try a different method or check your data.`);
                showLoading(false);
                document.getElementById('sphere-loading-overlay').classList.add('hidden');
                return;
            }
            
            // Calculate transition plane using RIM BOUNDARY POINTS
            // NEW v3.4: Plane is generated from rim exclusion edge, not worn/unworn inflection
            try {
                console.log('=== Calculating transition plane using RIM BOUNDARY POINTS (v3.4) ===');
                console.log(`Rim boundary points detected: ${state.rimBoundaryPoints.length}`);
                
                // Convert rim boundary vertices to positions for plane fitting
                const boundaryVertices = [];
                for (let i = 0; i < state.rimBoundaryPoints.length; i++) {
                    boundaryVertices.push(state.rimBoundaryPoints[i].pos);
                }
                
                console.log(`Using ${boundaryVertices.length} rim boundary points to define transition plane`);
                console.log(`This plane delimits the inner surface after rim exclusion`);
            
            // Fit plane to boundary points using RADIAL method
            // IMPROVED: Use radial direction method for robust plane positioning
            // This ensures the plane passes through the centroid of boundary points
            // with normal pointing in the natural radial wear direction
            if (boundaryVertices.length < 3) {
                console.warn(`Not enough boundary points (${boundaryVertices.length}), using sphere-based fallback plane`);
                // Fallback: Use radial direction plane
                let avgWornDist = state.unwornSphere.radius * 0.9;
                if (state.wornVertices.length > 0) {
                    // FIXED: Calculate average iteratively to avoid stack overflow
                    let sumDist = 0;
                    for (let i = 0; i < state.wornVertices.length; i++) {
                        sumDist += state.wornVertices[i].pos.distanceTo(state.unwornSphere.center);
                    }
                    avgWornDist = sumDist / state.wornVertices.length;
                }
                const defaultRadialDist = (state.unwornSphere.radius + avgWornDist) / 2;
                const radialDir = new THREE.Vector3(0, 0, 1);
                const planePoint = state.unwornSphere.center.clone().add(radialDir.clone().multiplyScalar(defaultRadialDist));
                
                // FIXED v4.0: Consistent plane equation form n·x - d = 0, where d = n·point
                state.transitionPlane = { 
                    normal: radialDir, 
                    point: planePoint,
                    d: radialDir.dot(planePoint)  // FIXED: positive for consistency
                };
                console.log(`Fallback plane: radial dist=${defaultRadialDist.toFixed(3)} (form: n·x - d = 0)`);
            } else {
                // PCA METHOD: Fit plane to rim boundary points using Principal Component Analysis
                // This ensures the plane actually passes through the inflection markers (yellow dots)
                console.log('Fitting plane to rim boundary points using PCA (best-fit plane through inflection markers)...');
                console.log(`Calling PCAService.computePlane with ${boundaryVertices.length} points...`);
                
                // Use PCAService to compute best-fit plane
                const pcaResult = PCAService.computePlane(boundaryVertices);
                
                console.log(`PCA result:`, pcaResult);
                
                if (!pcaResult) {
                    console.warn('PCA failed, falling back to centroid-based plane');
                    // Fallback: simple centroid-based plane
                    const centroid = new THREE.Vector3(0, 0, 0);
                    for (let i = 0; i < boundaryVertices.length; i++) {
                        centroid.add(boundaryVertices[i]);
                    }
                    centroid.divideScalar(boundaryVertices.length);
                    
                    const radialDir = new THREE.Vector3().subVectors(state.unwornSphere.center, centroid).normalize();
                    const d = radialDir.dot(centroid);  // FIXED v4.0: positive for consistency
                    
                    state.transitionPlane = { normal: radialDir, point: centroid, d };
                    console.log(`Fallback plane: normal=(${radialDir.x}, ${radialDir.y}, ${radialDir.z}), d=${d} (form: n·x - d = 0)`);
                } else {
                    // PCA succeeded - use the best-fit plane
                    let normal = pcaResult.normal.clone();  // Clone to avoid mutation
                    const centroid = pcaResult.centroid;
                    
                    // Ensure normal points from rim boundary toward sphere center (inward)
                    // This is critical for correct signed distance calculations in wear volume
                    const radialDir = new THREE.Vector3().subVectors(state.unwornSphere.center, centroid);
                    if (radialDir.dot(normal) < 0) {
                        normal.negate(); // Flip to point inward
                    }
                    
                    // FIXED v4.0: Consistent plane equation: n·x - d = 0, where d = n·centroid
                    // Signed distance from point Q to plane = n·Q - d
                    // Points with distance <= 0 are on the "inner" side (toward sphere center)
                    const point = centroid;
                    const d = normal.dot(point);  // FIXED: positive (was negative, causing inconsistency)
                    
                    state.transitionPlane = { normal, point, d };
                    console.log(`Transition plane FITTED TO RIM BOUNDARY (PCA best-fit):`);
                    console.log(`  Normal (inward toward sphere): (${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)})`);
                    console.log(`  Point (boundary centroid): (${point.x.toFixed(4)}, ${point.y.toFixed(4)}, ${point.z.toFixed(4)})`);
                    console.log(`  Plane equation d: ${d.toFixed(4)} (form: n·x - d = 0)`);
                    
                    // Calculate quality metric: avg distance from rim boundary points to fitted plane
                    // FIXED v4.0: Using consistent equation n·x - d = 0, so distance = n·x - d
                    let avgPlaneDistance = 0;
                    let maxPlaneDistance = 0;
                    for (let i = 0; i < boundaryVertices.length; i++) {
                        const dist = Math.abs(normal.dot(boundaryVertices[i]) - d);  // FIXED: was + d
                        avgPlaneDistance += dist;
                        maxPlaneDistance = Math.max(maxPlaneDistance, dist);
                    }
                    avgPlaneDistance /= boundaryVertices.length;
                    console.log(`  Avg distance from rim boundary to plane: ${avgPlaneDistance.toFixed(6)} mm (best-fit - should be <0.1mm)`);
                    console.log(`  Max distance: ${maxPlaneDistance.toFixed(6)} mm`);
                    
                    if (avgPlaneDistance > 1.0) {
                        console.warn(`WARNING: High average distance (${avgPlaneDistance.toFixed(3)}mm) suggests PCA may not be working correctly`);
                    } else {
                        console.log(`  ✓ Plane successfully contains the inflection markers (yellow dots) at rim exclusion boundary`);
                    }
                }
            }
            
            // Visualize rim boundary points if enabled
            if (document.getElementById('show-inflection-markers').checked && boundaryVertices.length > 0) {
                console.log(`Visualizing ${boundaryVertices.length} rim boundary point markers...`);
                // Clear existing markers
                for (let i = 0; i < state.inflectionMarkers.length; i++) {
                    scene.remove(state.inflectionMarkers[i]);
                }
                state.inflectionMarkers = [];
                
                // Add small sphere markers at rim boundary points
                // OPTIMIZED: Limit to max 1000 markers to avoid performance issues
                const markerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                const step = Math.max(1, Math.floor(boundaryVertices.length / 1000));
                for (let i = 0; i < boundaryVertices.length; i += step) {
                    const pos = boundaryVertices[i];
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(pos);
                    scene.add(marker);
                    state.inflectionMarkers.push(marker);
                }
                console.log(`Added ${state.inflectionMarkers.length} rim boundary markers (step=${step})`);
            }
            
            // Clear and update sphere viewer
            while (sphereScene.children.length > 0) {
                sphereScene.remove(sphereScene.children[0]);
            }
            
            sphereScene.add(sphereAmbientLight);
            sphereScene.add(sphereDirectionalLight);
            
            // Add STL mesh with vertex colors AND transparency for non-isolated surfaces
            const clonedGeometry = state.geometry.clone();
            
            // CRITICAL: geometry.clone() does NOT preserve groups, must copy manually
            // Copy groups from original geometry to preserve inner/outer surface separation
            clonedGeometry.clearGroups();
            if (state.geometry.groups && state.geometry.groups.length > 0) {
                state.geometry.groups.forEach(group => {
                    clonedGeometry.addGroup(group.start, group.count, group.materialIndex);
                });
                console.log(`Copied ${state.geometry.groups.length} geometry groups to cloned geometry`);
            }
            
            // Set up vertex colors and transparency for worn/unworn/rim zones
            const colors = new Float32Array(clonedGeometry.attributes.position.count * 3);
            const alphas = new Float32Array(clonedGeometry.attributes.position.count);
            
            // Default color (blue) and alpha (opaque)
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259; colors[i + 1] = 0.6; colors[i + 2] = 0.882;
            }
            for (let i = 0; i < alphas.length; i++) {
                alphas[i] = 0.7;  // Default opacity for sphere viewer
            }
            
            // Worn vertices (red, opaque)
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96; colors[idx + 1] = 0.396; colors[idx + 2] = 0.396;
                alphas[v.index] = 0.7;
            });
            
            // Unworn vertices (green, opaque)
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282; colors[idx + 1] = 0.733; colors[idx + 2] = 0.471;
                alphas[v.index] = 0.7;
            });
            
            // Rim vertices (gray, transparent)
            state.rimVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.259; colors[idx + 1] = 0.6; colors[idx + 2] = 0.882;
                alphas[v.index] = 0.25;  // Transparent like outer surface
            });
            
            clonedGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            clonedGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            
            // Create multi-material setup: inner surface opaque, outer surface 75% transparent
            // This matches the behavior in the main 3D viewer
            // CRITICAL: Both materials MUST have vertexColors:true to share the BufferGeometry correctly
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7  // Inner surface with vertex colors
                }),
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // CRITICAL: Must be true to properly share geometry with inner material
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent (25% opaque)
                    depthWrite: false
                })
            ];
            
            const clonedMesh = new THREE.Mesh(clonedGeometry, materials);
            clonedMesh.renderOrder = 1;
            
            // Force proper transparency rendering by ensuring renderer sorts objects
            sphereRenderer.sortObjects = true;
            
            sphereScene.add(clonedMesh);
            
            // Add unworn reference sphere (yellow wireframe)
            const unwornSphereGeom = new THREE.SphereGeometry(state.unwornSphere.radius, 64, 64);
            const wireframeGeom = new THREE.WireframeGeometry(unwornSphereGeom);
            const unwornSphereMat = new THREE.LineBasicMaterial({
                color: 0xffff00,  // Yellow
                linewidth: 0.5
            });
            const unwornSphereMesh = new THREE.LineSegments(wireframeGeom, unwornSphereMat);
            unwornSphereMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornSphereMesh);
            
            // Add unworn sphere center marker
            const unwornCenterGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const unwornCenterMat = new THREE.MeshBasicMaterial({ color: 0x48bb78 });
            const unwornCenterMesh = new THREE.Mesh(unwornCenterGeom, unwornCenterMat);
            unwornCenterMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornCenterMesh);
            
            // DUAL-SPHERE MODE: Add worn reference sphere (red wireframe)
            if (state.wornSphere && state.detectionMethod === 'dual-sphere') {
                console.log('Adding worn sphere visualization (red wireframe)...');
                
                const wornSphereGeom = new THREE.SphereGeometry(state.wornSphere.radius, 64, 64);
                const wornWireframeGeom = new THREE.WireframeGeometry(wornSphereGeom);
                const wornSphereMat = new THREE.LineBasicMaterial({
                    color: 0xff4444,  // Red
                    linewidth: 0.5
                });
                const wornSphereMesh = new THREE.LineSegments(wornWireframeGeom, wornSphereMat);
                wornSphereMesh.position.copy(state.wornSphere.center);
                sphereScene.add(wornSphereMesh);
                
                // Add worn sphere center marker
                const wornCenterGeom = new THREE.SphereGeometry(0.8, 16, 16);
                const wornCenterMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                const wornCenterMesh = new THREE.Mesh(wornCenterGeom, wornCenterMat);
                wornCenterMesh.position.copy(state.wornSphere.center);
                sphereScene.add(wornCenterMesh);
                
                // Add line connecting the two centers
                const centerLineGeom = new THREE.BufferGeometry();
                const centerLinePositions = new Float32Array([
                    state.unwornSphere.center.x, state.unwornSphere.center.y, state.unwornSphere.center.z,
                    state.wornSphere.center.x, state.wornSphere.center.y, state.wornSphere.center.z
                ]);
                centerLineGeom.setAttribute('position', new THREE.BufferAttribute(centerLinePositions, 3));
                const centerLineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                const centerLine = new THREE.Line(centerLineGeom, centerLineMat);
                sphereScene.add(centerLine);
                
                console.log(`Worn sphere added at (${state.wornSphere.center.x.toFixed(2)}, ${state.wornSphere.center.y.toFixed(2)}, ${state.wornSphere.center.z.toFixed(2)}), r=${state.wornSphere.radius.toFixed(2)}`);
                console.log(`Center distance visualized: ${state.centerDistance.toFixed(3)} mm`);
            }
            
            // Add transition plane at RIM EXCLUSION BOUNDARY (v3.4)
            const planeSize = state.unwornSphere.radius * 4;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,  // Green to mark the rim boundary
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const planeMesh = new THREE.Mesh(planeGeom, planeMat);
            planeMesh.position.copy(state.transitionPlane.point);
            
            // Orient plane to match normal (radial direction)
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, state.transitionPlane.normal);
            planeMesh.quaternion.copy(quaternion);
            sphereScene.add(planeMesh);
            
            // Add rim boundary vertices visualization (yellow/gold points at rim exclusion edge)
            const boundaryGeom = new THREE.BufferGeometry();
            const boundaryPositions = new Float32Array(boundaryVertices.length * 3);
            boundaryVertices.forEach((v, i) => {
                boundaryPositions[i * 3] = v.x;
                boundaryPositions[i * 3 + 1] = v.y;
                boundaryPositions[i * 3 + 2] = v.z;
            });
            boundaryGeom.setAttribute('position', new THREE.BufferAttribute(boundaryPositions, 3));
            const boundaryMat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.8 });
            const boundaryPoints = new THREE.Points(boundaryGeom, boundaryMat);
            sphereScene.add(boundaryPoints);
            
            // Position camera
            const size = new THREE.Vector3();
            state.geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            sphereCamera.position.set(maxDim, maxDim, maxDim);
            sphereControls.target.set(0, 0, 0);
            sphereControls.update();
            
            } catch (boundaryError) {
                console.error('Boundary detection error:', boundaryError);
                console.error('Stack:', boundaryError.stack);
                alert(`Boundary detection failed: ${boundaryError.message}. Using simplified plane calculation.`);
                
                // Fallback: Use simple radial plane
                const avgWornDist = state.unwornSphere.radius * 0.9;
                const radialDir = new THREE.Vector3(0, 0, 1);
                const planePoint = state.unwornSphere.center.clone().add(radialDir.clone().multiplyScalar(avgWornDist));
                
                state.transitionPlane = { 
                    normal: radialDir, 
                    point: planePoint,
                    d: radialDir.dot(planePoint)
                };
                state.inflectionPoints = [];
            }
            
            updateStatus('complete', 'Unworn sphere fitted and transition boundary detected');
            showLoading(false);
            document.getElementById('sphere-loading-overlay').classList.add('hidden');
            document.getElementById('btn-download-sphere-view').classList.remove('hidden');
            enableButton('btn-calculate', true);
        });

        // ALGORITHM 4: Calculate Volumetric and Linear Wear
        // NEW METHOD: Volume between transition plane and worn surface, minus spherical cap
        // Formula: V_wear = V(plane to surface) - V(spherical cap)
        document.getElementById('btn-calculate').addEventListener('click', async () => {
            if (!state.unwornSphere || !state.transitionPlane) {
                alert('Please fit unworn sphere and detect transition plane first');
                return;
            }
            
            updateStatus('processing', 'Calculating wear volume: (plane-to-surface) - (spherical cap)...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            console.log('=== VOLUMETRIC WEAR CALCULATION (v4.0 CORRECTED METHOD) ===');
            console.log('Formula: V_wear = Volume between fitted sphere and real worn surface (clipped by plane)');
            console.log('Plane equation: n·x - d = 0, where n =', state.transitionPlane.normal, ', d =', state.transitionPlane.d);
            console.log('Distance to plane = n·x - d; negative distance = inside boundary (toward sphere center)');
            
            const positions = state.geometry.attributes.position.array;
            
            // CRITICAL FIX: Build Set iteratively to avoid stack overflow with 41k vertices
            const wornVertexIndices = new Set();
            for (let i = 0; i < state.wornVertices.length; i++) {
                wornVertexIndices.add(state.wornVertices[i].index);
            }
            
            const planeNormal = state.transitionPlane.normal;
            const planeD = state.transitionPlane.d;
            const sphereCenter = state.unwornSphere.center;
            const sphereRadius = state.unwornSphere.radius;
            
            console.log(`Sphere center: (${sphereCenter.x.toFixed(4)}, ${sphereCenter.y.toFixed(4)}, ${sphereCenter.z.toFixed(4)})`);
            console.log(`Sphere radius used for calculations: ${sphereRadius.toFixed(4)} mm`);
            
            // Helper: Calculate signed distance from point to plane
            function distanceToPlane(point, planeNormal, planeD) {
                return point.dot(planeNormal) - planeD;
            }
            
            // Helper: Calculate signed tetrahedral volume
            function tetrahedronVolume(v0, v1, v2, v3) {
                const a = new THREE.Vector3().subVectors(v1, v0);
                const b = new THREE.Vector3().subVectors(v2, v0);
                const c = new THREE.Vector3().subVectors(v3, v0);
                const cross = new THREE.Vector3().crossVectors(b, c);
                return a.dot(cross) / 6.0;
            }
            
            // Helper: Project point onto sphere surface (radially)
            function projectToSphere(point, center, radius) {
                const dir = new THREE.Vector3().subVectors(point, center);
                const dist = dir.length();
                if (dist < 0.0001) {
                    // Point too close to center, return arbitrary point on sphere
                    return new THREE.Vector3(center.x + radius, center.y, center.z);
                }
                const normalized = dir.clone().divideScalar(dist);
                return new THREE.Vector3().addVectors(center, normalized.multiplyScalar(radius));
            }
            
            // Helper: Project point onto ellipsoid surface (radially along normalized direction)
            function projectToEllipsoid(point, center, radii) {
                const dir = new THREE.Vector3().subVectors(point, center);
                const dist = dir.length();
                if (dist < 0.0001) {
                    // Point too close to center, return arbitrary point on ellipsoid
                    return new THREE.Vector3(center.x + radii.x, center.y, center.z);
                }
                
                // For ellipsoid projection, we need to find the point on the ellipsoid surface
                // along the ray from center to point. This requires solving a quadratic equation.
                // Parametric line: P(t) = center + t*dir
                // Ellipsoid: (x/rx)² + (y/ry)² + (z/rz)² = 1
                
                // Normalized direction
                const dx = dir.x;
                const dy = dir.y;
                const dz = dir.z;
                
                // Quadratic coefficients for intersection with ellipsoid
                const a = (dx*dx)/(radii.x*radii.x) + (dy*dy)/(radii.y*radii.y) + (dz*dz)/(radii.z*radii.z);
                const t = 1.0 / Math.sqrt(a); // Distance along ray to ellipsoid surface
                
                return new THREE.Vector3(
                    center.x + t * dx,
                    center.y + t * dy,
                    center.z + t * dz
                );
            }
            
            // Helper: Calculate penetration depth for ellipsoid
            // Returns the radial penetration depth from the ellipsoid surface to the point
            function penetrationDepthEllipsoid(point, center, radii) {
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                const dz = point.z - center.z;
                
                // Distance from point to center
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist < 1e-10) {
                    // Point is at center - penetration is average radius
                    return (radii.x + radii.y + radii.z) / 3;
                }
                
                // Ellipsoid equation: (x/rx)² + (y/ry)² + (z/rz)² = 1
                // Normalized distance f: how far along the ray we are relative to the ellipsoid surface
                const f = Math.sqrt(
                    (dx*dx)/(radii.x*radii.x) + 
                    (dy*dy)/(radii.y*radii.y) + 
                    (dz*dz)/(radii.z*radii.z)
                );
                
                // Distance from center to ellipsoid surface along this ray direction
                const distToSurface = dist / f;
                
                // Penetration = surface_distance - actual_distance
                // Positive = point is inside (worn), Negative = point is outside
                const penetration = distToSurface - dist;
                
                return penetration;
            }
            
            // VOLUMETRIC WEAR: Integral of positive penetrations between fitted sphere and ALL inner surface
            // Volume = ∫(penetration · dA) for ALL triangles within transition plane boundary where penetration > 0
            // This measures total material loss (real surface inside fitted sphere) without relying on worn/unworn classification
            console.log('=== Calculating volumetric wear: ALL positive penetrations (bounded by transition plane) ===');
            console.log('Method: Integrate penetration depth × area for ALL triangles with positive penetration');
            console.log('Independent of worn/unworn classification - measures real geometric deviation');
            console.log('CODE VERSION: v3.2 - Full surface integration with positive penetration filter');
            
            let volumetricWear = 0;
            let processedTriangleCount = 0;
            let totalClippedTriangles = 0;
            
            // Kahan summation for numerical stability
            let kahanC = 0;
            
            // Helper: Calculate triangle area
            function triangleArea(p1, p2, p3) {
                const v1 = new THREE.Vector3().subVectors(p2, p1);
                const v2 = new THREE.Vector3().subVectors(p3, p1);
                const cross = new THREE.Vector3().crossVectors(v1, v2);
                return cross.length() / 2.0;
            }
            
            // Helper: Clip triangle by plane, return sub-triangles INSIDE the bounded region (distance <= 0)
            // Returns array of triangles (each as {p1, p2, p3}) that lie inside the boundary
            // FIXED v4.0: Plane equation n·x - d = 0, distance = n·x - d
            // Plane normal points INWARD (from rim boundary toward sphere center)
            // Vertices INSIDE the bounded region (between plane and inner surface) have distance <= 0
            function clipTriangleByPlane(p1, p2, p3, planeNormal, planeD) {
                // Calculate signed distances to plane for all three vertices
                // distance = n·x - d; negative = inside boundary (toward center)
                const d1 = distanceToPlane(p1, planeNormal, planeD);
                const d2 = distanceToPlane(p2, planeNormal, planeD);
                const d3 = distanceToPlane(p3, planeNormal, planeD);
                
                // Classify vertices: inside boundary (distance <= 0) or outside (distance > 0)
                // Since normal points INWARD (toward center), inside region has negative/zero distance
                const inside1 = d1 <= 0;
                const inside2 = d2 <= 0;
                const inside3 = d3 <= 0;
                
                const insideCount = (inside1 ? 1 : 0) + (inside2 ? 1 : 0) + (inside3 ? 1 : 0);
                
                // Case 1: All vertices inside boundary (distance <= 0) - return entire triangle
                if (insideCount === 3) {
                    return [{ p1, p2, p3 }];
                }
                
                // Case 2: No vertices inside - triangle is completely outside, return empty
                if (insideCount === 0) {
                    return [];
                }
                
                // Case 3: Triangle crosses the plane - need to clip it
                // Helper function to find intersection point between two vertices where one is on each side
                function findIntersection(pInside, pOutside, dInside, dOutside) {
                    // Linear interpolation: intersection at t where d(t) = 0
                    // d(t) = dInside + t*(dOutside - dInside) = 0
                    // t = -dInside / (dOutside - dInside)
                    const t = -dInside / (dOutside - dInside);
                    return new THREE.Vector3().lerpVectors(pInside, pOutside, t);
                }
                
                // Case 3a: Two vertices inside, one outside
                // Result: One quadrilateral (split into 2 triangles)
                if (insideCount === 2) {
                    let pIn1, pIn2, pOut, dIn1, dIn2, dOut;
                    
                    // Identify which vertices are inside and which is outside
                    if (!inside1) {
                        pOut = p1; dOut = d1;
                        pIn1 = p2; dIn1 = d2;
                        pIn2 = p3; dIn2 = d3;
                    } else if (!inside2) {
                        pOut = p2; dOut = d2;
                        pIn1 = p1; dIn1 = d1;
                        pIn2 = p3; dIn2 = d3;
                    } else {
                        pOut = p3; dOut = d3;
                        pIn1 = p1; dIn1 = d1;
                        pIn2 = p2; dIn2 = d2;
                    }
                    
                    // Find intersection points where edges cross the plane
                    const int1 = findIntersection(pIn1, pOut, dIn1, dOut);
                    const int2 = findIntersection(pIn2, pOut, dIn2, dOut);
                    
                    // Return quadrilateral as two triangles
                    return [
                        { p1: pIn1, p2: int1, p3: int2 },
                        { p1: pIn1, p2: int2, p3: pIn2 }
                    ];
                }
                
                // Case 3b: One vertex inside, two outside
                // Result: One triangle (smaller piece on inside)
                if (insideCount === 1) {
                    let pIn, pOut1, pOut2, dIn, dOut1, dOut2;
                    
                    // Identify which vertex is inside and which are outside
                    if (inside1) {
                        pIn = p1; dIn = d1;
                        pOut1 = p2; dOut1 = d2;
                        pOut2 = p3; dOut2 = d3;
                    } else if (inside2) {
                        pIn = p2; dIn = d2;
                        pOut1 = p1; dOut1 = d1;
                        pOut2 = p3; dOut2 = d3;
                    } else {
                        pIn = p3; dIn = d3;
                        pOut1 = p1; dOut1 = d1;
                        pOut2 = p2; dOut2 = d2;
                    }
                    
                    // Find intersection points where edges cross the plane
                    const int1 = findIntersection(pIn, pOut1, dIn, dOut1);
                    const int2 = findIntersection(pIn, pOut2, dIn, dOut2);
                    
                    // Return the small triangle on the inside
                    return [{ p1: pIn, p2: int1, p3: int2 }];
                }
                
                // Should never reach here
                return [];
            }
            
            // CRITICAL FIX v3.8: Use filtered inner surface triangles from Step 1
            // This ensures we only integrate over triangles that were properly isolated
            // and the same triangle set is used for both volume calculation and visualization
            
            if (!state.filteredInnerTriangles || state.filteredInnerTriangles.length === 0) {
                console.error('No filtered inner triangles found! Run Step 1 (Isolate Inner Surface) first.');
                alert('Please run Step 1 (Isolate Inner Surface) first to generate filtered triangle data.');
                showLoading(false);
                return;
            }
            
            console.log(`Processing ${state.filteredInnerTriangles.length} filtered inner triangles (from Step 1)`);
            
            // DEBUG v4.0: Log plane equation details
            console.log(`DEBUG: Plane normal = (${planeNormal.x.toFixed(6)}, ${planeNormal.y.toFixed(6)}, ${planeNormal.z.toFixed(6)})`);
            console.log(`DEBUG: Plane d = ${planeD.toFixed(6)}`);
            console.log(`DEBUG: Plane point = (${state.transitionPlane.point.x.toFixed(6)}, ${state.transitionPlane.point.y.toFixed(6)}, ${state.transitionPlane.point.z.toFixed(6)})`);
            
            // Verify plane passes through its defining point (distance should be ~0)
            const testDist = planeNormal.dot(state.transitionPlane.point) - planeD;
            console.log(`DEBUG: Distance from plane point to plane = ${testDist.toFixed(10)} (should be ~0)`);
            
            // Store processed triangles for visualization sync
            state.processedWearTriangles = [];
            
            for (const triangle of state.filteredInnerTriangles) {
                // Use pre-stored triangle vertices from Step 1
                const p1 = triangle.p1.clone();
                const p2 = triangle.p2.clone();
                const p3 = triangle.p3.clone();
                
                // CRITICAL: Clip triangle by transition plane to get only the portion within the bounded region
                // This ensures we only integrate within the space between the plane and the inner surface
                const clippedTriangles = clipTriangleByPlane(p1, p2, p3, planeNormal, planeD);
                
                // Track clipped triangles for debugging
                totalClippedTriangles += clippedTriangles.length;
                
                // Skip if triangle is completely outside the bounded region
                if (clippedTriangles.length === 0) continue;
                
                // Process each clipped sub-triangle
                for (const tri of clippedTriangles) {
                    // Calculate penetration depth for each vertex of the clipped triangle
                    let pen1, pen2, pen3;
                    
                    if (state.unwornSphere.isEllipsoid && state.unwornSphere.radii) {
                        // Ellipsoid penetration depth (INVERTED for acetabular geometry)
                        // For acetabular cups, wear moves surface OUTWARD, so we invert the sign
                        pen1 = -penetrationDepthEllipsoid(tri.p1, sphereCenter, state.unwornSphere.radii);
                        pen2 = -penetrationDepthEllipsoid(tri.p2, sphereCenter, state.unwornSphere.radii);
                        pen3 = -penetrationDepthEllipsoid(tri.p3, sphereCenter, state.unwornSphere.radii);
                    } else {
                        // Sphere penetration depth for ACETABULAR geometry
                        // CRITICAL: For acetabular cups, wear removes material causing surface to move OUTWARD
                        // Positive penetration = point is FARTHER from center than sphere (worn area)
                        // Formula: distanceToCenter - sphereRadius (inverted from femoral head convention)
                        const dist1 = tri.p1.distanceTo(sphereCenter);
                        const dist2 = tri.p2.distanceTo(sphereCenter);
                        const dist3 = tri.p3.distanceTo(sphereCenter);
                        pen1 = dist1 - sphereRadius;
                        pen2 = dist2 - sphereRadius;
                        pen3 = dist3 - sphereRadius;
                        
                        // DEBUG: Log first few triangles to verify formula
                        if (processedTriangleCount < 3) {
                            console.log(`DEBUG Triangle ${processedTriangleCount}: dist1=${dist1.toFixed(4)}, sphereRadius=${sphereRadius.toFixed(4)}, pen1=${pen1.toFixed(4)}`);
                        }
                    }
                    
                    // Average penetration over the clipped triangle
                    const avgPenetration = (pen1 + pen2 + pen3) / 3.0;
                    
                    // Only include triangles with positive penetration (actual material loss)
                    // This ensures we only measure worn regions inside the reference sphere
                    if (avgPenetration <= 0) continue;
                    
                    // Calculate triangle area
                    const area = triangleArea(tri.p1, tri.p2, tri.p3);
                    
                    // Volume contribution = average_penetration × area
                    const volumeContribution = avgPenetration * area;
                    
                    // Kahan summation to minimize floating-point error
                    const y = volumeContribution - kahanC;
                    const t = volumetricWear + y;
                    kahanC = (t - volumetricWear) - y;
                    volumetricWear = t;
                    
                    // Store this triangle for synchronized visualization
                    state.processedWearTriangles.push({
                        p1: tri.p1.clone(),
                        p2: tri.p2.clone(),
                        p3: tri.p3.clone(),
                        avgPenetration: avgPenetration
                    });
                    
                    processedTriangleCount++;
                }
            }
            
            console.log(`Stored ${state.processedWearTriangles.length} triangles for synchronized visualization`);
            console.log(`Total clipped sub-triangles generated: ${totalClippedTriangles}`);
            console.log(`Processed ${processedTriangleCount} triangles with positive penetration (bounded by transition plane)`);
            console.log(`Volumetric wear (all positive deviations, bounded by plane): ${volumetricWear.toFixed(4)} mm³`);
            
            // For backward compatibility with visualization code
            const volumePlaneToSurface = volumetricWear;
            const sphericalCapVolume = 0;
            
            console.log('=== FINAL RESULT ===');
            console.log(`Volumetric wear = ${volumePlaneToSurface.toFixed(4)} - ${sphericalCapVolume.toFixed(4)} = ${volumetricWear.toFixed(4)} mm³`);
            
            // LINEAR WEAR: Calculate PERPENDICULAR penetration depths (radial distance from ideal sphere)
            // CORRECTED: Only measure in the space between transition plane and real inner surface
            // This frames the measurement within the worn zone, from the plane to the inner face
            console.log('=== LINEAR WEAR (Perpendicular Penetration Depth - Framed by Transition Plane) ===');
            const penetrationDepths = [];
            let filteredWornCount = 0;
            let maxPenetrationVertex = null;
            let maxPenetrationValue = 0;
            
            state.wornVertices.forEach(v => {
                // Filter: Only include vertices on the WORN side of the transition plane
                // CRITICAL: Plane normal points radially INWARD (from boundary to center)
                // Worn vertices are closer to center, in front of the plane, so distance <= 0
                const distToTransitionPlane = distanceToPlane(v.pos, planeNormal, planeD);
                
                // Only measure vertices that are on the worn side (negative/zero distance, in front of plane)
                if (distToTransitionPlane <= 0) {
                    // Calculate penetration depth based on surface type
                    let penetration;
                    
                    if (state.unwornSphere.isEllipsoid && state.unwornSphere.radii) {
                        // Ellipsoid penetration (INVERTED for acetabular geometry)
                        penetration = -penetrationDepthEllipsoid(v.pos, state.unwornSphere.center, state.unwornSphere.radii);
                    } else {
                        // Sphere penetration for ACETABULAR geometry
                        // CRITICAL: For acetabular cups, wear moves surface OUTWARD
                        // Positive penetration = point is FARTHER from center than sphere
                        const distToCenter = v.pos.distanceTo(state.unwornSphere.center);
                        penetration = distToCenter - state.unwornSphere.radius;
                    }
                    
                    // Only include positive penetrations (actual wear)
                    if (penetration > 0) {
                        penetrationDepths.push(penetration);
                        filteredWornCount++;
                        
                        // Track vertex with maximum penetration for visualization
                        if (penetration > maxPenetrationValue) {
                            maxPenetrationValue = penetration;
                            maxPenetrationVertex = v.pos.clone();
                        }
                    }
                }
            });
            
            console.log(`Filtered worn vertices within transition plane frame: ${filteredWornCount} / ${state.wornVertices.length}`);
            
            // Calculate statistics - FIXED: Iterative min/max to avoid stack overflow
            let meanPenetration = 0;
            let maxPenetration = 0;
            let minPenetration = 0;
            
            if (penetrationDepths.length > 0) {
                meanPenetration = penetrationDepths.reduce((a, b) => a + b, 0) / penetrationDepths.length;
                maxPenetration = penetrationDepths[0];
                minPenetration = penetrationDepths[0];
                
                for (let i = 1; i < penetrationDepths.length; i++) {
                    if (penetrationDepths[i] > maxPenetration) maxPenetration = penetrationDepths[i];
                    if (penetrationDepths[i] < minPenetration) minPenetration = penetrationDepths[i];
                }
            }
            
            console.log(`Mean perpendicular penetration: ${meanPenetration.toFixed(4)} mm`);
            console.log(`Max perpendicular penetration: ${maxPenetration.toFixed(4)} mm (deepest point)`);
            console.log(`Min perpendicular penetration: ${minPenetration.toFixed(4)} mm`);
            
            // Calculate areas for reference
            const wornArea = state.wornVertices.length * 0.1;
            const unwornArea = state.unwornVertices.length * 0.1;
            
            // VISUALIZATION: Add wear volume mesh using SHARED processed triangles
            // CRITICAL FIX v3.8: Use state.processedWearTriangles from volumetric calculation
            // This ensures perfect numeric-visual consistency
            console.log('=== Creating wear volume visualization (bright orange) ===');
            console.log('Using SHARED processed triangles from volumetric calculation for perfect consistency');
            
            // Build geometry directly from the processed wear triangles stored during volumetric calculation
            const wearVolumePositions = [];
            const wearVolumeIndices = [];
            let vertexCount = 0;
            
            console.log(`DEBUG: Using ${state.processedWearTriangles.length} pre-processed wear triangles`);
            console.log(`DEBUG: Sphere center=(${sphereCenter.x.toFixed(3)}, ${sphereCenter.y.toFixed(3)}, ${sphereCenter.z.toFixed(3)}), radius=${sphereRadius.toFixed(3)}`);
            
            // Directly use the triangles that were calculated for volumetric wear
            for (const tri of state.processedWearTriangles) {
                wearVolumePositions.push(tri.p1.x, tri.p1.y, tri.p1.z);
                wearVolumePositions.push(tri.p2.x, tri.p2.y, tri.p2.z);
                wearVolumePositions.push(tri.p3.x, tri.p3.y, tri.p3.z);
                wearVolumeIndices.push(vertexCount, vertexCount+1, vertexCount+2);
                vertexCount += 3;
            }
            
            console.log(`DEBUG: Wear volume triangles: ${state.processedWearTriangles.length}`);
            console.log(`DEBUG: wearVolumePositions.length=${wearVolumePositions.length} (guaranteed to match volumetric calc)`);
            
            // Add wear volume to sphere viewer if we have triangles
            if (wearVolumePositions.length > 0) {
                const wearVolumeGeom = new THREE.BufferGeometry();
                wearVolumeGeom.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(wearVolumePositions), 3));
                wearVolumeGeom.setIndex(wearVolumeIndices);
                wearVolumeGeom.computeVertexNormals();
                
                const wearVolumeMat = new THREE.MeshPhongMaterial({
                    color: 0xff6600,  // BRIGHT ORANGE for high visibility
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    emissive: 0xff3300,  // Add glow effect
                    emissiveIntensity: 0.3
                });
                
                const wearVolumeMesh = new THREE.Mesh(wearVolumeGeom, wearVolumeMat);
                sphereScene.add(wearVolumeMesh);
                
                console.log(`Wear volume visualization added to sphere viewer: ${vertexCount} vertices`);
            }
            
            // === VOLUMETRIC VIEWER (Third Viewer): Show TRUE 3D VOLUMETRIC WEAR ===
            // Creates triangular prisms from worn surface to reference sphere
            // This represents the exact volume calculated as wear
            console.log('=== Populating Volumetric Wear Viewer (Third Viewer - TRUE 3D VOLUME) ===');
            
            // Clear volumetric viewer first
            while (volumetricScene.children.length > 0) {
                volumetricScene.remove(volumetricScene.children[0]);
            }
            // Re-add lights
            const volAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            const volDirectional = new THREE.DirectionalLight(0xffffff, 0.8);
            volDirectional.position.set(50, 50, 50);
            const volDirectional2 = new THREE.DirectionalLight(0xffffff, 0.4);
            volDirectional2.position.set(-50, -30, -50);
            volumetricScene.add(volAmbient);
            volumetricScene.add(volDirectional);
            volumetricScene.add(volDirectional2);
            
            // Add original STL completely transparent (light blue/gray)
            const transparentGeometry = state.geometry.clone();
            const transparentMaterial = new THREE.MeshPhongMaterial({
                color: 0x4299e1,  // Light blue like original component
                transparent: true,
                opacity: 0.12,  // Very transparent
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const transparentMesh = new THREE.Mesh(transparentGeometry, transparentMaterial);
            transparentMesh.renderOrder = 0;
            volumetricScene.add(transparentMesh);
            console.log('Added transparent STL to volumetric viewer');
            
            // CREATE TRUE 3D VOLUMETRIC WEAR MESH
            // For each worn surface triangle, create a triangular prism extending to the reference sphere
            // This represents the exact volume that was calculated
            if (state.processedWearTriangles.length > 0) {
                console.log(`Creating 3D volumetric prisms for ${state.processedWearTriangles.length} wear triangles...`);
                
                const volumePrismPositions = [];
                const volumePrismIndices = [];
                let prismVertexCount = 0;
                
                for (const tri of state.processedWearTriangles) {
                    // Worn surface triangle vertices (bottom of prism)
                    const p1 = tri.p1;
                    const p2 = tri.p2;
                    const p3 = tri.p3;
                    
                    // Project each vertex onto the reference sphere (top of prism)
                    // Direction from sphere center to vertex, then place at sphere radius
                    const dir1 = new THREE.Vector3().subVectors(p1, sphereCenter).normalize();
                    const dir2 = new THREE.Vector3().subVectors(p2, sphereCenter).normalize();
                    const dir3 = new THREE.Vector3().subVectors(p3, sphereCenter).normalize();
                    
                    const s1 = sphereCenter.clone().add(dir1.multiplyScalar(sphereRadius));
                    const s2 = sphereCenter.clone().add(dir2.multiplyScalar(sphereRadius));
                    const s3 = sphereCenter.clone().add(dir3.multiplyScalar(sphereRadius));
                    
                    // Build triangular prism with 5 faces:
                    // - Bottom face (worn surface): p1, p2, p3
                    // - Top face (sphere surface): s1, s2, s3
                    // - 3 side faces connecting them
                    
                    // Add all 6 vertices for this prism
                    const baseIdx = prismVertexCount;
                    
                    // Vertices: 0=p1, 1=p2, 2=p3, 3=s1, 4=s2, 5=s3
                    volumePrismPositions.push(p1.x, p1.y, p1.z);  // 0: p1 (bottom)
                    volumePrismPositions.push(p2.x, p2.y, p2.z);  // 1: p2 (bottom)
                    volumePrismPositions.push(p3.x, p3.y, p3.z);  // 2: p3 (bottom)
                    volumePrismPositions.push(s1.x, s1.y, s1.z);  // 3: s1 (top)
                    volumePrismPositions.push(s2.x, s2.y, s2.z);  // 4: s2 (top)
                    volumePrismPositions.push(s3.x, s3.y, s3.z);  // 5: s3 (top)
                    
                    // Bottom face (worn surface) - facing outward (away from center)
                    volumePrismIndices.push(baseIdx + 0, baseIdx + 2, baseIdx + 1);
                    
                    // Top face (sphere surface) - facing inward (toward center)
                    volumePrismIndices.push(baseIdx + 3, baseIdx + 4, baseIdx + 5);
                    
                    // Side face 1: p1-p2 to s1-s2 (quad as 2 triangles)
                    volumePrismIndices.push(baseIdx + 0, baseIdx + 1, baseIdx + 4);
                    volumePrismIndices.push(baseIdx + 0, baseIdx + 4, baseIdx + 3);
                    
                    // Side face 2: p2-p3 to s2-s3 (quad as 2 triangles)
                    volumePrismIndices.push(baseIdx + 1, baseIdx + 2, baseIdx + 5);
                    volumePrismIndices.push(baseIdx + 1, baseIdx + 5, baseIdx + 4);
                    
                    // Side face 3: p3-p1 to s3-s1 (quad as 2 triangles)
                    volumePrismIndices.push(baseIdx + 2, baseIdx + 0, baseIdx + 3);
                    volumePrismIndices.push(baseIdx + 2, baseIdx + 3, baseIdx + 5);
                    
                    prismVertexCount += 6;
                }
                
                console.log(`Created ${prismVertexCount / 6} volumetric prisms with ${volumePrismIndices.length / 3} triangular faces`);
                
                // Create the volumetric wear mesh
                const volWearGeom = new THREE.BufferGeometry();
                volWearGeom.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(volumePrismPositions), 3));
                volWearGeom.setIndex(volumePrismIndices);
                volWearGeom.computeVertexNormals();
                
                // Solid orange material for the volumetric wear (40% transparency = 60% opacity)
                const volWearMat = new THREE.MeshPhongMaterial({
                    color: 0xff6600,  // Bright orange
                    transparent: true,
                    opacity: 0.6,     // 40% transparency
                    side: THREE.DoubleSide,
                    shininess: 30,
                    depthWrite: false  // Better transparency blending
                });
                
                const volWearMesh = new THREE.Mesh(volWearGeom, volWearMat);
                volWearMesh.renderOrder = 1;
                volumetricScene.add(volWearMesh);
                
                // Also add wireframe overlay for better volume perception
                const wireframeMat = new THREE.MeshBasicMaterial({
                    color: 0xff9900,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const wireframeMesh = new THREE.Mesh(volWearGeom.clone(), wireframeMat);
                wireframeMesh.renderOrder = 2;
                volumetricScene.add(wireframeMesh);
                
                console.log(`Added TRUE 3D volumetric wear mesh: ${prismVertexCount} vertices, ${volumePrismIndices.length / 3} faces`);
                console.log(`This visualization represents EXACTLY the ${volumetricWear.toFixed(4)} mm³ calculated wear volume`);
            } else {
                console.log('No wear volume triangles to display in volumetric viewer');
            }
            
            // Force proper transparency rendering
            volumetricRenderer.sortObjects = true;
            
            // Hide loading overlay for volumetric viewer
            document.getElementById('volumetric-loading-overlay').classList.add('hidden');
            
            // Center camera on the mesh
            const volBox = new THREE.Box3().setFromObject(transparentMesh);
            const volCenter = volBox.getCenter(new THREE.Vector3());
            volumetricControls.target.copy(volCenter);
            volumetricCamera.position.set(
                volCenter.x + 50,
                volCenter.y + 50,
                volCenter.z + 50
            );
            volumetricControls.update();
            
            console.log(`Volumetric Viewer ready: Transparent STL + TRUE 3D volumetric wear representation`);
            // END VOLUMETRIC VIEWER
            
            // VISUALIZATION: Add maximum linear wear line (from sphere surface to deepest worn point)
            // First, clean up any existing max wear line objects from previous runs
            if (state.maxWearLineObjects.length > 0) {
                state.maxWearLineObjects.forEach(obj => {
                    sphereScene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                state.maxWearLineObjects = [];
                console.log('Cleaned up previous max wear line visualization objects');
            }
            
            if (maxPenetrationVertex && maxPenetration > 0) {
                console.log('=== Adding maximum linear wear visualization ===');
                
                // Calculate the point on the fitted sphere surface (accurate radial projection)
                // Direction from sphere center to the deepest worn point
                const directionToVertex = new THREE.Vector3().subVectors(maxPenetrationVertex, state.unwornSphere.center);
                const normalizedDirection = directionToVertex.normalize();
                
                // Project onto fitted sphere surface using the unworn sphere's center and radius
                const sphereSurfacePoint = state.unwornSphere.center.clone().add(
                    normalizedDirection.clone().multiplyScalar(state.unwornSphere.radius)
                );
                
                // Create line geometry from sphere surface to worn surface
                const lineGeometry = new THREE.BufferGeometry();
                const linePositions = new Float32Array([
                    sphereSurfacePoint.x, sphereSurfacePoint.y, sphereSurfacePoint.z,
                    maxPenetrationVertex.x, maxPenetrationVertex.y, maxPenetrationVertex.z
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
                
                // Create bright cyan/magenta line material for high contrast
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,  // Bright magenta/purple for maximum visibility
                    linewidth: 5,  // Increased thickness for better visibility
                    opacity: 1.0,
                    transparent: false
                });
                
                const maxWearLine = new THREE.Line(lineGeometry, lineMaterial);
                sphereScene.add(maxWearLine);
                state.maxWearLineObjects.push(maxWearLine);  // Track for cleanup
                
                // Add sphere marker at the worn surface point (deepest point)
                // REDUCED SIZE: Much finer markers for sub-millimeter measurements (0.1-0.2mm typical)
                const wornPointMarkerGeom = new THREE.SphereGeometry(0.15, 12, 12);  // Reduced from 0.6 to 0.15
                const wornPointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,  // Match line color
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.6
                });
                const wornPointMarker = new THREE.Mesh(wornPointMarkerGeom, wornPointMarkerMat);
                wornPointMarker.position.copy(maxPenetrationVertex);
                sphereScene.add(wornPointMarker);
                state.maxWearLineObjects.push(wornPointMarker);  // Track for cleanup
                
                // Add sphere marker at the fitted sphere surface point (start of measurement)
                const spherePointMarkerGeom = new THREE.SphereGeometry(0.12, 12, 12);  // Reduced from 0.5 to 0.12
                const spherePointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,  // Bright cyan for distinction
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.6
                });
                const spherePointMarker = new THREE.Mesh(spherePointMarkerGeom, spherePointMarkerMat);
                spherePointMarker.position.copy(sphereSurfacePoint);
                sphereScene.add(spherePointMarker);
                state.maxWearLineObjects.push(spherePointMarker);  // Track for cleanup
                
                console.log(`Maximum linear wear line added:`);
                console.log(`  From fitted sphere surface: (${sphereSurfacePoint.x.toFixed(3)}, ${sphereSurfacePoint.y.toFixed(3)}, ${sphereSurfacePoint.z.toFixed(3)})`);
                console.log(`  To deepest worn point: (${maxPenetrationVertex.x.toFixed(3)}, ${maxPenetrationVertex.y.toFixed(3)}, ${maxPenetrationVertex.z.toFixed(3)})`);
                console.log(`  Penetration distance: ${maxPenetration.toFixed(4)} mm`);
                console.log(`  Line color: Bright magenta/purple | Markers: Magenta (worn) + Cyan (sphere)`);
            } else {
                console.log('No positive penetration detected, skipping maximum linear wear visualization');
                // Ensure array is cleared to avoid memory leaks when no new line is created
                state.maxWearLineObjects = [];
            }
            
            state.wearData = {
                volumetricWear: Math.max(0, volumetricWear),
                volumePlaneToSurface,
                sphericalCapVolume,
                linearWearMean: meanPenetration,
                linearWearMax: maxPenetration,
                linearWearMin: minPenetration,
                unwornSphereCenter: state.unwornSphere.center,
                unwornSphereRadius: state.unwornSphere.radius,
                transitionPlaneNormal: state.transitionPlane.normal,
                transitionPlaneD: state.transitionPlane.d,
                wornArea,
                unwornArea
            };
            
            // Update UI
            document.getElementById('metric-volume').textContent = volumetricWear.toFixed(4) + ' mm³';
            document.getElementById('metric-linear-mean').textContent = meanPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-max').textContent = maxPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-min').textContent = minPenetration.toFixed(4) + ' mm';
            
            // Show detection method used
            const methodName = state.detectionMethod === 'dual-sphere' ? 'Dual Sphere (normal convergence)' : 'Hemisphere (axis dispersion)';
            document.getElementById('detection-method-used').textContent = methodName;
            
            document.getElementById('sphere-center').textContent = 
                `(${state.unwornSphere.center.x.toFixed(2)}, ${state.unwornSphere.center.y.toFixed(2)}, ${state.unwornSphere.center.z.toFixed(2)}) mm`;
            document.getElementById('sphere-radius').textContent = 
                `${state.unwornSphere.radius.toFixed(4)} mm`;
            
            // Show worn sphere info if dual-sphere mode
            if (state.wornSphere && state.detectionMethod === 'dual-sphere') {
                document.getElementById('worn-sphere-info').classList.remove('hidden');
                document.getElementById('worn-sphere-radius-info').classList.remove('hidden');
                document.getElementById('center-distance-info').classList.remove('hidden');
                document.getElementById('worn-sphere-center').textContent = 
                    `(${state.wornSphere.center.x.toFixed(2)}, ${state.wornSphere.center.y.toFixed(2)}, ${state.wornSphere.center.z.toFixed(2)}) mm`;
                document.getElementById('worn-sphere-radius').textContent = 
                    `${state.wornSphere.radius.toFixed(4)} mm`;
                document.getElementById('center-distance').textContent = 
                    `${state.centerDistance.toFixed(4)} mm`;
            } else {
                document.getElementById('worn-sphere-info').classList.add('hidden');
                document.getElementById('worn-sphere-radius-info').classList.add('hidden');
                document.getElementById('center-distance-info').classList.add('hidden');
            }
            
            document.getElementById('worn-area').textContent = wornArea.toFixed(2) + ' mm²';
            document.getElementById('unworn-area').textContent = unwornArea.toFixed(2) + ' mm²';
            
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('results-data').classList.remove('hidden');
            
            // DIAGNOSTIC: Show alert if results are zero
            if (volumetricWear === 0 && meanPenetration === 0) {
                console.warn('⚠️ RESULTADOS EN CERO - DIAGNÓSTICO:');
                console.warn(`  - Vértices desgastados detectados: ${state.wornVertices.length}`);
                console.warn(`  - Vértices no desgastados detectados: ${state.unwornVertices.length}`);
                console.warn(`  - Triángulos procesados: ${wornTriangleCount}`);
                console.warn(`  - Triángulos recortados generados: ${totalClippedTriangles}`);
                console.warn(`  - Radio de esfera: ${state.unwornSphere.radius.toFixed(4)} mm`);
                console.warn(`  - Vértices desgastados filtrados (dentro del plano): ${filteredWornCount}`);
                
                let diagnosticMsg = '⚠️ RESULTADOS EN CERO - Posibles causas:\n\n';
                
                if (state.wornVertices.length === 0) {
                    diagnosticMsg += '❌ NO SE DETECTARON ZONAS DESGASTADAS\n';
                    diagnosticMsg += '   El algoritmo de curvatura no encontró desgaste.\n';
                    diagnosticMsg += '   → Posible solución: Verificar que el archivo STL tenga desgaste real.\n\n';
                } else if (wornTriangleCount === 0) {
                    diagnosticMsg += '❌ TRIÁNGULOS DESGASTADOS EXCLUIDOS POR EL PLANO\n';
                    diagnosticMsg += '   El plano de transición está cortando todos los triángulos.\n';
                    diagnosticMsg += '   → Revisar la orientación del plano en la consola.\n\n';
                } else if (filteredWornCount === 0) {
                    diagnosticMsg += '❌ VÉRTICES DESGASTADOS FUERA DEL MARCO DEL PLANO\n';
                    diagnosticMsg += '   Todos los vértices están del lado equivocado del plano.\n';
                    diagnosticMsg += '   → Posible error en cálculo del plano de transición.\n\n';
                } else {
                    diagnosticMsg += '❌ PENETRACIÓN NEGATIVA O CERO\n';
                    diagnosticMsg += '   La esfera de referencia está mal ajustada.\n';
                    diagnosticMsg += '   → Intentar con otro método de ajuste (RANSAC vs Gauss-Newton).\n\n';
                }
                
                diagnosticMsg += 'Ver consola del navegador (F12) para más detalles.';
                alert(diagnosticMsg);
            }
            
            updateStatus('complete', 'Wear calculation complete');
            showLoading(false);
        });

        // Export CSV
        document.getElementById('btn-export-csv').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            const data = state.wearData;
            const csv = [
                'Metric,Value,Unit',
                `Volumetric Wear (plane-surface minus spherical-cap),${data.volumetricWear.toFixed(6)},mm³`,
                `Volume Plane to Surface,${data.volumePlaneToSurface.toFixed(6)},mm³`,
                `Volume Spherical Cap,${data.sphericalCapVolume.toFixed(6)},mm³`,
                `Linear Wear Mean Penetration,${data.linearWearMean.toFixed(6)},mm`,
                `Linear Wear Max Penetration,${data.linearWearMax.toFixed(6)},mm`,
                `Linear Wear Min Penetration,${data.linearWearMin.toFixed(6)},mm`,
                `Unworn Sphere Center X,${data.unwornSphereCenter.x.toFixed(6)},mm`,
                `Unworn Sphere Center Y,${data.unwornSphereCenter.y.toFixed(6)},mm`,
                `Unworn Sphere Center Z,${data.unwornSphereCenter.z.toFixed(6)},mm`,
                `Unworn Sphere Radius (Commercial),${data.unwornSphereRadius.toFixed(6)},mm`,
                `Unworn Sphere Radius (Raw Fitted),${(state.unwornSphere.rawRadius || data.unwornSphereRadius).toFixed(6)},mm`,
                `Commercial Radius Selection,${state.unwornSphere.commercialRadius || 'N/A'},mm`,
                `Transition Plane Normal X,${data.transitionPlaneNormal.x.toFixed(6)},-`,
                `Transition Plane Normal Y,${data.transitionPlaneNormal.y.toFixed(6)},-`,
                `Transition Plane Normal Z,${data.transitionPlaneNormal.z.toFixed(6)},-`,
                `Transition Plane D,${data.transitionPlaneD.toFixed(6)},mm`,
                `Worn Zone Area,${data.wornArea.toFixed(4)},mm²`,
                `Unworn Zone Area,${data.unwornArea.toFixed(4)},mm²`
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acetabular_wear_analysis.csv';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Export JSON with full metadata
        document.getElementById('btn-export-json').addEventListener('click', () => {
            if (!state.wearData || !state.fittingDiagnostics) {
                alert('Please complete analysis first');
                return;
            }
            
            const data = state.wearData;
            const diag = state.fittingDiagnostics;
            
            // Build comprehensive JSON export
            const exportData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    systemVersion: '2.0-Enhanced',
                    analysisMethod: 'Gaussian Curvature + PCA + ' + diag.method
                },
                wearMetrics: {
                    volumetric: {
                        total: data.volumetricWear,
                        planeToSurface: data.volumePlaneToSurface,
                        sphericalCap: data.sphericalCapVolume,
                        unit: 'mm³'
                    },
                    linear: {
                        mean: data.linearWearMean,
                        max: data.linearWearMax,
                        min: data.linearWearMin,
                        unit: 'mm'
                    }
                },
                unwornSphere: {
                    center: {
                        x: data.unwornSphereCenter.x,
                        y: data.unwornSphereCenter.y,
                        z: data.unwornSphereCenter.z
                    },
                    radius: data.unwornSphereRadius,
                    rawRadius: state.unwornSphere.rawRadius || data.unwornSphereRadius,
                    commercialRadius: state.unwornSphere.commercialRadius || null,
                    unit: 'mm'
                },
                transitionPlane: {
                    normal: {
                        x: data.transitionPlaneNormal.x,
                        y: data.transitionPlaneNormal.y,
                        z: data.transitionPlaneNormal.z
                    },
                    d: data.transitionPlaneD,
                    method: 'PCA (Principal Component Analysis)',
                    unit: 'mm'
                },
                zoneAreas: {
                    worn: data.wornArea,
                    unworn: data.unwornArea,
                    unit: 'mm²'
                },
                fittingDiagnostics: {
                    method: diag.method,
                    iterations: diag.iterations,
                    rmsError: diag.rmsError,
                    inlierCount: diag.inliers,
                    totalPoints: state.unwornVertices.length,
                    inlierRatio: diag.inliers / state.unwornVertices.length,
                    residualStatistics: {
                        min: diag.residuals.reduce((min, val) => val < min ? val : min, Infinity),
                        max: diag.residuals.reduce((max, val) => val > max ? val : max, -Infinity),
                        mean: diag.residuals.reduce((a, b) => a + b, 0) / diag.residuals.length,
                        unit: 'mm'
                    }
                },
                curvatureAnalysis: {
                    method: 'Meyer et al. 2003 Gaussian Curvature',
                    rimExclusion: true,
                    combinedScoring: 'Curvature + Radial Deviation'
                },
                inflectionPoints: {
                    count: state.inflectionPoints.length,
                    visualized: state.inflectionMarkers.length
                }
            };
            
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `acetabular_wear_analysis_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('JSON export completed with full metadata');
        });

        // Export PDF Report
        document.getElementById('btn-export-pdf').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const data = state.wearData;
            const diag = state.fittingDiagnostics;
            
            // Title
            doc.setFontSize(20);
            doc.setTextColor(102, 126, 234);
            doc.text('Acetabular Wear Analysis Report', 105, 20, { align: 'center' });
            
            // Date
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text(`Generated: ${new Date().toLocaleString()}`, 105, 28, { align: 'center' });
            
            // Section 1: Wear Metrics
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('Wear Metrics', 20, 45);
            doc.setFontSize(10);
            let y = 55;
            doc.text(`Volumetric Wear: ${data.volumetricWear.toFixed(4)} mm³`, 25, y);
            y += 8;
            doc.text(`Mean Linear Wear: ${data.linearWearMean.toFixed(4)} mm`, 25, y);
            y += 6;
            doc.text(`Maximum Penetration: ${data.linearWearMax.toFixed(4)} mm`, 25, y);
            y += 6;
            doc.text(`Minimum Penetration: ${data.linearWearMin.toFixed(4)} mm`, 25, y);
            
            // Section 2: Sphere Parameters
            y += 15;
            doc.setFontSize(14);
            doc.text('Unworn Sphere Parameters', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Center: (${data.unwornSphereCenter.x.toFixed(2)}, ${data.unwornSphereCenter.y.toFixed(2)}, ${data.unwornSphereCenter.z.toFixed(2)}) mm`, 25, y);
            y += 6;
            doc.text(`Radius: ${data.unwornSphereRadius.toFixed(4)} mm`, 25, y);
            
            // Section 3: Fitting Quality
            if (diag) {
                y += 15;
                doc.setFontSize(14);
                doc.text('Fitting Quality Diagnostics', 20, y);
                doc.setFontSize(10);
                y += 10;
                doc.text(`Method: ${diag.method}`, 25, y);
                y += 6;
                doc.text(`RMS Error: ${diag.rmsError.toFixed(6)} mm`, 25, y);
                y += 6;
                doc.text(`Iterations: ${diag.iterations}`, 25, y);
                y += 6;
                doc.text(`Inliers: ${diag.inliers} / ${state.unwornVertices.length} (${((diag.inliers / state.unwornVertices.length) * 100).toFixed(1)}%)`, 25, y);
            }
            
            // Section 4: Zone Areas
            y += 15;
            doc.setFontSize(14);
            doc.text('Zone Areas', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Worn Zone: ${data.wornArea.toFixed(2)} mm²`, 25, y);
            y += 6;
            doc.text(`Unworn Zone: ${data.unwornArea.toFixed(2)} mm²`, 25, y);
            
            // Section 5: Transition Plane
            y += 15;
            doc.setFontSize(14);
            doc.text('Transition Plane', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Normal: (${data.transitionPlaneNormal.x.toFixed(4)}, ${data.transitionPlaneNormal.y.toFixed(4)}, ${data.transitionPlaneNormal.z.toFixed(4)})`, 25, y);
            y += 6;
            doc.text(`D coefficient: ${data.transitionPlaneD.toFixed(4)}`, 25, y);
            
            // Footer
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text('Acetabular Wear Analysis System v2.4', 105, 285, { align: 'center' });
            
            // Save
            doc.save(`acetabular_wear_report_${new Date().toISOString().split('T')[0]}.pdf`);
            console.log('PDF report generated successfully');
        });

        // Download Sphere Visualization Elements
        document.getElementById('btn-download-sphere-view').addEventListener('click', () => {
            if (!state.unwornSphere || !state.transitionPlane) {
                alert('Please complete sphere fitting first');
                return;
            }
            
            // Helper function to convert geometry to STL string
            function geometryToSTL(geometry, name = 'model') {
                const positions = geometry.attributes.position.array;
                let stl = `solid ${name}\n`;
                
                for (let i = 0; i < positions.length; i += 9) {
                    const v1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                    const v2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                    const v3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                    
                    const e1 = new THREE.Vector3().subVectors(v2, v1);
                    const e2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(e1, e2).normalize();
                    
                    stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                }
                
                stl += `endsolid ${name}\n`;
                return stl;
            }
            
            // Helper function to download text file
            function downloadFile(content, filename, type = 'text/plain') {
                const blob = new Blob([content], { type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            // 1. Export original STL (inner surface)
            if (state.geometry) {
                const stlContent = geometryToSTL(state.geometry, 'inner_surface');
                downloadFile(stlContent, 'inner_surface.stl');
            }
            
            // 2. Export fitted sphere as STL
            const sphereGeom = new THREE.SphereGeometry(state.unwornSphere.radius, 64, 64);
            sphereGeom.translate(state.unwornSphere.center.x, state.unwornSphere.center.y, state.unwornSphere.center.z);
            const sphereStl = geometryToSTL(sphereGeom, 'fitted_sphere');
            downloadFile(sphereStl, 'fitted_sphere.stl');
            
            // 3. Export transition plane as STL
            const planeSize = state.unwornSphere.radius * 4;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
            planeGeom.translate(state.transitionPlane.point.x, state.transitionPlane.point.y, state.transitionPlane.point.z);
            
            // Orient plane
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, state.transitionPlane.normal);
            planeGeom.applyQuaternion(quaternion);
            
            const planeStl = geometryToSTL(planeGeom, 'transition_plane');
            downloadFile(planeStl, 'transition_plane.stl');
            
            // 4. Export inflection points as CSV
            if (state.inflectionPoints && state.inflectionPoints.length > 0) {
                let csvContent = 'X,Y,Z\n';
                state.inflectionPoints.forEach(p => {
                    csvContent += `${p.x},${p.y},${p.z}\n`;
                });
                downloadFile(csvContent, 'inflection_points.csv', 'text/csv');
            }
            
            // 5. Export metadata as JSON
            const metadata = {
                unwornSphere: {
                    center: { x: state.unwornSphere.center.x, y: state.unwornSphere.center.y, z: state.unwornSphere.center.z },
                    radius: state.unwornSphere.radius
                },
                transitionPlane: {
                    normal: { x: state.transitionPlane.normal.x, y: state.transitionPlane.normal.y, z: state.transitionPlane.normal.z },
                    point: { x: state.transitionPlane.point.x, y: state.transitionPlane.point.y, z: state.transitionPlane.point.z },
                    d: state.transitionPlane.d
                },
                inflectionPointsCount: state.inflectionPoints.length,
                exportDate: new Date().toISOString()
            };
            downloadFile(JSON.stringify(metadata, null, 2), 'sphere_view_metadata.json', 'application/json');
            
            alert('5 files downloaded:\n- inner_surface.stl\n- fitted_sphere.stl\n- transition_plane.stl\n- inflection_points.csv\n- sphere_view_metadata.json');
        });

        // Export Interactive HTML
        document.getElementById('btn-export-html').addEventListener('click', () => {
            if (!state.unwornSphere || !state.transitionPlane || !state.wearData) {
                alert('Please complete analysis first (all 4 steps)');
                return;
            }
            
            // Capture current sphere scene data
            const sceneData = {
                geometry: state.geometry ? state.geometry.clone() : null,
                unwornSphere: state.unwornSphere,
                transitionPlane: state.transitionPlane,
                wearData: state.wearData,
                wornVertices: state.wornVertices,
                unwornVertices: state.unwornVertices,
                inflectionPoints: state.inflectionPoints || []
            };
            
            // Helper to serialize geometry to JSON
            function serializeGeometry(geom) {
                if (!geom) return null;
                return {
                    positions: Array.from(geom.attributes.position.array),
                    indices: geom.index ? Array.from(geom.index.array) : null,
                    colors: geom.attributes.color ? Array.from(geom.attributes.color.array) : null
                };
            }
            
            const geometryData = serializeGeometry(sceneData.geometry);
            
            // Pre-calculate wear metrics for embedding in HTML
            const volumetricWear = sceneData.wearData.volumetricWear.toFixed(4);
            const linearWearMean = sceneData.wearData.linearWearMean.toFixed(4);
            const linearWearMax = sceneData.wearData.linearWearMax.toFixed(4);
            const sphereRadius = sceneData.unwornSphere.radius.toFixed(4);
            const wornArea = sceneData.wearData.wornArea.toFixed(2);
            const unwornArea = sceneData.wearData.unwornArea.toFixed(2);
            
            // Create standalone HTML document with embedded data
            const dataJSON = JSON.stringify({
                geometryData,
                unwornSphere: sceneData.unwornSphere,
                transitionPlane: sceneData.transitionPlane,
                inflectionPoints: sceneData.inflectionPoints.map(p => ({x: p.x, y: p.y, z: p.z}))
            });
            
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acetabular Wear Analysis - 3D Visualization</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    <\/script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: white;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: #1e293b;
            max-width: 350px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #667eea;
        }
        .metric {
            margin: 8px 0;
            font-size: 13px;
        }
        .metric strong {
            color: #667eea;
        }
        .controls-hint {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
            font-size: 11px;
            color: #64748b;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info-panel">
        <h1>🔬 Wear Analysis Results</h1>
        <div class="metric"><strong>Volumetric Wear:</strong> ${volumetricWear} mm³</div>
        <div class="metric"><strong>Mean Linear Wear:</strong> ${linearWearMean} mm</div>
        <div class="metric"><strong>Max Penetration:</strong> ${linearWearMax} mm</div>
        <div class="metric"><strong>Sphere Radius:</strong> ${sphereRadius} mm</div>
        <div class="metric"><strong>Worn Area:</strong> ${wornArea} mm²</div>
        <div class="metric"><strong>Unworn Area:</strong> ${unwornArea} mm²</div>
        <div class="controls-hint">
            <strong>Controls:</strong><br>
            Left click + drag: Rotate<br>
            Right click + drag: Pan<br>
            Scroll: Zoom
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const sceneData = ${dataJSON};
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e293b);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 30, 30);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // Reconstruct geometry from data
        if (sceneData.geometryData && sceneData.geometryData.positions) {
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(sceneData.geometryData.positions), 3));
            if (sceneData.geometryData.indices) {
                geom.setIndex(new THREE.BufferAttribute(new Uint32Array(sceneData.geometryData.indices), 1));
            }
            if (sceneData.geometryData.colors) {
                geom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(sceneData.geometryData.colors), 3));
            }
            geom.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: sceneData.geometryData.colors ? true : false,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            const mesh = new THREE.Mesh(geom, material);
            scene.add(mesh);
        }
        
        // Add fitted sphere (wireframe)
        const sphereGeom = new THREE.SphereGeometry(sceneData.unwornSphere.radius, 64, 64);
        const sphereMat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            wireframe: true,
            transparent: true,
            opacity: 0.4
        });
        const sphereMesh = new THREE.Mesh(sphereGeom, sphereMat);
        sphereMesh.position.set(
            sceneData.unwornSphere.center.x,
            sceneData.unwornSphere.center.y,
            sceneData.unwornSphere.center.z
        );
        scene.add(sphereMesh);
        
        // Add transition plane
        const planeSize = sceneData.unwornSphere.radius * 4;
        const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
        const planeMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const planeMesh = new THREE.Mesh(planeGeom, planeMat);
        planeMesh.position.set(
            sceneData.transitionPlane.point.x,
            sceneData.transitionPlane.point.y,
            sceneData.transitionPlane.point.z
        );
        const up = new THREE.Vector3(0, 0, 1);
        const normal = new THREE.Vector3(
            sceneData.transitionPlane.normal.x,
            sceneData.transitionPlane.normal.y,
            sceneData.transitionPlane.normal.z
        );
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal);
        planeMesh.applyQuaternion(quaternion);
        scene.add(planeMesh);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    <\/script>
</body>
</html>`;
            
            // Download HTML file
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acetabular_wear_3d_' + new Date().toISOString().split('T')[0] + '.html';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('Interactive HTML exported successfully');
            alert('Interactive HTML file downloaded!\\n\\nOpen it in any browser to view the 3D visualization with orbit controls.');
        });
    </script>
</body>
</html>
