<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acetabular Wear Analysis System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.05), transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(124, 58, 237, 0.05), transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(59, 130, 246, 0.05), transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            max-width: 1920px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        #viewer-container {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #sphere-viewer-container {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel {
            background: #ffffff;
            border-radius: 20px;
            padding: 28px;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(226, 232, 240, 0.8);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 30px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 
                0 10px 30px rgba(102, 126, 234, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
        }
        
        .metric-card:hover::before {
            opacity: 1;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 15px rgba(102, 126, 234, 0.4),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }
        
        .btn-primary:hover::before {
            left: 100%;
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            padding: 14px 28px;
            border-radius: 12px;
            border: 2px solid #667eea;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }
        
        .btn-secondary:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px currentColor;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .status-ready { background: #48bb78; box-shadow: 0 0 15px #48bb78; }
        .status-processing { background: #ed8936; box-shadow: 0 0 15px #ed8936; }
        .status-complete { background: #4299e1; box-shadow: 0 0 15px #4299e1; }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            background: rgba(102, 126, 234, 0.05);
            transform: translateX(4px);
        }
        
        .legend-color {
            width: 36px;
            height: 24px;
            border-radius: 6px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .loading-overlay::after {
            content: '';
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .hidden { display: none; }
        
        h1 {
            color: #0f172a;
            font-weight: 800;
        }
        
        h2 {
            color: #1e293b;
            font-weight: 700;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        input[type="file"] {
            padding: 12px;
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            transition: all 0.3s ease;
            background: #f8fafc;
            color: #475569;
        }
        
        input[type="file"]:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }
        
        p {
            color: #64748b;
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-6">
        <!-- Header -->
        <div class="panel mb-6 fade-in">
            <div class="flex items-center gap-4 mb-3">
                <svg class="w-12 h-12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" fill="url(#grad1)"/>
                    <circle cx="12" cy="12" r="4" fill="url(#grad1)" opacity="0.6"/>
                </svg>
                <div>
                    <h1 class="text-4xl font-bold mb-1">Acetabular Wear Analysis System</h1>
                    <p class="text-lg" style="color: #64748b;">Professional volumetric and linear wear measurement for hip prosthesis components</p>
                </div>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Panel: Controls -->
            <div class="lg:col-span-1">
                <div class="panel mb-6 fade-in" style="animation-delay: 0.1s;">
                    <h2 class="text-2xl font-bold mb-4">
                        <span class="flex items-center gap-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <defs>
                                    <linearGradient id="grad2" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <path stroke="url(#grad2)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            File Upload
                        </span>
                    </h2>
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2" style="color: #475569;">
                            Upload STL File
                        </label>
                        <input type="file" id="file-input" accept=".stl" class="w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                    <div class="text-sm mb-4 flex items-center" style="color: #64748b;">
                        <span class="status-indicator status-ready" id="status-indicator"></span>
                        <span id="status-text">Ready to load file</span>
                    </div>
                </div>

                <div class="panel mb-6 fade-in" style="animation-delay: 0.2s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Pipeline</h2>
                    <div class="space-y-3">
                        <button id="btn-isolate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                            </svg>
                            <span>1. Isolate Inner Surface</span>
                        </button>
                        <button id="btn-detect-wear" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                            </svg>
                            <span>2. Detect Wear Zones</span>
                        </button>
                        <button id="btn-fit-sphere" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                            </svg>
                            <span>3. Fit Reference Sphere</span>
                        </button>
                        <button id="btn-calculate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                            </svg>
                            <span>4. Calculate Wear</span>
                        </button>
                    </div>
                </div>

                <div class="panel fade-in" style="animation-delay: 0.3s;">
                    <h2 class="text-2xl font-bold mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <defs>
                                <linearGradient id="grad3" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <path stroke="url(#grad3)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                        </svg>
                        Legend
                    </h2>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4299e1;"></div>
                        <span>Original Component</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span><strong>Unworn Zone</strong> (furthest from prosthesis)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f56565;"></div>
                        <span><strong>Worn Zone</strong> (closest to prosthesis)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255, 215, 0, 0.5); border: 2px solid rgba(255, 215, 0, 0.8);"></div>
                        <span>Fitted Reference Sphere</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6600;"></div>
                        <span><strong>Volumetric Wear Zone</strong> (orange highlight)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ffff 0%, #ff00ff 50%, #ff00ff 100%);"></div>
                        <span><strong>Max Linear Wear</strong> (cyan→magenta line)</span>
                    </div>
                    <div class="mt-4 p-4 rounded-xl text-sm" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(124, 58, 237, 0.08) 100%); border: 1px solid rgba(102, 126, 234, 0.15); color: #475569;">
                        <p class="font-semibold mb-2 flex items-center gap-2">
                            <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            Important:
                        </p>
                        <p class="mb-1"><strong class="text-red-600">Worn zone</strong> = inner surface closest to femoral head (where contact occurs)</p>
                        <p class="mb-1"><strong class="text-green-600">Unworn zone</strong> = outer edges furthest from contact point</p>
                        <p class="text-xs mt-2" style="color: #64748b;"><strong>Sphere Viewer:</strong> Orange area shows volumetric wear volume. Cyan-to-magenta line marks maximum penetration depth with fine markers.</p>
                    </div>
                </div>
            </div>

            <!-- Middle/Right Panel: 3D Viewers -->
            <div class="lg:col-span-2">
                <!-- Main Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.4s;">
                    <h2 class="text-2xl font-bold mb-4">3D Model Viewer</h2>
                    <div id="viewer-container">
                        <div id="loading-overlay" class="loading-overlay hidden">
                            <div>Processing...</div>
                        </div>
                    </div>
                    <div class="mt-4 text-sm" style="color: #64748b;">
                        <p><strong style="color: #475569;">Controls:</strong> Left click + drag to rotate | Right click + drag to pan | Scroll to zoom</p>
                    </div>
                </div>

                <!-- Sphere Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.5s;">
                    <h2 class="text-2xl font-bold mb-4">Reference Sphere Visualization</h2>
                    <div id="sphere-viewer-container">
                        <div id="sphere-loading-overlay" class="loading-overlay">
                            <div>Waiting for analysis...</div>
                        </div>
                    </div>
                </div>

                <!-- Results Panel -->
                <div class="panel fade-in" style="animation-delay: 0.6s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Results</h2>
                    <div id="results-container">
                        <div class="text-center py-8" style="color: #94a3b8;">
                            No analysis completed yet. Upload an STL file and run the analysis pipeline.
                        </div>
                    </div>
                    <div id="results-data" class="hidden">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Volumetric Wear</div>
                                <div class="text-3xl font-bold" id="metric-volume">0.00 mm³</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Mean Linear Wear</div>
                                <div class="text-3xl font-bold" id="metric-linear-mean">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Maximum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-max">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Minimum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-min">0.00 mm</div>
                            </div>
                        </div>
                        <div class="space-y-2 mb-4">
                            <p><strong>Reference Sphere Center:</strong> <span id="sphere-center">-</span></p>
                            <p><strong>Reference Sphere Radius:</strong> <span id="sphere-radius">-</span></p>
                            <p><strong>Worn Zone Area:</strong> <span id="worn-area">-</span></p>
                            <p><strong>Unworn Zone Area:</strong> <span id="unworn-area">-</span></p>
                        </div>
                        <div class="flex gap-3">
                            <button id="btn-export-csv" class="btn-secondary">Export CSV</button>
                            <button id="btn-export-pdf" class="btn-secondary">Export PDF Report</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        // Application State
        const state = {
            geometry: null,
            mesh: null,
            innerSurfaceVertices: [],
            wornVertices: [],
            unwornVertices: [],
            referenceSphere: null,
            wearData: null,
            maxWearLineObjects: []  // Track max wear line visualization objects for cleanup
        };

        // Initialize Main Viewer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('viewer-container').clientWidth / 
            document.getElementById('viewer-container').clientHeight,
            0.1,
            1000
        );
        camera.position.set(50, 50, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(
            document.getElementById('viewer-container').clientWidth,
            document.getElementById('viewer-container').clientHeight
        );
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(50, 50, 50);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-50, -50, -50);
        scene.add(directionalLight2);

        // Initialize Sphere Viewer
        const sphereScene = new THREE.Scene();
        sphereScene.background = new THREE.Color(0x1a202c);
        
        const sphereCamera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('sphere-viewer-container').clientWidth / 
            document.getElementById('sphere-viewer-container').clientHeight,
            0.1,
            1000
        );
        sphereCamera.position.set(50, 50, 50);

        const sphereRenderer = new THREE.WebGLRenderer({ antialias: true });
        sphereRenderer.setSize(
            document.getElementById('sphere-viewer-container').clientWidth,
            document.getElementById('sphere-viewer-container').clientHeight
        );
        document.getElementById('sphere-viewer-container').appendChild(sphereRenderer.domElement);

        const sphereControls = new OrbitControls(sphereCamera, sphereRenderer.domElement);
        sphereControls.enableDamping = true;
        sphereControls.dampingFactor = 0.05;

        // Lighting for sphere viewer
        const sphereAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
        sphereScene.add(sphereAmbientLight);

        const sphereDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sphereDirectionalLight.position.set(50, 50, 50);
        sphereScene.add(sphereDirectionalLight);

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            sphereControls.update();
            renderer.render(scene, camera);
            sphereRenderer.render(sphereScene, sphereCamera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            const viewerWidth = document.getElementById('viewer-container').clientWidth;
            const viewerHeight = document.getElementById('viewer-container').clientHeight;
            camera.aspect = viewerWidth / viewerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerWidth, viewerHeight);

            const sphereViewerWidth = document.getElementById('sphere-viewer-container').clientWidth;
            const sphereViewerHeight = document.getElementById('sphere-viewer-container').clientHeight;
            sphereCamera.aspect = sphereViewerWidth / sphereViewerHeight;
            sphereCamera.updateProjectionMatrix();
            sphereRenderer.setSize(sphereViewerWidth, sphereViewerHeight);
        });

        // File Upload Handler
        document.getElementById('file-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            updateStatus('processing', 'Loading STL file...');
            showLoading(true);

            const loader = new STLLoader();
            const reader = new FileReader();

            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                const geometry = loader.parse(arrayBuffer);
                
                // Center and scale geometry
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);
                
                // Compute normals
                geometry.computeVertexNormals();
                
                // Store geometry
                state.geometry = geometry;
                
                // Create mesh and add to scene
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide
                });
                
                if (state.mesh) {
                    scene.remove(state.mesh);
                }
                
                state.mesh = new THREE.Mesh(geometry, material);
                scene.add(state.mesh);
                
                // Adjust camera
                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
                
                updateStatus('complete', 'STL file loaded successfully');
                showLoading(false);
                enableButton('btn-isolate', true);
            };

            reader.readAsArrayBuffer(file);
        });

        // Utility Functions
        function updateStatus(type, text) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            indicator.className = 'status-indicator';
            if (type === 'ready') indicator.classList.add('status-ready');
            else if (type === 'processing') indicator.classList.add('status-processing');
            else if (type === 'complete') indicator.classList.add('status-complete');
            
            statusText.textContent = text;
        }

        function showLoading(show) {
            document.getElementById('loading-overlay').classList.toggle('hidden', !show);
        }

        function enableButton(buttonId, enabled) {
            const button = document.getElementById(buttonId);
            button.disabled = !enabled;
            if (enabled) {
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                button.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // ALGORITHM 1: Isolate Inner Surface
        // IMPROVED: Robust normal vector analysis with connectivity filtering
        // NOW WITH TRANSPARENCY: Non-selected surfaces are made 75% transparent
        document.getElementById('btn-isolate').addEventListener('click', async () => {
            if (!state.geometry) return;
            
            updateStatus('processing', 'Isolating inner bowl surface with robust filtering...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const positions = state.geometry.attributes.position.array;
            const normals = state.geometry.attributes.normal.array;
            
            // Step 1: Calculate geometric centroid
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexCount = positions.length / 3;
            
            for (let i = 0; i < positions.length; i += 3) {
                centroid.x += positions[i];
                centroid.y += positions[i + 1];
                centroid.z += positions[i + 2];
            }
            centroid.divideScalar(vertexCount);
            
            console.log(`Centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)}, ${centroid.z.toFixed(2)})`);
            
            // Step 2: Calculate distances to centroid for all faces
            const faceCount = positions.length / 9;
            const faceData = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                const faceCenter = new THREE.Vector3()
                    .add(v1).add(v2).add(v3)
                    .divideScalar(3);
                
                const n = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
                const toCentroid = new THREE.Vector3().subVectors(centroid, faceCenter).normalize();
                const dot = n.dot(toCentroid);
                const distanceToCentroid = faceCenter.distanceTo(centroid);
                
                faceData.push({
                    index: i / 9,
                    vertices: [v1, v2, v3],
                    indices: [i / 3, i / 3 + 1, i / 3 + 2],
                    dot,
                    distance: distanceToCentroid,
                    center: faceCenter
                });
            }
            
            // Step 3: Filter inner surface using multiple criteria
            // Inner surface should be: concave (dot > threshold) AND within distance range
            const distances = faceData.map(f => f.distance);
            distances.sort((a, b) => a - b);
            const medianDist = distances[Math.floor(distances.length / 2)];
            const q1Dist = distances[Math.floor(distances.length * 0.25)];
            const q3Dist = distances[Math.floor(distances.length * 0.75)];
            
            // Inner surface of concave bowl should be close to centroid (not far)
            // For acetabulum, the centroid is inside the bowl, so inner surface is closer
            const maxDistance = q3Dist;
            
            let candidateFaces = faceData.filter(f => 
                f.dot > 0.5 &&  // Stricter: normal points strongly toward centroid (concave)
                f.distance <= maxDistance  // Inner surface is closer to centroid for concave geometry
            );
            
            console.log(`Initial candidates: ${candidateFaces.length} faces (strict normal + distance filter)`);
            
            // Step 4: Keep only the largest connected component (OPTIMIZED)
            // This eliminates small isolated regions (like the green spots at the bottom)
            console.log(`Building adjacency graph for ${candidateFaces.length} faces...`);
            
            // Helper: convert vertex position to unique key (round to avoid floating point issues)
            const vertexKey = (v) => {
                const precision = 1000; // 0.001mm precision
                return `${Math.round(v.x * precision)},${Math.round(v.y * precision)},${Math.round(v.z * precision)}`;
            };
            
            // Build vertex-to-faces map using position-based keys
            const vertexToFaces = new Map();
            candidateFaces.forEach(f => {
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (!vertexToFaces.has(key)) {
                        vertexToFaces.set(key, []);
                    }
                    vertexToFaces.get(key).push(f.index);
                });
            });
            
            // Build adjacency list: faces are adjacent if they share a vertex position
            const adjacency = new Map();
            candidateFaces.forEach(f => {
                adjacency.set(f.index, new Set());
            });
            
            candidateFaces.forEach(f => {
                // For each vertex in this face, find all other faces that share the same position
                const neighbors = new Set();
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (vertexToFaces.has(key)) {
                        vertexToFaces.get(key).forEach(neighborIdx => {
                            if (neighborIdx !== f.index) {
                                neighbors.add(neighborIdx);
                            }
                        });
                    }
                });
                
                // Add to adjacency list
                neighbors.forEach(n => adjacency.get(f.index).add(n));
            });
            
            // Find connected components using BFS
            const visited = new Set();
            const components = [];
            
            candidateFaces.forEach(f => {
                if (visited.has(f.index)) return;
                
                const component = [];
                const queue = [f.index];
                visited.add(f.index);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    
                    if (adjacency.has(current)) {
                        for (let neighbor of adjacency.get(current)) {
                            if (!visited.has(neighbor)) {
                                visited.add(neighbor);
                                queue.push(neighbor);
                            }
                        }
                    }
                }
                
                components.push(component);
            });
            
            // Select largest connected component
            components.sort((a, b) => b.length - a.length);
            const largestComponent = components.length > 0 ? components[0] : [];
            
            console.log(`Connected components: ${components.length}, largest has ${largestComponent.length} faces`);
            
            // Step 5: Build final inner surface from largest component
            const innerFaceSet = new Set(largestComponent);
            const innerFaces = largestComponent;
            state.innerSurfaceVertices = [];
            const vertexMap = new Map();
            
            candidateFaces.forEach(f => {
                if (!innerFaceSet.has(f.index)) return;
                
                f.vertices.forEach((v, i) => {
                    const idx = f.indices[i];
                    if (!vertexMap.has(idx)) {
                        const vData = { pos: v.clone(), index: idx };
                        vertexMap.set(idx, vData);
                        state.innerSurfaceVertices.push(vData);
                    }
                });
            });
            
            console.log(`Inner surface isolated: ${innerFaces.length} faces, ${state.innerSurfaceVertices.length} unique vertices`);
            console.log(`Algorithm: Robust normal analysis + connectivity filtering (largest component)`);
            
            // Step 6: Apply transparency to non-selected surfaces (75% transparent = 0.25 opacity)
            // Build index buffer with inner faces first, then outer faces
            const innerIndices = [];
            const outerIndices = [];
            
            for (let faceIdx = 0; faceIdx < faceCount; faceIdx++) {
                const baseIdx = faceIdx * 3; // Each face has 3 vertices
                if (innerFaceSet.has(faceIdx)) {
                    // Inner surface vertices - add to inner list
                    innerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                } else {
                    // Outer surface vertices - add to outer list (will be 75% transparent)
                    outerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                }
            }
            
            console.log(`Inner indices: ${innerIndices.length}, Outer indices: ${outerIndices.length}`);
            
            // Combine indices: inner first, then outer
            const combinedIndices = [...innerIndices, ...outerIndices];
            
            // Apply new index buffer to geometry
            const geometry = state.geometry;
            geometry.setIndex(combinedIndices);
            
            // Clear existing groups
            geometry.clearGroups();
            
            // Add group for inner surface (opaque) - starts at 0
            if (innerIndices.length > 0) {
                geometry.addGroup(0, innerIndices.length, 0);
                console.log(`Inner group: start=0, count=${innerIndices.length}, materialIndex=0 (opaque)`);
            }
            
            // Add group for outer surface (75% transparent) - starts after inner
            if (outerIndices.length > 0) {
                geometry.addGroup(innerIndices.length, outerIndices.length, 1);
                console.log(`Outer group: start=${innerIndices.length}, count=${outerIndices.length}, materialIndex=1 (75% transparent)`);
            }
            
            // Create materials array: [0] opaque for inner, [1] 75% transparent for outer
            const materials = [
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: false
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // 75% transparent = 25% opaque
                    depthWrite: false
                })
            ];
            
            // Update mesh with multi-material
            state.mesh.material = materials;
            state.mesh.renderOrder = 1; // Ensure proper transparency rendering
            
            updateStatus('complete', `Inner surface isolated: ${innerFaces.length} faces (${((innerFaces.length/faceCount)*100).toFixed(1)}% of mesh), ${state.innerSurfaceVertices.length} vertices`);
            showLoading(false);
            enableButton('btn-detect-wear', true);
        });

        // ALGORITHM 2: Detect Worn/Unworn Zones
        // IMPROVED: Curvature-based detection using Gaussian curvature and saddle points
        // Methodology: Meyer et al. 2003 + rim exclusion + radial deviation analysis
        document.getElementById('btn-detect-wear').addEventListener('click', async () => {
            if (state.innerSurfaceVertices.length === 0) {
                alert('Please isolate inner surface first');
                return;
            }
            
            updateStatus('processing', 'Detecting wear zones using curvature analysis (Gaussian curvature + saddle points)...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const allVertices = state.innerSurfaceVertices;
            console.log(`=== CURVATURE-BASED WEAR DETECTION ===`);
            console.log(`Processing ${allVertices.length} inner surface vertices`);
            
            // Step 1: Build vertex adjacency and face data structures
            console.log('Building mesh topology...');
            const positions = state.geometry.attributes.position.array;
            const normals = state.geometry.attributes.normal.array;
            
            // Vertex-to-faces mapping
            const vertexToFaces = new Map();
            allVertices.forEach(v => {
                vertexToFaces.set(v.index, []);
            });
            
            // Collect faces from inner surface
            const innerVertexIndices = new Set(allVertices.map(v => v.index));
            const faces = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = i / 3;
                const idx2 = i / 3 + 1;
                const idx3 = i / 3 + 2;
                
                // Only process faces that belong to inner surface
                if (!innerVertexIndices.has(idx1) || !innerVertexIndices.has(idx2) || !innerVertexIndices.has(idx3)) {
                    continue;
                }
                
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                const face = {
                    indices: [idx1, idx2, idx3],
                    vertices: [v1, v2, v3]
                };
                
                faces.push(face);
                vertexToFaces.get(idx1).push(face);
                vertexToFaces.get(idx2).push(face);
                vertexToFaces.get(idx3).push(face);
            }
            
            console.log(`Found ${faces.length} faces in inner surface`);
            
            // Step 2: Build vertex neighborhood (1-ring)
            const vertexNeighbors = new Map();
            allVertices.forEach(v => {
                vertexNeighbors.set(v.index, new Set());
            });
            
            faces.forEach(face => {
                const [i1, i2, i3] = face.indices;
                vertexNeighbors.get(i1).add(i2);
                vertexNeighbors.get(i1).add(i3);
                vertexNeighbors.get(i2).add(i1);
                vertexNeighbors.get(i2).add(i3);
                vertexNeighbors.get(i3).add(i1);
                vertexNeighbors.get(i3).add(i2);
            });
            
            // Step 3: Calculate Gaussian curvature using Meyer et al. 2003 method
            console.log('Calculating Gaussian curvature (Meyer 2003)...');
            const gaussianCurvatures = new Map();
            
            // Helper: Calculate angle between two vectors
            function angleBetweenVectors(v1, v2) {
                const dot = v1.dot(v2);
                const lengths = v1.length() * v2.length();
                if (lengths < 1e-10) return 0;
                return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
            }
            
            // Helper: Calculate mixed Voronoi area for vertex (Meyer 2003)
            function calculateMixedArea(vertexIdx, vertexPos, adjacentFaces) {
                let mixedArea = 0;
                
                adjacentFaces.forEach(face => {
                    // Find vertex positions in this face
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    
                    // Find index of current vertex in face
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    // Triangle edges from vertex
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    // Triangle area
                    const triangleArea = 0.5 * new THREE.Vector3().crossVectors(e1, e2).length();
                    
                    // Check if triangle is obtuse
                    const angle0 = angleBetweenVectors(e1, e2);
                    const e1neg = e1.clone().negate();
                    const e12 = new THREE.Vector3().subVectors(v2, v1);
                    const angle1 = angleBetweenVectors(e1neg, e12);
                    const e2neg = e2.clone().negate();
                    const e21 = new THREE.Vector3().subVectors(v1, v2);
                    const angle2 = angleBetweenVectors(e2neg, e21);
                    
                    // Meyer 2003: Different area calculation based on triangle type
                    if (angle0 > Math.PI / 2) {
                        // Obtuse at vertex 0 (our vertex)
                        mixedArea += triangleArea / 2;
                    } else if (angle1 > Math.PI / 2 || angle2 > Math.PI / 2) {
                        // Obtuse at other vertex
                        mixedArea += triangleArea / 4;
                    } else {
                        // Non-obtuse: use Voronoi area (simplified: use barycentric)
                        mixedArea += triangleArea / 3;
                    }
                });
                
                return Math.max(mixedArea, 1e-10); // Avoid division by zero
            }
            
            // Calculate Gaussian curvature for each vertex
            allVertices.forEach(v => {
                const vertexIdx = v.index;
                const vertexPos = v.pos;
                const adjacentFaces = vertexToFaces.get(vertexIdx);
                
                if (!adjacentFaces || adjacentFaces.length === 0) {
                    gaussianCurvatures.set(vertexIdx, 0);
                    return;
                }
                
                // Meyer 2003: K = (2π - Σθⱼ) / A_mixed
                // where θⱼ are the angles at this vertex in adjacent triangles
                
                let angleSum = 0;
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    angleSum += angleBetweenVectors(e1, e2);
                });
                
                const mixedArea = calculateMixedArea(vertexIdx, vertexPos, adjacentFaces);
                const gaussianCurvature = (2 * Math.PI - angleSum) / mixedArea;
                
                gaussianCurvatures.set(vertexIdx, gaussianCurvature);
            });
            
            console.log(`Calculated Gaussian curvature for ${gaussianCurvatures.size} vertices`);
            
            // Step 4: Detect rim/edge vertices to exclude from wear analysis
            console.log('Detecting rim/edge vertices...');
            const rimVertices = new Set();
            
            // Rim detection: vertices with fewer neighbors (boundary) or at extreme distances
            allVertices.forEach(v => {
                const neighbors = vertexNeighbors.get(v.index);
                const faces = vertexToFaces.get(v.index);
                
                // Boundary vertex if neighbor count != face count (open mesh boundary)
                if (neighbors && faces && neighbors.size < faces.length * 2) {
                    rimVertices.add(v.index);
                }
            });
            
            // Also detect rim by radial distance (outer perimeter)
            const centroid = new THREE.Vector3(0, 0, 0);
            allVertices.forEach(v => centroid.add(v.pos));
            centroid.divideScalar(allVertices.length);
            
            const radialDistances = allVertices.map(v => v.pos.distanceTo(centroid));
            radialDistances.sort((a, b) => a - b);
            const maxRadialDist = radialDistances[radialDistances.length - 1];
            const rimThreshold = maxRadialDist * 0.85; // Top 15% radial distance = rim
            
            allVertices.forEach(v => {
                if (v.pos.distanceTo(centroid) > rimThreshold) {
                    rimVertices.add(v.index);
                }
            });
            
            console.log(`Detected ${rimVertices.size} rim vertices (excluded from wear analysis)`);
            
            // Step 5: Fit reference sphere to ALL inner surface vertices (for radial deviation)
            console.log('Fitting reference sphere...');
            let center = new THREE.Vector3(0, 0, 0);
            allVertices.forEach(v => center.add(v.pos));
            center.divideScalar(allVertices.length);
            
            // Initial radius estimate
            let avgRadius = 0;
            allVertices.forEach(v => avgRadius += v.pos.distanceTo(center));
            avgRadius /= allVertices.length;
            
            // Refine sphere fit
            for (let iter = 0; iter < 5; iter++) {
                const newCenter = new THREE.Vector3(0, 0, 0);
                let newRadius = 0;
                
                allVertices.forEach(v => {
                    const dir = new THREE.Vector3().subVectors(v.pos, center).normalize();
                    const pointOnSphere = center.clone().add(dir.multiplyScalar(avgRadius));
                    newCenter.add(pointOnSphere);
                });
                newCenter.divideScalar(allVertices.length);
                
                allVertices.forEach(v => {
                    newRadius += v.pos.distanceTo(newCenter);
                });
                newRadius /= allVertices.length;
                
                center = newCenter;
                avgRadius = newRadius;
            }
            
            console.log(`Reference sphere: center=(${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius=${avgRadius.toFixed(2)}`);
            
            // Step 6: Calculate penetration depths (radial deviation)
            const penetrationDepths = new Array(allVertices.length);
            for (let i = 0; i < allVertices.length; i++) {
                const v = allVertices[i].pos;
                const distance = v.distanceTo(center);
                penetrationDepths[i] = avgRadius - distance; // Positive = inside sphere (worn)
            }
            
            // Step 7: COMBINED SCORING: Curvature + Radial Deviation
            // Worn zones have: negative Gaussian curvature (saddle points) + high penetration
            console.log('Computing combined wear scores (curvature + radial deviation)...');
            
            const wearScores = new Map();
            const validVertices = []; // Vertices not on rim
            
            allVertices.forEach((v, i) => {
                // Exclude rim vertices
                if (rimVertices.has(v.index)) {
                    wearScores.set(v.index, -Infinity); // Never classify rim as worn
                    return;
                }
                
                validVertices.push(v);
                
                const K = gaussianCurvatures.get(v.index) || 0;
                const penetration = penetrationDepths[i];
                
                // Wear score combines:
                // 1. Negative curvature (K < 0) indicates saddle point (wear signature)
                // 2. Positive penetration indicates material loss
                // Score = penetration * (1 + saddleWeight * |K|) if K < 0
                //       = penetration * 0.5                     if K >= 0
                
                let score;
                if (K < 0) {
                    // Saddle point: boost score by curvature magnitude
                    const saddleWeight = 2.0; // Weight for curvature contribution
                    score = penetration * (1 + saddleWeight * Math.abs(K));
                } else {
                    // Not a saddle point: reduce score
                    score = penetration * 0.5;
                }
                
                wearScores.set(v.index, score);
            });
            
            console.log(`Computed wear scores for ${validVertices.length} valid vertices (${rimVertices.size} rim vertices excluded)`);
            
            // Step 8: Classify worn/unworn using IQR on wear scores
            const scores = validVertices.map(v => wearScores.get(v.index)).filter(s => s !== -Infinity);
            scores.sort((a, b) => a - b);
            
            const q1Score = scores[Math.floor(scores.length * 0.25)];
            const q3Score = scores[Math.floor(scores.length * 0.75)];
            const medianScore = scores[Math.floor(scores.length / 2)];  // FIXED: was / 0.5
            const iqrScore = q3Score - q1Score;
            
            // Worn threshold: scores above Q3 + 0.5*IQR (conservative)
            const wornThreshold = q3Score + 0.3 * iqrScore;
            
            console.log(`Wear score stats: Q1=${q1Score.toFixed(4)}, Median=${medianScore.toFixed(4)}, Q3=${q3Score.toFixed(4)}, IQR=${iqrScore.toFixed(4)}`);
            console.log(`Worn threshold: ${wornThreshold.toFixed(4)}`);
            
            // Classify vertices
            state.wornVertices = [];
            state.unwornVertices = [];
            
            allVertices.forEach(v => {
                const score = wearScores.get(v.index);
                if (score > wornThreshold) {
                    state.wornVertices.push(v);
                } else {
                    state.unwornVertices.push(v);
                }
            });
            
            // Ensure reasonable distribution
            if (state.wornVertices.length === 0 || state.wornVertices.length > validVertices.length * 0.5) {
                console.log('Adjusting classification (fallback to top 20% by wear score)...');
                
                // FIXED: Build complete ranking with actual wear scores
                const rankedVertices = validVertices.map(v => ({
                    vertex: v,
                    score: wearScores.get(v.index) || -Infinity
                }));
                
                // Sort by score (highest first = most worn)
                rankedVertices.sort((a, b) => b.score - a.score);
                
                // Worn vertices are the top 20% with highest scores
                const wornCount = Math.floor(validVertices.length * 0.20);
                
                state.wornVertices = rankedVertices.slice(0, wornCount).map(r => r.vertex);
                state.unwornVertices = rankedVertices.slice(wornCount).map(r => r.vertex);
            }
            
            // Step 9: Apply colors to geometry
            const colors = new Float32Array(state.geometry.attributes.position.count * 3);
            
            // Default color (blue)
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259;
                colors[i + 1] = 0.6;
                colors[i + 2] = 0.882;
            }
            
            // Worn vertices (red)
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96;
                colors[idx + 1] = 0.396;
                colors[idx + 2] = 0.396;
            });
            
            // Unworn vertices (green)
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282;
                colors[idx + 1] = 0.733;
                colors[idx + 2] = 0.471;
            });
            
            state.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Keep multi-material: opaque for inner surface (with vertex colors), 75% transparent for outer
            // Update only the inner surface material to use vertex colors
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // Use vertex colors for worn/unworn visualization
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: false  // Inner surface opaque
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent
                    depthWrite: false
                })
            ];
            
            state.mesh.material = materials;
            state.mesh.renderOrder = 1;
            
            const wornPercent = (state.wornVertices.length / allVertices.length * 100).toFixed(1);
            const unwornPercent = (state.unwornVertices.length / allVertices.length * 100).toFixed(1);
            
            console.log(`=== CLASSIFICATION RESULTS ===`);
            console.log(`Worn: ${state.wornVertices.length} (${wornPercent}%), Unworn: ${state.unwornVertices.length} (${unwornPercent}%)`);
            console.log(`Rim excluded: ${rimVertices.size} vertices`);
            console.log(`Algorithm: Gaussian curvature (Meyer 2003) + radial deviation + rim exclusion`);
            
            updateStatus('complete', `Wear zones detected using curvature analysis: ${state.wornVertices.length} worn (${wornPercent}%), ${state.unwornVertices.length} unworn (${unwornPercent}%)`);
            showLoading(false);
            enableButton('btn-fit-sphere', true);
        });

        // ALGORITHM 3: Fit Unworn Sphere and Detect Transition Plane
        // IMPROVED: Fits sphere ONLY to unworn zone (reference geometry)
        // Generates transition plane containing boundary points between worn/unworn
        document.getElementById('btn-fit-sphere').addEventListener('click', async () => {
            if (state.unwornVertices.length === 0 || state.wornVertices.length === 0) {
                alert('Please detect wear zones first');
                return;
            }
            
            updateStatus('processing', 'Fitting unworn sphere and detecting transition boundary...');
            showLoading(true);
            document.getElementById('sphere-loading-overlay').classList.remove('hidden');
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // IMPROVED Helper function: Gauss-Newton with Levenberg-Marquardt fallback
            function fitSphereRobust(vertices) {
                // Step 1: Initialize center (geometric centroid)
                let center = new THREE.Vector3(0, 0, 0);
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Step 2: Initialize radius (average distance to center)
                let radius = 0;
                vertices.forEach(p => radius += p.distanceTo(center));
                radius /= vertices.length;
                
                console.log(`Initial sphere: center=(${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius=${radius.toFixed(2)}`);
                
                // Step 3: Gauss-Newton iterations with adaptive damping
                const maxIterations = 20;
                const tolerance = 1e-6;
                let lambda = 0.001; // LM damping factor
                let prevResidual = Infinity;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Compute residuals: r_i = ||p_i - c|| - R
                    let residualSum = 0;
                    const n = vertices.length;
                    
                    // Jacobian matrix: J is n x 4 (partial derivatives w.r.t. cx, cy, cz, R)
                    // For each point p_i: residual = sqrt((px-cx)^2 + (py-cy)^2 + (pz-cz)^2) - R
                    // ∂r/∂cx = -(px-cx)/d, ∂r/∂cy = -(py-cy)/d, ∂r/∂cz = -(pz-cz)/d, ∂r/∂R = -1
                    
                    const J = []; // Jacobian matrix (n x 4)
                    const residuals = []; // Residual vector (n x 1)
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        const residual = dist - radius;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        // Jacobian row: [∂r/∂cx, ∂r/∂cy, ∂r/∂cz, ∂r/∂R]
                        if (dist > 1e-10) {
                            J.push([-dx/dist, -dy/dist, -dz/dist, -1]);
                        } else {
                            J.push([0, 0, 0, -1]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    console.log(`Iteration ${iter}: RMSE = ${currentResidual.toFixed(6)}, lambda = ${lambda.toFixed(6)}`);
                    
                    // Check convergence
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        console.log(`Converged after ${iter} iterations`);
                        break;
                    }
                    
                    // Compute J^T * J (4x4 matrix)
                    const JTJ = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add Levenberg-Marquardt damping: JTJ + lambda * I
                    for (let i = 0; i < 4; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r (4x1 vector)
                    const JTr = [0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    // Solve (JTJ) * delta = -JTr using Gauss elimination
                    const delta = solveLinearSystem4x4(JTJ, JTr.map(x => -x));
                    
                    if (!delta) {
                        console.log('Singular matrix, increasing lambda');
                        lambda *= 10;
                        continue;
                    }
                    
                    // Update parameters
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadius = radius + delta[3];
                    
                    // Check if update improves residual
                    let newResidualSum = 0;
                    vertices.forEach(p => {
                        const r = p.distanceTo(newCenter) - newRadius;
                        newResidualSum += r * r;
                    });
                    const newResidual = Math.sqrt(newResidualSum / n);
                    
                    if (newResidual < currentResidual) {
                        // Accept update, decrease damping
                        center = newCenter;
                        radius = newRadius;
                        prevResidual = currentResidual;
                        lambda = Math.max(lambda / 10, 1e-10);
                    } else {
                        // Reject update, increase damping (Levenberg-Marquardt)
                        lambda *= 10;
                        if (lambda > 1e6) {
                            console.log('Lambda too large, stopping');
                            break;
                        }
                    }
                }
                
                console.log(`Final sphere: center=(${center.x.toFixed(4)}, ${center.y.toFixed(4)}, ${center.z.toFixed(4)}), radius=${radius.toFixed(4)}`);
                
                return { center, radius };
            }
            
            // Helper: Solve 4x4 linear system using Gauss elimination
            function solveLinearSystem4x4(A, b) {
                // Create augmented matrix
                const n = 4;
                const aug = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    // Check for singular matrix
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    // Eliminate column
                    for (let k = i + 1; k < n; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j <= n; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                // Back substitution
                const x = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = aug[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            }
            
            // Fit ONLY unworn sphere (reference geometry for ideal unworn surface)
            // ROBUST ITERATIVE FITTING: Multiple iterations with outlier removal
            console.log('=== Fitting UNWORN sphere (reference geometry - ROBUST ITERATIVE) ===');
            const unwornPositions = state.unwornVertices.map(v => v.pos);
            
            // Iteration 1: Initial fit with all unworn vertices
            console.log('--- Iteration 1: Initial fit with all unworn vertices ---');
            let currentSphere = fitSphereRobust(unwornPositions);
            console.log(`Iteration 1 result: center=(${currentSphere.center.x.toFixed(4)}, ${currentSphere.center.y.toFixed(4)}, ${currentSphere.center.z.toFixed(4)}), radius=${currentSphere.radius.toFixed(4)}`);
            
            // Iteration 2: Remove outliers (vertices > 2 std deviations from sphere) and refit
            console.log('--- Iteration 2: Outlier removal and refinement ---');
            let distances = unwornPositions.map(p => Math.abs(p.distanceTo(currentSphere.center) - currentSphere.radius));
            let meanDist = distances.reduce((a, b) => a + b, 0) / distances.length;
            let variance = distances.reduce((sum, d) => sum + Math.pow(d - meanDist, 2), 0) / distances.length;
            let stdDev = Math.sqrt(variance);
            
            const threshold = meanDist + 2 * stdDev;  // 2 sigma threshold
            const inliers = unwornPositions.filter((p, i) => distances[i] < threshold);
            console.log(`Removed ${unwornPositions.length - inliers.length} outliers (>${threshold.toFixed(4)} mm deviation), keeping ${inliers.length} inliers`);
            
            if (inliers.length >= 10) {  // Need at least 10 points for stable fit
                currentSphere = fitSphereRobust(inliers);
                console.log(`Iteration 2 result: center=(${currentSphere.center.x.toFixed(4)}, ${currentSphere.center.y.toFixed(4)}, ${currentSphere.center.z.toFixed(4)}), radius=${currentSphere.radius.toFixed(4)}`);
                
                // Iteration 3: Final refinement with tighter threshold
                console.log('--- Iteration 3: Final refinement ---');
                distances = inliers.map(p => Math.abs(p.distanceTo(currentSphere.center) - currentSphere.radius));
                meanDist = distances.reduce((a, b) => a + b, 0) / distances.length;
                variance = distances.reduce((sum, d) => sum + Math.pow(d - meanDist, 2), 0) / distances.length;
                stdDev = Math.sqrt(variance);
                
                const finalThreshold = meanDist + 1.5 * stdDev;  // Tighter 1.5 sigma threshold
                const finalInliers = inliers.filter((p, i) => distances[i] < finalThreshold);
                console.log(`Final refinement: removed ${inliers.length - finalInliers.length} additional outliers, keeping ${finalInliers.length} best-fit vertices`);
                
                if (finalInliers.length >= 10) {
                    currentSphere = fitSphereRobust(finalInliers);
                    console.log(`Final sphere: center=(${currentSphere.center.x.toFixed(4)}, ${currentSphere.center.y.toFixed(4)}, ${currentSphere.center.z.toFixed(4)}), radius=${currentSphere.radius.toFixed(4)}`);
                }
            }
            
            state.unwornSphere = currentSphere;
            console.log(`=== ROBUST UNWORN SPHERE FITTED (${inliers.length} inliers from ${unwornPositions.length} unworn vertices) ===`);
            
            // Detect boundary vertices (transition between worn and unworn)
            // IMPROVED: Use radial distance analysis to find true inflection zone
            console.log('=== Detecting transition boundary (IMPROVED: radial inflection analysis) ===');
            const wornIndices = new Set(state.wornVertices.map(v => v.index));
            const unwornIndices = new Set(state.unwornVertices.map(v => v.index));
            const boundaryVertices = [];
            
            // Find vertices that are neighbors to both worn and unworn regions
            const positions = state.geometry.attributes.position.array;
            const index = state.geometry.index ? state.geometry.index.array : null;
            
            // Build vertex-to-vertex connectivity
            const neighbors = new Map();
            for (let i = 0; i < state.innerSurfaceVertices.length; i++) {
                neighbors.set(state.innerSurfaceVertices[i].index, new Set());
            }
            
            // Process faces to build adjacency
            const processedFaces = index ? index.length / 3 : positions.length / 9;
            for (let i = 0; i < processedFaces; i++) {
                let idx1, idx2, idx3;
                if (index) {
                    idx1 = index[i * 3];
                    idx2 = index[i * 3 + 1];
                    idx3 = index[i * 3 + 2];
                } else {
                    idx1 = i * 3;
                    idx2 = i * 3 + 1;
                    idx3 = i * 3 + 2;
                }
                
                // Add edges
                if (neighbors.has(idx1) && neighbors.has(idx2)) {
                    neighbors.get(idx1).add(idx2);
                    neighbors.get(idx2).add(idx1);
                }
                if (neighbors.has(idx2) && neighbors.has(idx3)) {
                    neighbors.get(idx2).add(idx3);
                    neighbors.get(idx3).add(idx2);
                }
                if (neighbors.has(idx3) && neighbors.has(idx1)) {
                    neighbors.get(idx3).add(idx1);
                    neighbors.get(idx1).add(idx3);
                }
            }
            
            // Find boundary: unworn vertices that have worn neighbors
            state.unwornVertices.forEach(v => {
                if (neighbors.has(v.index)) {
                    for (let neighborIdx of neighbors.get(v.index)) {
                        if (wornIndices.has(neighborIdx)) {
                            boundaryVertices.push(v.pos);
                            break;
                        }
                    }
                }
            });
            
            console.log(`Found ${boundaryVertices.length} boundary vertices at worn/unworn interface`);
            
            // Fit plane to boundary points using IMPROVED least squares with radial analysis
            // IMPROVEMENT: Position plane at the radial inflection point (true worn/unworn boundary)
            // Plane equation: ax + by + cz + d = 0
            if (boundaryVertices.length < 3) {
                console.warn(`Not enough boundary points (${boundaryVertices.length}), using sphere-based fallback plane`);
                // Fallback: Use default radial plane through sphere
                // Position plane at average radius between worn and unworn zones
                let avgWornDist = state.unwornSphere.radius * 0.9; // Default: 90% of sphere radius
                if (state.wornVertices.length > 0) {
                    const wornDistances = state.wornVertices.map(v => v.pos.distanceTo(state.unwornSphere.center));
                    avgWornDist = wornDistances.reduce((sum, d) => sum + d, 0) / wornDistances.length;
                }
                const defaultRadialDist = (state.unwornSphere.radius + avgWornDist) / 2;
                
                // Use dominant radial direction (from centroid of all inner surface points)
                let radialDir = new THREE.Vector3(0, 0, 1); // Default direction (Z-axis)
                if (state.innerSurfaceVertices.length > 0) {
                    const allInnerCentroid = new THREE.Vector3(0, 0, 0);
                    state.innerSurfaceVertices.forEach(v => allInnerCentroid.add(v.pos));
                    allInnerCentroid.divideScalar(state.innerSurfaceVertices.length);
                    const tempDir = new THREE.Vector3().subVectors(allInnerCentroid, state.unwornSphere.center);
                    
                    // Guard against zero-length vector (centroid == sphere center)
                    if (tempDir.lengthSq() > 1e-10) {
                        radialDir = tempDir.normalize();
                    } else {
                        console.warn('Centroid coincides with sphere center, using Z-axis as default');
                    }
                }
                
                const planePoint = state.unwornSphere.center.clone().add(radialDir.clone().multiplyScalar(defaultRadialDist));
                state.transitionPlane = { 
                    normal: radialDir, 
                    point: planePoint,
                    d: radialDir.dot(planePoint)
                };
                console.log(`Fallback plane: radial dist=${defaultRadialDist.toFixed(3)}, normal=(${radialDir.x.toFixed(3)}, ${radialDir.y.toFixed(3)}, ${radialDir.z.toFixed(3)})`);
            } else {
                // Compute centroid of boundary (this is the inflection zone center)
                const centroid = new THREE.Vector3(0, 0, 0);
                boundaryVertices.forEach(v => centroid.add(v));
                centroid.divideScalar(boundaryVertices.length);
                
                // IMPROVED: Calculate average radial distance from sphere center to boundary
                // This defines the exact radial position of the worn/unworn inflection
                const avgRadialDist = boundaryVertices.reduce((sum, v) => 
                    sum + v.distanceTo(state.unwornSphere.center), 0) / boundaryVertices.length;
                
                console.log(`Boundary average radial distance from sphere center: ${avgRadialDist.toFixed(4)} mm`);
                console.log(`Unworn sphere radius: ${state.unwornSphere.radius.toFixed(4)} mm`);
                console.log(`Radial deviation at boundary: ${(state.unwornSphere.radius - avgRadialDist).toFixed(4)} mm`);
                
                // Method 1: Use radial direction from sphere center to boundary centroid as plane normal
                // This ensures the plane is perpendicular to the radial wear direction
                const radialNormal = new THREE.Vector3().subVectors(centroid, state.unwornSphere.center).normalize();
                
                // Position the plane at the boundary centroid (true inflection zone)
                const normal = radialNormal;
                const point = centroid;
                const d = normal.dot(point);
                
                state.transitionPlane = { normal, point, d };
                console.log(`IMPROVED Transition plane at radial inflection zone:`);
                console.log(`  Normal (radial direction): (${normal.x.toFixed(3)}, ${normal.y.toFixed(3)}, ${normal.z.toFixed(3)})`);
                console.log(`  Point (boundary centroid): (${point.x.toFixed(3)}, ${point.y.toFixed(3)}, ${point.z.toFixed(3)})`);
                console.log(`  Plane equation d: ${d.toFixed(3)}`);
            }
            
            // Clear and update sphere viewer
            while (sphereScene.children.length > 0) {
                sphereScene.remove(sphereScene.children[0]);
            }
            
            sphereScene.add(sphereAmbientLight);
            sphereScene.add(sphereDirectionalLight);
            
            // Add STL mesh with vertex colors AND transparency for non-isolated surfaces
            const clonedGeometry = state.geometry.clone();
            
            // CRITICAL: geometry.clone() does NOT preserve groups, must copy manually
            // Copy groups from original geometry to preserve inner/outer surface separation
            clonedGeometry.clearGroups();
            if (state.geometry.groups && state.geometry.groups.length > 0) {
                state.geometry.groups.forEach(group => {
                    clonedGeometry.addGroup(group.start, group.count, group.materialIndex);
                });
                console.log(`Copied ${state.geometry.groups.length} geometry groups to cloned geometry`);
            }
            
            // Set up vertex colors for worn/unworn zones
            const colors = new Float32Array(clonedGeometry.attributes.position.count * 3);
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259; colors[i + 1] = 0.6; colors[i + 2] = 0.882;
            }
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96; colors[idx + 1] = 0.396; colors[idx + 2] = 0.396;
            });
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282; colors[idx + 1] = 0.733; colors[idx + 2] = 0.471;
            });
            clonedGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create multi-material setup: inner surface opaque, outer surface 75% transparent
            // This matches the behavior in the main 3D viewer
            // CRITICAL: Both materials MUST have vertexColors:true to share the BufferGeometry correctly
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7  // Inner surface with vertex colors
                }),
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // CRITICAL: Must be true to properly share geometry with inner material
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent (25% opaque)
                    depthWrite: false
                })
            ];
            
            const clonedMesh = new THREE.Mesh(clonedGeometry, materials);
            clonedMesh.renderOrder = 1;
            
            // Force proper transparency rendering by ensuring renderer sorts objects
            sphereRenderer.sortObjects = true;
            
            sphereScene.add(clonedMesh);
            
            // Add unworn reference sphere (green, semi-transparent)
            const unwornSphereGeom = new THREE.SphereGeometry(state.unwornSphere.radius, 64, 64);
            const unwornSphereMat = new THREE.MeshPhongMaterial({
                color: 0x48bb78,
                transparent: true,
                opacity: 0.7,  // Increased opacity to match STL mesh for better visibility
                side: THREE.DoubleSide
            });
            const unwornSphereMesh = new THREE.Mesh(unwornSphereGeom, unwornSphereMat);
            unwornSphereMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornSphereMesh);
            
            // Add unworn sphere center marker
            const unwornCenterGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const unwornCenterMat = new THREE.MeshBasicMaterial({ color: 0x48bb78 });
            const unwornCenterMesh = new THREE.Mesh(unwornCenterGeom, unwornCenterMat);
            unwornCenterMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornCenterMesh);
            
            // Add transition plane at worn/unworn inflection zone
            const planeSize = state.unwornSphere.radius * 4;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,  // Green to mark the inflection boundary
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const planeMesh = new THREE.Mesh(planeGeom, planeMat);
            planeMesh.position.copy(state.transitionPlane.point);
            
            // Orient plane to match normal (radial direction)
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, state.transitionPlane.normal);
            planeMesh.quaternion.copy(quaternion);
            sphereScene.add(planeMesh);
            
            // Add boundary vertices visualization (yellow/gold points at exact inflection)
            const boundaryGeom = new THREE.BufferGeometry();
            const boundaryPositions = new Float32Array(boundaryVertices.length * 3);
            boundaryVertices.forEach((v, i) => {
                boundaryPositions[i * 3] = v.x;
                boundaryPositions[i * 3 + 1] = v.y;
                boundaryPositions[i * 3 + 2] = v.z;
            });
            boundaryGeom.setAttribute('position', new THREE.BufferAttribute(boundaryPositions, 3));
            const boundaryMat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.8 });
            const boundaryPoints = new THREE.Points(boundaryGeom, boundaryMat);
            sphereScene.add(boundaryPoints);
            
            // Position camera
            const size = new THREE.Vector3();
            state.geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            sphereCamera.position.set(maxDim, maxDim, maxDim);
            sphereControls.target.set(0, 0, 0);
            sphereControls.update();
            
            updateStatus('complete', 'Unworn sphere fitted and transition boundary detected');
            showLoading(false);
            document.getElementById('sphere-loading-overlay').classList.add('hidden');
            enableButton('btn-calculate', true);
        });

        // ALGORITHM 4: Calculate Volumetric and Linear Wear
        // NEW METHOD: Volume between transition plane and worn surface, minus spherical cap
        // Formula: V_wear = V(plane to surface) - V(spherical cap)
        document.getElementById('btn-calculate').addEventListener('click', async () => {
            if (!state.unwornSphere || !state.transitionPlane) {
                alert('Please fit unworn sphere and detect transition plane first');
                return;
            }
            
            updateStatus('processing', 'Calculating wear volume: (plane-to-surface) - (spherical cap)...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            console.log('=== VOLUMETRIC WEAR CALCULATION (CORRECTED METHOD) ===');
            console.log('Formula: V_wear = Volume between fitted sphere and real worn surface (clipped by plane)');
            console.log('Plane equation: n·p = d, where n =', state.transitionPlane.normal, ', d =', state.transitionPlane.d);
            
            const positions = state.geometry.attributes.position.array;
            const wornVertexIndices = new Set(state.wornVertices.map(v => v.index));
            const planeNormal = state.transitionPlane.normal;
            const planeD = state.transitionPlane.d;
            const sphereCenter = state.unwornSphere.center;
            const sphereRadius = state.unwornSphere.radius;
            
            // Helper: Calculate signed distance from point to plane
            function distanceToPlane(point, planeNormal, planeD) {
                return point.dot(planeNormal) - planeD;
            }
            
            // Helper: Calculate signed tetrahedral volume
            function tetrahedronVolume(v0, v1, v2, v3) {
                const a = new THREE.Vector3().subVectors(v1, v0);
                const b = new THREE.Vector3().subVectors(v2, v0);
                const c = new THREE.Vector3().subVectors(v3, v0);
                const cross = new THREE.Vector3().crossVectors(b, c);
                return a.dot(cross) / 6.0;
            }
            
            // Helper: Project point onto sphere surface (radially)
            function projectToSphere(point, center, radius) {
                const dir = new THREE.Vector3().subVectors(point, center);
                const dist = dir.length();
                if (dist < 0.0001) {
                    // Point too close to center, return arbitrary point on sphere
                    return new THREE.Vector3(center.x + radius, center.y, center.z);
                }
                const normalized = dir.clone().divideScalar(dist);
                return new THREE.Vector3().addVectors(center, normalized.multiplyScalar(radius));
            }
            
            // VOLUMETRIC WEAR: Only in WORN zone
            // Volume = ∫(penetration · dA) over worn surface
            // This avoids floating-point cancellation by directly integrating penetration depth
            console.log('=== Calculating wear volume in WORN zone (penetration integral) ===');
            
            let volumetricWear = 0;
            let wornTriangleCount = 0;
            
            // Kahan summation for numerical stability
            let kahanC = 0;
            
            // Helper: Calculate triangle area
            function triangleArea(p1, p2, p3) {
                const v1 = new THREE.Vector3().subVectors(p2, p1);
                const v2 = new THREE.Vector3().subVectors(p3, p1);
                const cross = new THREE.Vector3().crossVectors(v1, v2);
                return cross.length() / 2.0;
            }
            
            // Process each triangle in the worn zone
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = (i / 3);
                const idx2 = (i / 3) + 1;
                const idx3 = (i / 3) + 2;
                
                // Check if triangle belongs to worn zone (at least 2 vertices worn)
                const v1Worn = wornVertexIndices.has(idx1);
                const v2Worn = wornVertexIndices.has(idx2);
                const v3Worn = wornVertexIndices.has(idx3);
                const wornCount = (v1Worn ? 1 : 0) + (v2Worn ? 1 : 0) + (v3Worn ? 1 : 0);
                
                if (wornCount < 2) continue; // Skip if not a worn triangle
                
                // Get real surface triangle vertices (from STL)
                const p1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                const p2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                const p3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                
                // Calculate penetration depth for each vertex (radial distance to sphere)
                // Penetration = sphere_radius - distance_to_center
                const pen1 = sphereRadius - p1.distanceTo(sphereCenter);
                const pen2 = sphereRadius - p2.distanceTo(sphereCenter);
                const pen3 = sphereRadius - p3.distanceTo(sphereCenter);
                
                // Average penetration over the triangle
                const avgPenetration = (pen1 + pen2 + pen3) / 3.0;
                
                // Only include triangles with positive average penetration (actually worn)
                if (avgPenetration <= 0) continue;
                
                // Calculate triangle area
                const area = triangleArea(p1, p2, p3);
                
                // Volume contribution = average_penetration × area
                const volumeContribution = avgPenetration * area;
                
                // Kahan summation to minimize floating-point error
                const y = volumeContribution - kahanC;
                const t = volumetricWear + y;
                kahanC = (t - volumetricWear) - y;
                volumetricWear = t;
                
                wornTriangleCount++;
            }
            
            console.log(`Processed ${wornTriangleCount} worn triangles`);
            console.log(`Volumetric wear (sphere to real surface in worn zone): ${volumetricWear.toFixed(4)} mm³`);
            
            // For backward compatibility with visualization code
            const volumePlaneToSurface = volumetricWear;
            const sphericalCapVolume = 0;
            
            console.log('=== FINAL RESULT ===');
            console.log(`Volumetric wear = ${volumePlaneToSurface.toFixed(4)} - ${sphericalCapVolume.toFixed(4)} = ${volumetricWear.toFixed(4)} mm³`);
            
            // LINEAR WEAR: Calculate PERPENDICULAR penetration depths (radial distance from ideal sphere)
            // CORRECTED: Only measure in the space between transition plane and real inner surface
            // This frames the measurement within the worn zone, from the plane to the inner face
            console.log('=== LINEAR WEAR (Perpendicular Penetration Depth - Framed by Transition Plane) ===');
            const penetrationDepths = [];
            let filteredWornCount = 0;
            let maxPenetrationVertex = null;
            let maxPenetrationValue = 0;
            
            state.wornVertices.forEach(v => {
                // Filter: Only include vertices on the WORN side of the transition plane
                // Worn side = negative distance to plane (towards inner surface)
                const distToTransitionPlane = distanceToPlane(v.pos, planeNormal, planeD);
                
                // Only measure vertices that are on the worn side (below/inside the transition plane)
                if (distToTransitionPlane <= 0) {
                    // Perpendicular distance from vertex to ideal unworn sphere surface (radial measurement)
                    // This is the shortest (perpendicular) distance from the sphere to the point
                    const distToCenter = v.pos.distanceTo(state.unwornSphere.center);
                    const penetration = state.unwornSphere.radius - distToCenter;
                    
                    // Only include positive penetrations (actual wear)
                    if (penetration > 0) {
                        penetrationDepths.push(penetration);
                        filteredWornCount++;
                        
                        // Track vertex with maximum penetration for visualization
                        if (penetration > maxPenetrationValue) {
                            maxPenetrationValue = penetration;
                            maxPenetrationVertex = v.pos.clone();
                        }
                    }
                }
            });
            
            console.log(`Filtered worn vertices within transition plane frame: ${filteredWornCount} / ${state.wornVertices.length}`);
            
            // Calculate statistics
            const meanPenetration = penetrationDepths.length > 0 
                ? penetrationDepths.reduce((a, b) => a + b, 0) / penetrationDepths.length 
                : 0;
            const maxPenetration = penetrationDepths.length > 0 
                ? Math.max(...penetrationDepths) 
                : 0;
            const minPenetration = penetrationDepths.length > 0 
                ? Math.min(...penetrationDepths) 
                : 0;
            
            console.log(`Mean perpendicular penetration: ${meanPenetration.toFixed(4)} mm`);
            console.log(`Max perpendicular penetration: ${maxPenetration.toFixed(4)} mm (deepest point)`);
            console.log(`Min perpendicular penetration: ${minPenetration.toFixed(4)} mm`);
            
            // Calculate areas for reference
            const wornArea = state.wornVertices.length * 0.1;
            const unwornArea = state.unwornVertices.length * 0.1;
            
            // VISUALIZATION: Add wear volume mesh to sphere viewer in BRIGHT ORANGE
            console.log('=== Creating wear volume visualization (bright orange) ===');
            
            // Create mesh showing the exact volume being calculated (worn surface below plane)
            const wearVolumePositions = [];
            const wearVolumeIndices = [];
            let vertexCount = 0;
            
            // Build geometry for worn triangles below the transition plane
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = (i / 3);
                const idx2 = (i / 3) + 1;
                const idx3 = (i / 3) + 2;
                
                const isWornFace = wornVertexIndices.has(idx1) || 
                                   wornVertexIndices.has(idx2) || 
                                   wornVertexIndices.has(idx3);
                
                if (!isWornFace) continue;
                
                const p1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                const p2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                const p3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                
                // Check if triangle is on the worn side
                const dist1 = distanceToPlane(p1, planeNormal, planeD);
                const dist2 = distanceToPlane(p2, planeNormal, planeD);
                const dist3 = distanceToPlane(p3, planeNormal, planeD);
                
                if (dist1 > 0 && dist2 > 0 && dist3 > 0) continue;
                
                // Add this worn triangle to the visualization
                wearVolumePositions.push(p1.x, p1.y, p1.z);
                wearVolumePositions.push(p2.x, p2.y, p2.z);
                wearVolumePositions.push(p3.x, p3.y, p3.z);
                wearVolumeIndices.push(vertexCount, vertexCount+1, vertexCount+2);
                vertexCount += 3;
            }
            
            if (wearVolumePositions.length > 0) {
                const wearVolumeGeom = new THREE.BufferGeometry();
                wearVolumeGeom.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(wearVolumePositions), 3));
                wearVolumeGeom.setIndex(wearVolumeIndices);
                wearVolumeGeom.computeVertexNormals();
                
                const wearVolumeMat = new THREE.MeshPhongMaterial({
                    color: 0xff6600,  // BRIGHT ORANGE for high visibility
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    emissive: 0xff3300,  // Add glow effect
                    emissiveIntensity: 0.3
                });
                
                const wearVolumeMesh = new THREE.Mesh(wearVolumeGeom, wearVolumeMat);
                sphereScene.add(wearVolumeMesh);
                
                console.log(`Wear volume visualization added: ${vertexCount} vertices, bright orange color`);
                console.log(`This shows the EXACT volume being calculated as volumetric wear`);
            }
            
            // VISUALIZATION: Add maximum linear wear line (from sphere surface to deepest worn point)
            // First, clean up any existing max wear line objects from previous runs
            if (state.maxWearLineObjects.length > 0) {
                state.maxWearLineObjects.forEach(obj => {
                    sphereScene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                state.maxWearLineObjects = [];
                console.log('Cleaned up previous max wear line visualization objects');
            }
            
            if (maxPenetrationVertex && maxPenetration > 0) {
                console.log('=== Adding maximum linear wear visualization ===');
                
                // Calculate the point on the fitted sphere surface (accurate radial projection)
                // Direction from sphere center to the deepest worn point
                const directionToVertex = new THREE.Vector3().subVectors(maxPenetrationVertex, state.unwornSphere.center);
                const normalizedDirection = directionToVertex.normalize();
                
                // Project onto fitted sphere surface using the unworn sphere's center and radius
                const sphereSurfacePoint = state.unwornSphere.center.clone().add(
                    normalizedDirection.clone().multiplyScalar(state.unwornSphere.radius)
                );
                
                // Create line geometry from sphere surface to worn surface
                const lineGeometry = new THREE.BufferGeometry();
                const linePositions = new Float32Array([
                    sphereSurfacePoint.x, sphereSurfacePoint.y, sphereSurfacePoint.z,
                    maxPenetrationVertex.x, maxPenetrationVertex.y, maxPenetrationVertex.z
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
                
                // Create bright cyan/magenta line material for high contrast
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,  // Bright magenta/purple for maximum visibility
                    linewidth: 5,  // Increased thickness for better visibility
                    opacity: 1.0,
                    transparent: false
                });
                
                const maxWearLine = new THREE.Line(lineGeometry, lineMaterial);
                sphereScene.add(maxWearLine);
                state.maxWearLineObjects.push(maxWearLine);  // Track for cleanup
                
                // Add sphere marker at the worn surface point (deepest point)
                // REDUCED SIZE: Much finer markers for sub-millimeter measurements (0.1-0.2mm typical)
                const wornPointMarkerGeom = new THREE.SphereGeometry(0.15, 12, 12);  // Reduced from 0.6 to 0.15
                const wornPointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,  // Match line color
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.6
                });
                const wornPointMarker = new THREE.Mesh(wornPointMarkerGeom, wornPointMarkerMat);
                wornPointMarker.position.copy(maxPenetrationVertex);
                sphereScene.add(wornPointMarker);
                state.maxWearLineObjects.push(wornPointMarker);  // Track for cleanup
                
                // Add sphere marker at the fitted sphere surface point (start of measurement)
                const spherePointMarkerGeom = new THREE.SphereGeometry(0.12, 12, 12);  // Reduced from 0.5 to 0.12
                const spherePointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,  // Bright cyan for distinction
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.6
                });
                const spherePointMarker = new THREE.Mesh(spherePointMarkerGeom, spherePointMarkerMat);
                spherePointMarker.position.copy(sphereSurfacePoint);
                sphereScene.add(spherePointMarker);
                state.maxWearLineObjects.push(spherePointMarker);  // Track for cleanup
                
                console.log(`Maximum linear wear line added:`);
                console.log(`  From fitted sphere surface: (${sphereSurfacePoint.x.toFixed(3)}, ${sphereSurfacePoint.y.toFixed(3)}, ${sphereSurfacePoint.z.toFixed(3)})`);
                console.log(`  To deepest worn point: (${maxPenetrationVertex.x.toFixed(3)}, ${maxPenetrationVertex.y.toFixed(3)}, ${maxPenetrationVertex.z.toFixed(3)})`);
                console.log(`  Penetration distance: ${maxPenetration.toFixed(4)} mm`);
                console.log(`  Line color: Bright magenta/purple | Markers: Magenta (worn) + Cyan (sphere)`);
            } else {
                console.log('No positive penetration detected, skipping maximum linear wear visualization');
                // Ensure array is cleared to avoid memory leaks when no new line is created
                state.maxWearLineObjects = [];
            }
            
            state.wearData = {
                volumetricWear: Math.max(0, volumetricWear),
                volumePlaneToSurface,
                sphericalCapVolume,
                linearWearMean: meanPenetration,
                linearWearMax: maxPenetration,
                linearWearMin: minPenetration,
                unwornSphereCenter: state.unwornSphere.center,
                unwornSphereRadius: state.unwornSphere.radius,
                transitionPlaneNormal: state.transitionPlane.normal,
                transitionPlaneD: state.transitionPlane.d,
                wornArea,
                unwornArea
            };
            
            // Update UI
            document.getElementById('metric-volume').textContent = volumetricWear.toFixed(4) + ' mm³';
            document.getElementById('metric-linear-mean').textContent = meanPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-max').textContent = maxPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-min').textContent = minPenetration.toFixed(4) + ' mm';
            document.getElementById('sphere-center').textContent = 
                `(${state.unwornSphere.center.x.toFixed(2)}, ${state.unwornSphere.center.y.toFixed(2)}, ${state.unwornSphere.center.z.toFixed(2)}) mm`;
            document.getElementById('sphere-radius').textContent = 
                `${state.unwornSphere.radius.toFixed(4)} mm`;
            document.getElementById('worn-area').textContent = wornArea.toFixed(2) + ' mm²';
            document.getElementById('unworn-area').textContent = unwornArea.toFixed(2) + ' mm²';
            
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('results-data').classList.remove('hidden');
            
            updateStatus('complete', 'Wear calculation complete');
            showLoading(false);
        });

        // Export CSV
        document.getElementById('btn-export-csv').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            const data = state.wearData;
            const csv = [
                'Metric,Value,Unit',
                `Volumetric Wear (plane-surface minus spherical-cap),${data.volumetricWear.toFixed(6)},mm³`,
                `Volume Plane to Surface,${data.volumePlaneToSurface.toFixed(6)},mm³`,
                `Volume Spherical Cap,${data.sphericalCapVolume.toFixed(6)},mm³`,
                `Linear Wear Mean Penetration,${data.linearWearMean.toFixed(6)},mm`,
                `Linear Wear Max Penetration,${data.linearWearMax.toFixed(6)},mm`,
                `Linear Wear Min Penetration,${data.linearWearMin.toFixed(6)},mm`,
                `Unworn Sphere Center X,${data.unwornSphereCenter.x.toFixed(6)},mm`,
                `Unworn Sphere Center Y,${data.unwornSphereCenter.y.toFixed(6)},mm`,
                `Unworn Sphere Center Z,${data.unwornSphereCenter.z.toFixed(6)},mm`,
                `Unworn Sphere Radius,${data.unwornSphereRadius.toFixed(6)},mm`,
                `Transition Plane Normal X,${data.transitionPlaneNormal.x.toFixed(6)},-`,
                `Transition Plane Normal Y,${data.transitionPlaneNormal.y.toFixed(6)},-`,
                `Transition Plane Normal Z,${data.transitionPlaneNormal.z.toFixed(6)},-`,
                `Transition Plane D,${data.transitionPlaneD.toFixed(6)},mm`,
                `Worn Zone Area,${data.wornArea.toFixed(4)},mm²`,
                `Unworn Zone Area,${data.unwornArea.toFixed(4)},mm²`
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acetabular_wear_analysis.csv';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Export PDF Report
        document.getElementById('btn-export-pdf').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            alert('PDF export requires jsPDF library. For now, please use the CSV export or take a screenshot of the results.');
        });
    </script>
</body>
</html>
