<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acetabular Wear Analysis System</title>
    <link rel="icon" type="image/png" href="attached_assets/favicon_1763986228549.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.05), transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(124, 58, 237, 0.05), transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(59, 130, 246, 0.05), transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            max-width: 1920px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        #viewer-container {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #sphere-viewer-container {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel {
            background: #ffffff;
            border-radius: 20px;
            padding: 28px;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(226, 232, 240, 0.8);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 30px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 
                0 10px 30px rgba(102, 126, 234, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
        }
        
        .metric-card:hover::before {
            opacity: 1;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 15px rgba(102, 126, 234, 0.4),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }
        
        .btn-primary:hover::before {
            left: 100%;
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            padding: 14px 28px;
            border-radius: 12px;
            border: 2px solid #667eea;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }
        
        .btn-secondary:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px currentColor;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .status-ready { background: #48bb78; box-shadow: 0 0 15px #48bb78; }
        .status-processing { background: #ed8936; box-shadow: 0 0 15px #ed8936; }
        .status-complete { background: #4299e1; box-shadow: 0 0 15px #4299e1; }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            background: rgba(102, 126, 234, 0.05);
            transform: translateX(4px);
        }
        
        .legend-color {
            width: 36px;
            height: 24px;
            border-radius: 6px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .loading-overlay::after {
            content: '';
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .hidden { display: none; }
        
        h1 {
            color: #0f172a;
            font-weight: 800;
        }
        
        h2 {
            color: #1e293b;
            font-weight: 700;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        input[type="file"] {
            padding: 12px;
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            transition: all 0.3s ease;
            background: #f8fafc;
            color: #475569;
        }
        
        input[type="file"]:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }
        
        p {
            color: #64748b;
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-6">
        <!-- Header -->
        <div class="panel mb-6 fade-in">
            <div class="flex items-center gap-4 mb-3">
                <svg class="w-12 h-12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" fill="url(#grad1)"/>
                    <circle cx="12" cy="12" r="4" fill="url(#grad1)" opacity="0.6"/>
                </svg>
                <div>
                    <h1 class="text-4xl font-bold mb-1">Acetabular Wear Analysis System</h1>
                    <p class="text-lg" style="color: #64748b;">Professional volumetric and linear wear measurement for hip prosthesis components</p>
                </div>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Panel: Controls -->
            <div class="lg:col-span-1">
                <div class="panel mb-6 fade-in" style="animation-delay: 0.1s;">
                    <h2 class="text-2xl font-bold mb-4">
                        <span class="flex items-center gap-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <defs>
                                    <linearGradient id="grad2" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <path stroke="url(#grad2)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            File Upload
                        </span>
                    </h2>
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2" style="color: #475569;">
                            Upload STL File
                        </label>
                        <input type="file" id="file-input" accept=".stl" class="w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                    <div class="text-sm mb-4 flex items-center" style="color: #64748b;">
                        <span class="status-indicator status-ready" id="status-indicator"></span>
                        <span id="status-text">Ready to load file</span>
                    </div>
                </div>

                <div class="panel mb-6 fade-in" style="animation-delay: 0.2s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Pipeline</h2>
                    <div class="space-y-3">
                        <button id="btn-isolate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"/>
                            </svg>
                            <span>1. Isolate Inner Surface</span>
                        </button>
                        <button id="btn-detect-wear" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                            </svg>
                            <span>2. Detect Wear Zones</span>
                        </button>
                        <button id="btn-fit-sphere" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                            </svg>
                            <span>3. Fit Reference Sphere</span>
                        </button>
                        <button id="btn-calculate" class="btn-primary w-full flex items-center justify-center gap-2" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                            </svg>
                            <span>4. Calculate Wear</span>
                        </button>
                    </div>
                    
                    <!-- Analysis Options -->
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h3 class="text-sm font-semibold mb-2 text-gray-700">Surface Shape</h3>
                        <select id="fitting-shape" class="w-full p-2 border border-gray-300 rounded-lg text-sm mb-3">
                            <option value="sphere">Spherical (4 params: cx, cy, cz, r)</option>
                            <option value="ellipsoid">Ellipsoidal (6 params: cx, cy, cz, rx, ry, rz)</option>
                        </select>
                        
                        <h3 class="text-sm font-semibold mb-2 text-gray-700">Optimization Method</h3>
                        <select id="fitting-method" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                            <option value="gauss-newton">Gauss-Newton + LM (Fast)</option>
                            <option value="ransac">RANSAC + LM (Robust)</option>
                        </select>
                        
                        <h3 class="text-sm font-semibold mb-2 mt-3 text-gray-700">Visualization</h3>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="show-inflection-markers" class="rounded">
                            <span>Show inflection point markers</span>
                        </label>
                    </div>
                </div>

                <div class="panel fade-in" style="animation-delay: 0.3s;">
                    <h2 class="text-2xl font-bold mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <defs>
                                <linearGradient id="grad3" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <path stroke="url(#grad3)" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                        </svg>
                        Legend
                    </h2>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4299e1;"></div>
                        <span>Original Component</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span><strong>Unworn Zone</strong> (furthest from prosthesis)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f56565;"></div>
                        <span><strong>Worn Zone</strong> (closest to prosthesis)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: transparent; border: 1px solid #ffff00; position: relative; overflow: hidden;">
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 5px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 9px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 13px;"></div>
                            <div style="position: absolute; width: 100%; height: 1px; background: #ffff00; top: 17px;"></div>
                        </div>
                        <span>Fitted Reference Sphere (yellow wireframe)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6600;"></div>
                        <span><strong>Volumetric Wear Zone</strong> (orange highlight)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ffff 0%, #ff00ff 50%, #ff00ff 100%);"></div>
                        <span><strong>Max Linear Wear</strong> (cyan→magenta line)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffff00; box-shadow: 0 0 10px rgba(255, 255, 0, 0.6);"></div>
                        <span><strong>Inflection Markers</strong> (yellow spheres, transition zone)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ffff; border-radius: 50%; width: 20px; height: 20px; box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);"></div>
                        <span style="margin-left: 8px;"><strong>Sphere Surface Point</strong> (cyan marker)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff00ff; border-radius: 50%; width: 20px; height: 20px; box-shadow: 0 0 8px rgba(255, 0, 255, 0.6);"></div>
                        <span style="margin-left: 8px;"><strong>Deepest Worn Point</strong> (magenta marker)</span>
                    </div>
                    <div class="mt-4 p-4 rounded-xl text-sm" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(124, 58, 237, 0.08) 100%); border: 1px solid rgba(102, 126, 234, 0.15); color: #475569;">
                        <p class="font-semibold mb-2 flex items-center gap-2">
                            <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            Important:
                        </p>
                        <p class="mb-1"><strong class="text-red-600">Worn zone</strong> = inner surface closest to femoral head (where contact occurs)</p>
                        <p class="mb-1"><strong class="text-green-600">Unworn zone</strong> = outer edges furthest from contact point</p>
                        <p class="text-xs mt-2" style="color: #64748b;"><strong>Sphere Viewer:</strong> Orange area shows volumetric wear volume. Cyan-to-magenta line marks maximum penetration depth with fine markers.</p>
                    </div>
                </div>
            </div>

            <!-- Middle/Right Panel: 3D Viewers -->
            <div class="lg:col-span-2">
                <!-- Main Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.4s;">
                    <h2 class="text-2xl font-bold mb-4">3D Model Viewer</h2>
                    <div id="viewer-container">
                        <div id="loading-overlay" class="loading-overlay hidden">
                            <div>Processing...</div>
                        </div>
                    </div>
                    <div class="mt-4 text-sm" style="color: #64748b;">
                        <p><strong style="color: #475569;">Controls:</strong> Left click + drag to rotate | Right click + drag to pan | Scroll to zoom</p>
                    </div>
                </div>

                <!-- Sphere Viewer -->
                <div class="panel mb-6 fade-in" style="animation-delay: 0.5s;">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Reference Sphere Visualization</h2>
                        <button id="btn-download-sphere-view" class="btn-secondary hidden" title="Download sphere visualization elements (STL, sphere, plane, inflection points)">
                            Download Elements
                        </button>
                    </div>
                    <div id="sphere-viewer-container">
                        <div id="sphere-loading-overlay" class="loading-overlay">
                            <div>Waiting for analysis...</div>
                        </div>
                    </div>
                </div>

                <!-- Results Panel -->
                <div class="panel fade-in" style="animation-delay: 0.6s;">
                    <h2 class="text-2xl font-bold mb-4">Analysis Results</h2>
                    <div id="results-container">
                        <div class="text-center py-8" style="color: #94a3b8;">
                            No analysis completed yet. Upload an STL file and run the analysis pipeline.
                        </div>
                    </div>
                    <div id="results-data" class="hidden">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Volumetric Wear</div>
                                <div class="text-3xl font-bold" id="metric-volume">0.00 mm³</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Mean Linear Wear</div>
                                <div class="text-3xl font-bold" id="metric-linear-mean">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Maximum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-max">0.00 mm</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-80 mb-1">Minimum Penetration</div>
                                <div class="text-3xl font-bold" id="metric-linear-min">0.00 mm</div>
                            </div>
                        </div>
                        <div class="space-y-2 mb-4">
                            <p><strong>Reference Sphere Center:</strong> <span id="sphere-center">-</span></p>
                            <p><strong>Reference Sphere Radius:</strong> <span id="sphere-radius">-</span></p>
                            <p><strong>Worn Zone Area:</strong> <span id="worn-area">-</span></p>
                            <p><strong>Unworn Zone Area:</strong> <span id="unworn-area">-</span></p>
                        </div>
                        
                        <!-- Quality Diagnostics Panel -->
                        <div id="quality-diagnostics" class="hidden mb-4 p-4 rounded-xl" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(124, 58, 237, 0.08) 100%); border: 1px solid rgba(102, 126, 234, 0.15);">
                            <h3 class="font-bold mb-3 text-lg">Quality Diagnostics</h3>
                            <div class="space-y-2 text-sm">
                                <p><strong>Fitting Method:</strong> <span id="diag-method">-</span></p>
                                <p><strong>RMS Error:</strong> <span id="diag-rms">-</span> mm</p>
                                <p><strong>Iterations:</strong> <span id="diag-iterations">-</span></p>
                                <p><strong>Inlier Count:</strong> <span id="diag-inliers">-</span></p>
                                <p><strong>Residual Range:</strong> <span id="diag-residual-range">-</span> mm</p>
                                <p><strong>Convergence:</strong> <span id="diag-convergence">-</span></p>
                                <p><strong>Unworn Area Match:</strong> <span id="diag-unworn-match">-</span></p>
                                <p id="diag-sphericity-container" class="hidden"><strong>Sphericity:</strong> <span id="diag-sphericity">-</span>%</p>
                                <p id="diag-ellipsoidality-container" class="hidden"><strong>Ellipsoidality:</strong> <span id="diag-ellipsoidality">-</span>%</p>
                                <p id="diag-radii-container" class="hidden"><strong>Semi-axes (rx, ry, rz):</strong> <span id="diag-radii">-</span> mm</p>
                            </div>
                        </div>
                        
                        <div class="flex gap-3 flex-wrap">
                            <button id="btn-export-csv" class="btn-secondary">Export CSV</button>
                            <button id="btn-export-json" class="btn-secondary">Export JSON</button>
                            <button id="btn-export-pdf" class="btn-secondary">Export PDF Report</button>
                            <button id="btn-export-html" class="btn-secondary">Export Interactive HTML</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        // ========================================
        // APPLICATION STATE
        // ========================================
        const state = {
            geometry: null,
            mesh: null,
            innerSurfaceVertices: [],
            wornVertices: [],
            unwornVertices: [],
            inflectionPoints: [],  // NEW: Detected inflection/boundary points
            inflectionMarkers: [],  // NEW: Interactive 3D markers
            referenceSphere: null,
            unwornSphere: null,
            transitionPlane: null,
            wearData: null,
            fittingDiagnostics: null,  // NEW: Quality diagnostics
            octree: null,  // NEW: Spatial optimization structure
            maxWearLineObjects: []
        };

        // ========================================
        // MODULE: GEOMETRY SERVICE
        // ========================================
        const GeometryService = {
            // Build vertex adjacency (1-ring neighborhood)
            buildAdjacency(vertices, faces) {
                const adjacency = new Map();
                vertices.forEach(v => adjacency.set(v.index, new Set()));
                
                faces.forEach(face => {
                    const [i1, i2, i3] = face.indices;
                    if (adjacency.has(i1)) {
                        adjacency.get(i1).add(i2);
                        adjacency.get(i1).add(i3);
                    }
                    if (adjacency.has(i2)) {
                        adjacency.get(i2).add(i1);
                        adjacency.get(i2).add(i3);
                    }
                    if (adjacency.has(i3)) {
                        adjacency.get(i3).add(i1);
                        adjacency.get(i3).add(i2);
                    }
                });
                
                return adjacency;
            },
            
            // Calculate triangle area using Heron's formula
            triangleArea(p1, p2, p3) {
                const a = p1.distanceTo(p2);
                const b = p2.distanceTo(p3);
                const c = p3.distanceTo(p1);
                const s = (a + b + c) / 2;
                return Math.sqrt(Math.max(0, s * (s - a) * (s - b) * (s - c)));
            },
            
            // Calculate angle between two vectors
            angleBetween(v1, v2) {
                const dot = v1.dot(v2);
                const lengths = v1.length() * v2.length();
                if (lengths < 1e-10) return 0;
                return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
            }
        };

        // ========================================
        // MODULE: CURVATURE ANALYZER
        // ========================================
        const CurvatureAnalyzer = {
            // Calculate Gaussian curvature using Meyer et al. 2003
            calculateGaussianCurvature(vertexIdx, vertexPos, adjacentFaces) {
                if (!adjacentFaces || adjacentFaces.length === 0) return 0;
                
                // Meyer 2003: K = (2π - Σθⱼ) / A_mixed
                let angleSum = 0;
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    angleSum += GeometryService.angleBetween(e1, e2);
                });
                
                const mixedArea = this.calculateMixedArea(vertexIdx, vertexPos, adjacentFaces);
                return (2 * Math.PI - angleSum) / mixedArea;
            },
            
            // Calculate mixed Voronoi area (Meyer 2003)
            calculateMixedArea(vertexIdx, vertexPos, adjacentFaces) {
                let mixedArea = 0;
                
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    const triangleArea = 0.5 * new THREE.Vector3().crossVectors(e1, e2).length();
                    
                    const angle0 = GeometryService.angleBetween(e1, e2);
                    const e1neg = e1.clone().negate();
                    const e12 = new THREE.Vector3().subVectors(v2, v1);
                    const angle1 = GeometryService.angleBetween(e1neg, e12);
                    const e2neg = e2.clone().negate();
                    const e21 = new THREE.Vector3().subVectors(v1, v2);
                    const angle2 = GeometryService.angleBetween(e2neg, e21);
                    
                    // Meyer 2003: Different area calc based on triangle type
                    if (angle0 > Math.PI / 2) {
                        mixedArea += triangleArea / 2;
                    } else if (angle1 > Math.PI / 2 || angle2 > Math.PI / 2) {
                        mixedArea += triangleArea / 4;
                    } else {
                        mixedArea += triangleArea / 3;
                    }
                });
                
                return Math.max(mixedArea, 1e-10);
            }
        };

        // ========================================
        // MODULE: PCA SERVICE
        // ========================================
        const PCAService = {
            // Compute PCA-based plane from point cloud
            computePlane(points, weights = null) {
                if (points.length < 3) {
                    console.warn('PCA: Less than 3 points, using fallback');
                    return null;
                }
                
                // Calculate weighted centroid
                // OPTIMIZED: Use for-loop for large point arrays
                const centroid = new THREE.Vector3();
                let totalWeight = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const w = weights ? weights[i] : 1.0;
                    centroid.x += p.x * w;
                    centroid.y += p.y * w;
                    centroid.z += p.z * w;
                    totalWeight += w;
                }
                centroid.divideScalar(totalWeight);
                
                // Build covariance matrix
                // OPTIMIZED: Use for-loop for large point arrays
                let xx = 0, xy = 0, xz = 0;
                let yy = 0, yz = 0, zz = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const w = weights ? weights[i] : 1.0;
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dz = p.z - centroid.z;
                    
                    xx += w * dx * dx;
                    xy += w * dx * dy;
                    xz += w * dx * dz;
                    yy += w * dy * dy;
                    yz += w * dy * dz;
                    zz += w * dz * dz;
                }
                
                // Normalize
                xx /= totalWeight;
                xy /= totalWeight;
                xz /= totalWeight;
                yy /= totalWeight;
                yz /= totalWeight;
                zz /= totalWeight;
                
                // Find the eigenvector corresponding to the SMALLEST eigenvalue
                // This is the normal direction to the best-fit plane (minimum variance direction)
                // Method: Analytic solution for 3x3 symmetric matrix eigenvalues + iterative eigenvector
                
                // Solve characteristic equation det(C - λI) = 0 for 3x3 symmetric matrix
                // λ³ - I₁λ² + I₂λ - I₃ = 0
                // where I₁ = trace, I₂ = sum of principal minors, I₃ = determinant
                
                const I1 = xx + yy + zz;  // trace
                const I2 = xx*yy + yy*zz + xx*zz - xy*xy - yz*yz - xz*xz;  // sum of 2x2 principal minors
                const I3 = xx*yy*zz + 2*xy*yz*xz - xx*yz*yz - yy*xz*xz - zz*xy*xy;  // determinant
                
                // Use Cardano's method to solve cubic: t³ + pt + q = 0 (after depressing)
                // Substitution: λ = t + I₁/3
                const p = I2 - I1*I1/3;
                const q = 2*I1*I1*I1/27 - I1*I2/3 + I3;
                
                const discriminant = q*q/4 + p*p*p/27;
                
                let eigenvalues = [];
                if (Math.abs(discriminant) < 1e-10 || discriminant >= 0) {
                    // One real root or three real roots with discriminant ~0
                    // Use trigonometric solution for real roots
                    const r = Math.sqrt(-p/3);
                    const theta = Math.acos(-q / (2 * r * r * r)) / 3;
                    eigenvalues = [
                        2 * r * Math.cos(theta) + I1/3,
                        2 * r * Math.cos(theta + 2*Math.PI/3) + I1/3,
                        2 * r * Math.cos(theta + 4*Math.PI/3) + I1/3
                    ];
                } else {
                    // Three distinct real roots
                    const r = Math.sqrt(-p/3);
                    const theta = Math.acos(-q / (2 * r * r * r)) / 3;
                    eigenvalues = [
                        2 * r * Math.cos(theta) + I1/3,
                        2 * r * Math.cos(theta + 2*Math.PI/3) + I1/3,
                        2 * r * Math.cos(theta + 4*Math.PI/3) + I1/3
                    ];
                }
                
                // Sort eigenvalues to find the smallest
                eigenvalues.sort((a, b) => a - b);
                const lambda_min = eigenvalues[0];
                
                console.log(`PCA eigenvalues: [${eigenvalues[0].toFixed(6)}, ${eigenvalues[1].toFixed(6)}, ${eigenvalues[2].toFixed(6)}]`);
                
                // Find eigenvector for λ_min by solving (C - λ_min·I)v = 0
                // Use null space computation via cross products of rows
                const A11 = xx - lambda_min;
                const A12 = xy;
                const A13 = xz;
                const A22 = yy - lambda_min;
                const A23 = yz;
                const A33 = zz - lambda_min;
                
                const row0 = new THREE.Vector3(A11, A12, A13);
                const row1 = new THREE.Vector3(A12, A22, A23);
                const row2 = new THREE.Vector3(A13, A23, A33);
                
                // Cross products of rows give vectors in the null space
                const n0 = new THREE.Vector3().crossVectors(row0, row1);
                const n1 = new THREE.Vector3().crossVectors(row1, row2);
                const n2 = new THREE.Vector3().crossVectors(row2, row0);
                
                // Choose the one with largest magnitude (most stable)
                let normal;
                const len0 = n0.length();
                const len1 = n1.length();
                const len2 = n2.length();
                
                if (len0 >= len1 && len0 >= len2 && len0 > 1e-10) {
                    normal = n0.normalize();
                } else if (len1 >= len2 && len1 > 1e-10) {
                    normal = n1.normalize();
                } else if (len2 > 1e-10) {
                    normal = n2.normalize();
                } else {
                    // Degenerate case: use axis with smallest diagonal element
                    console.warn('PCA: Degenerate covariance matrix, using fallback normal');
                    if (xx <= yy && xx <= zz) {
                        normal = new THREE.Vector3(1, 0, 0);
                    } else if (yy <= zz) {
                        normal = new THREE.Vector3(0, 1, 0);
                    } else {
                        normal = new THREE.Vector3(0, 0, 1);
                    }
                }
                
                // Ensure normal points away from sphere center if available
                // (this ensures consistent orientation)
                if (state.unwornSphere && state.unwornSphere.center) {
                    const toSphere = new THREE.Vector3().subVectors(state.unwornSphere.center, centroid);
                    if (normal.dot(toSphere) < 0) {
                        normal.negate();
                    }
                }
                
                // Plane equation: normal · (p - centroid) = 0
                // Or: normal · p = d, where d = normal · centroid
                const d = normal.dot(centroid);
                
                console.log(`PCA plane calculated: normal=(${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}), centroid=(${centroid.x.toFixed(4)}, ${centroid.y.toFixed(4)}, ${centroid.z.toFixed(4)})`);
                
                return { normal, d, centroid };
            }
        };

        // ========================================
        // MODULE: FITTING SERVICE
        // ========================================
        const FittingService = {
            // Fit sphere using Gauss-Newton with LM damping
            fitSphereGaussNewton(vertices) {
                // Initialize center (geometric centroid)
                let center = new THREE.Vector3();
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Initialize radius
                let radius = 0;
                vertices.forEach(p => radius += p.distanceTo(center));
                radius /= vertices.length;
                
                const maxIterations = 20;
                const tolerance = 1e-6;
                let lambda = 0.001;
                let prevResidual = Infinity;
                let iterations = 0;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    iterations++;
                    const n = vertices.length;
                    const J = [];
                    const residuals = [];
                    let residualSum = 0;
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        const residual = dist - radius;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        if (dist > 1e-10) {
                            J.push([-dx/dist, -dy/dist, -dz/dist, -1]);
                        } else {
                            J.push([0, 0, 0, -1]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        break;
                    }
                    
                    // Compute J^T * J
                    const JTJ = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add LM damping
                    for (let i = 0; i < 4; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r
                    const JTr = [0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    const delta = this.solveLinearSystem4x4(JTJ, JTr.map(x => -x));
                    if (!delta) {
                        lambda *= 10;
                        continue;
                    }
                    
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadius = radius + delta[3];
                    
                    if (newRadius > 0) {
                        center = newCenter;
                        radius = newRadius;
                        lambda *= 0.1;
                    } else {
                        lambda *= 10;
                    }
                    
                    prevResidual = currentResidual;
                }
                
                // Calculate final diagnostics
                const residuals = [];
                let rmsError = 0;
                vertices.forEach(p => {
                    const dist = p.distanceTo(center);
                    const residual = Math.abs(dist - radius);
                    residuals.push(residual);
                    rmsError += residual * residual;
                });
                rmsError = Math.sqrt(rmsError / vertices.length);
                
                return {
                    center,
                    radius,
                    method: 'Gauss-Newton + LM',
                    iterations,
                    rmsError,
                    residuals,
                    inliers: vertices.length
                };
            },
            
            // Fit sphere using RANSAC + LM refinement
            fitSphereRANSAC(vertices) {
                const maxIterations = 100;
                // FIXED: Threshold must match typical acetabular cup scale (30-50mm radius)
                // Use 1.5mm tolerance (about 3-5% of radius) instead of 0.5mm
                const threshold = 1.5;  // mm tolerance for inliers
                const minSampleSize = Math.min(20, Math.floor(vertices.length * 0.1));
                
                let bestFit = null;
                let bestInlierCount = 0;
                let bestInliers = [];  // FIXED: Initialize bestInliers array
                
                console.log(`RANSAC: Starting with ${vertices.length} points, ${maxIterations} iterations, threshold=${threshold}mm`);
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Random sample
                    const sample = [];
                    const usedIndices = new Set();
                    while (sample.length < minSampleSize && usedIndices.size < vertices.length) {
                        const idx = Math.floor(Math.random() * vertices.length);
                        if (!usedIndices.has(idx)) {
                            sample.push(vertices[idx]);
                            usedIndices.add(idx);
                        }
                    }
                    
                    if (sample.length < 4) continue;  // Need at least 4 points
                    
                    // Fit to sample
                    const fit = this.fitSphereGaussNewton(sample);
                    
                    // Count inliers
                    const inliers = [];
                    vertices.forEach(p => {
                        const dist = p.distanceTo(fit.center);
                        const residual = Math.abs(dist - fit.radius);
                        if (residual < threshold) {
                            inliers.push(p);
                        }
                    });
                    
                    // FIXED: Proper comparison and storage
                    if (inliers.length > bestInlierCount) {
                        bestInlierCount = inliers.length;
                        bestFit = fit;
                        bestInliers = inliers;
                    }
                }
                
                console.log(`RANSAC: Best consensus has ${bestInlierCount} inliers (${(bestInlierCount/vertices.length*100).toFixed(1)}%)`);
                
                // FIXED: Guard against failure cases
                if (bestInliers.length < minSampleSize) {
                    console.warn(`RANSAC failed to find consensus, falling back to Gauss-Newton on all points`);
                    return this.fitSphereGaussNewton(vertices);
                }
                
                // Refine with all inliers
                const refinedFit = this.fitSphereGaussNewton(bestInliers);
                refinedFit.method = 'RANSAC + LM';
                refinedFit.inliers = bestInlierCount;
                return refinedFit;
            },
            
            // Solve 4x4 linear system using Gaussian elimination
            solveLinearSystem4x4(A, b) {
                // Create augmented matrix [A|b]
                const aug = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination
                for (let i = 0; i < 4; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < 4; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    // Check for singular matrix
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    // Eliminate
                    for (let k = i + 1; k < 4; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j < 5; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                // Back substitution
                const x = [0, 0, 0, 0];
                for (let i = 3; i >= 0; i--) {
                    x[i] = aug[i][4];
                    for (let j = i + 1; j < 4; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            },
            
            // Solve 6x6 linear system using Gaussian elimination (for ellipsoid fitting)
            solveLinearSystem6x6(A, b) {
                const aug = A.map((row, i) => [...row, b[i]]);
                
                for (let i = 0; i < 6; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < 6; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    for (let k = i + 1; k < 6; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j < 7; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                const x = [0, 0, 0, 0, 0, 0];
                for (let i = 5; i >= 0; i--) {
                    x[i] = aug[i][6];
                    for (let j = i + 1; j < 6; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            },
            
            // Fit ellipsoid using Gauss-Newton with LM damping
            // Parameters: center (cx, cy, cz) + semi-axes (rx, ry, rz)
            // Ellipsoid equation: (x-cx)²/rx² + (y-cy)²/ry² + (z-cz)²/rz² = 1
            fitEllipsoidGaussNewton(vertices) {
                // Initialize center (geometric centroid)
                let center = new THREE.Vector3();
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Initialize radii from PCA of point cloud
                const centered = vertices.map(p => new THREE.Vector3(p.x - center.x, p.y - center.y, p.z - center.z));
                
                // Simple PCA: compute variance along each axis
                let vx = 0, vy = 0, vz = 0;
                centered.forEach(p => {
                    vx += p.x * p.x;
                    vy += p.y * p.y;
                    vz += p.z * p.z;
                });
                vx = Math.sqrt(vx / vertices.length);
                vy = Math.sqrt(vy / vertices.length);
                vz = Math.sqrt(vz / vertices.length);
                
                let radii = { x: vx, y: vy, z: vz };
                
                const maxIterations = 30;
                const tolerance = 1e-6;
                let lambda = 0.001;
                let prevResidual = Infinity;
                let iterations = 0;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    iterations++;
                    const n = vertices.length;
                    const J = [];
                    const residuals = [];
                    let residualSum = 0;
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        
                        // Ellipsoid distance: f(p) = sqrt((dx/rx)² + (dy/ry)² + (dz/rz)²) - 1
                        const term_x = dx / radii.x;
                        const term_y = dy / radii.y;
                        const term_z = dz / radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const residual = f - 1.0;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        // Jacobian: ∂f/∂params
                        // params = [cx, cy, cz, rx, ry, rz]
                        if (f > 1e-10) {
                            const df_dcx = -term_x / (radii.x * f);
                            const df_dcy = -term_y / (radii.y * f);
                            const df_dcz = -term_z / (radii.z * f);
                            const df_drx = -dx * term_x / (radii.x * radii.x * f);
                            const df_dry = -dy * term_y / (radii.y * radii.y * f);
                            const df_drz = -dz * term_z / (radii.z * radii.z * f);
                            
                            J.push([df_dcx, df_dcy, df_dcz, df_drx, df_dry, df_drz]);
                        } else {
                            J.push([0, 0, 0, 0, 0, 0]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        break;
                    }
                    
                    // Compute J^T * J
                    const JTJ = [];
                    for (let i = 0; i < 6; i++) {
                        JTJ[i] = [];
                        for (let j = 0; j < 6; j++) {
                            JTJ[i][j] = 0;
                        }
                    }
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 6; j++) {
                            for (let k = 0; k < 6; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add LM damping
                    for (let i = 0; i < 6; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r
                    const JTr = [0, 0, 0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 6; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    const delta = this.solveLinearSystem6x6(JTJ, JTr.map(x => -x));
                    if (!delta) {
                        lambda *= 10;
                        continue;
                    }
                    
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadii = {
                        x: radii.x + delta[3],
                        y: radii.y + delta[4],
                        z: radii.z + delta[5]
                    };
                    
                    if (newRadii.x > 0 && newRadii.y > 0 && newRadii.z > 0) {
                        center = newCenter;
                        radii = newRadii;
                        lambda *= 0.1;
                    } else {
                        lambda *= 10;
                    }
                    
                    prevResidual = currentResidual;
                }
                
                // Calculate final diagnostics
                const finalResiduals = [];
                let rmsError = 0;
                vertices.forEach(p => {
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    const dz = p.z - center.z;
                    const term_x = dx / radii.x;
                    const term_y = dy / radii.y;
                    const term_z = dz / radii.z;
                    const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                    const residual = Math.abs(f - 1.0);
                    finalResiduals.push(residual);
                    rmsError += residual * residual;
                });
                rmsError = Math.sqrt(rmsError / vertices.length);
                
                // Calculate sphericity index (how close to a perfect sphere)
                const avgRadius = (radii.x + radii.y + radii.z) / 3;
                const minRadius = Math.min(radii.x, radii.y, radii.z);
                const maxRadius = Math.max(radii.x, radii.y, radii.z);
                const sphericity = minRadius / maxRadius; // 1.0 = perfect sphere, <1.0 = ellipsoidal
                const sphericityPercent = sphericity * 100;
                const ellipsoidalityPercent = (1 - sphericity) * 100;
                
                return {
                    center,
                    radii,
                    radius: avgRadius,
                    method: 'Ellipsoid Gauss-Newton + LM',
                    iterations,
                    rmsError,
                    residuals: finalResiduals,
                    inliers: vertices.length,
                    sphericity,
                    sphericityPercent,
                    ellipsoidalityPercent,
                    isEllipsoid: true
                };
            },
            
            // Fit ellipsoid using RANSAC + LM refinement
            fitEllipsoidRANSAC(vertices) {
                const maxIterations = 100;
                const threshold = 1.5;
                const minSampleSize = Math.min(30, Math.floor(vertices.length * 0.1));
                
                let bestFit = null;
                let bestInlierCount = 0;
                let bestInliers = [];
                
                console.log(`RANSAC Ellipsoid: Starting with ${vertices.length} points, ${maxIterations} iterations`);
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    const sample = [];
                    const usedIndices = new Set();
                    while (sample.length < minSampleSize && usedIndices.size < vertices.length) {
                        const idx = Math.floor(Math.random() * vertices.length);
                        if (!usedIndices.has(idx)) {
                            sample.push(vertices[idx]);
                            usedIndices.add(idx);
                        }
                    }
                    
                    if (sample.length < 6) continue;
                    
                    const fit = this.fitEllipsoidGaussNewton(sample);
                    
                    const inliers = [];
                    vertices.forEach(p => {
                        const dx = p.x - fit.center.x;
                        const dy = p.y - fit.center.y;
                        const dz = p.z - fit.center.z;
                        const term_x = dx / fit.radii.x;
                        const term_y = dy / fit.radii.y;
                        const term_z = dz / fit.radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const residual = Math.abs(f - 1.0);
                        if (residual < threshold) {
                            inliers.push(p);
                        }
                    });
                    
                    if (inliers.length > bestInlierCount) {
                        bestInlierCount = inliers.length;
                        bestFit = fit;
                        bestInliers = inliers;
                    }
                }
                
                console.log(`RANSAC Ellipsoid: Best consensus has ${bestInlierCount} inliers (${(bestInlierCount/vertices.length*100).toFixed(1)}%)`);
                
                if (bestInliers.length < minSampleSize) {
                    console.warn(`RANSAC Ellipsoid failed, falling back to Gauss-Newton`);
                    return this.fitEllipsoidGaussNewton(vertices);
                }
                
                const refinedFit = this.fitEllipsoidGaussNewton(bestInliers);
                refinedFit.method = 'Ellipsoid RANSAC + LM';
                refinedFit.inliers = bestInlierCount;
                return refinedFit;
            }
        };

        // Initialize Main Viewer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('viewer-container').clientWidth / 
            document.getElementById('viewer-container').clientHeight,
            0.1,
            1000
        );
        camera.position.set(50, 50, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(
            document.getElementById('viewer-container').clientWidth,
            document.getElementById('viewer-container').clientHeight
        );
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(50, 50, 50);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-50, -50, -50);
        scene.add(directionalLight2);

        // Initialize Sphere Viewer
        const sphereScene = new THREE.Scene();
        sphereScene.background = new THREE.Color(0x1a202c);
        
        const sphereCamera = new THREE.PerspectiveCamera(
            75,
            document.getElementById('sphere-viewer-container').clientWidth / 
            document.getElementById('sphere-viewer-container').clientHeight,
            0.1,
            1000
        );
        sphereCamera.position.set(50, 50, 50);

        const sphereRenderer = new THREE.WebGLRenderer({ antialias: true });
        sphereRenderer.setSize(
            document.getElementById('sphere-viewer-container').clientWidth,
            document.getElementById('sphere-viewer-container').clientHeight
        );
        document.getElementById('sphere-viewer-container').appendChild(sphereRenderer.domElement);

        const sphereControls = new OrbitControls(sphereCamera, sphereRenderer.domElement);
        sphereControls.enableDamping = true;
        sphereControls.dampingFactor = 0.05;

        // Lighting for sphere viewer
        const sphereAmbientLight = new THREE.AmbientLight(0xffffff, 0.6);
        sphereScene.add(sphereAmbientLight);

        const sphereDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sphereDirectionalLight.position.set(50, 50, 50);
        sphereScene.add(sphereDirectionalLight);

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            sphereControls.update();
            renderer.render(scene, camera);
            sphereRenderer.render(sphereScene, sphereCamera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            const viewerWidth = document.getElementById('viewer-container').clientWidth;
            const viewerHeight = document.getElementById('viewer-container').clientHeight;
            camera.aspect = viewerWidth / viewerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerWidth, viewerHeight);

            const sphereViewerWidth = document.getElementById('sphere-viewer-container').clientWidth;
            const sphereViewerHeight = document.getElementById('sphere-viewer-container').clientHeight;
            sphereCamera.aspect = sphereViewerWidth / sphereViewerHeight;
            sphereCamera.updateProjectionMatrix();
            sphereRenderer.setSize(sphereViewerWidth, sphereViewerHeight);
        });

        // File Upload Handler
        document.getElementById('file-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            updateStatus('processing', 'Loading STL file...');
            showLoading(true);

            const loader = new STLLoader();
            const reader = new FileReader();

            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                const geometry = loader.parse(arrayBuffer);
                
                // Center and scale geometry
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);
                
                // Compute normals
                geometry.computeVertexNormals();
                
                // Store geometry
                state.geometry = geometry;
                
                // Create mesh and add to scene
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide
                });
                
                if (state.mesh) {
                    scene.remove(state.mesh);
                }
                
                state.mesh = new THREE.Mesh(geometry, material);
                scene.add(state.mesh);
                
                // Adjust camera
                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
                
                updateStatus('complete', 'STL file loaded successfully');
                showLoading(false);
                enableButton('btn-isolate', true);
            };

            reader.readAsArrayBuffer(file);
        });

        // Utility Functions
        function updateStatus(type, text) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            indicator.className = 'status-indicator';
            if (type === 'ready') indicator.classList.add('status-ready');
            else if (type === 'processing') indicator.classList.add('status-processing');
            else if (type === 'complete') indicator.classList.add('status-complete');
            
            statusText.textContent = text;
        }

        function showLoading(show) {
            document.getElementById('loading-overlay').classList.toggle('hidden', !show);
        }

        function enableButton(buttonId, enabled) {
            const button = document.getElementById(buttonId);
            button.disabled = !enabled;
            if (enabled) {
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                button.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // ALGORITHM 1: Isolate Inner Surface
        // IMPROVED: Robust normal vector analysis with connectivity filtering
        // NOW WITH TRANSPARENCY: Non-selected surfaces are made 75% transparent
        document.getElementById('btn-isolate').addEventListener('click', async () => {
            if (!state.geometry) return;
            
            updateStatus('processing', 'Isolating inner bowl surface with robust filtering...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const positions = state.geometry.attributes.position.array;
            const normals = state.geometry.attributes.normal.array;
            
            // Step 1: Calculate geometric centroid
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexCount = positions.length / 3;
            
            for (let i = 0; i < positions.length; i += 3) {
                centroid.x += positions[i];
                centroid.y += positions[i + 1];
                centroid.z += positions[i + 2];
            }
            centroid.divideScalar(vertexCount);
            
            console.log(`Centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)}, ${centroid.z.toFixed(2)})`);
            
            // Step 2: Calculate distances to centroid for all faces
            const faceCount = positions.length / 9;
            const faceData = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                const faceCenter = new THREE.Vector3()
                    .add(v1).add(v2).add(v3)
                    .divideScalar(3);
                
                const n = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
                const toCentroid = new THREE.Vector3().subVectors(centroid, faceCenter).normalize();
                const dot = n.dot(toCentroid);
                const distanceToCentroid = faceCenter.distanceTo(centroid);
                
                faceData.push({
                    index: i / 9,
                    vertices: [v1, v2, v3],
                    indices: [i / 3, i / 3 + 1, i / 3 + 2],
                    dot,
                    distance: distanceToCentroid,
                    center: faceCenter
                });
            }
            
            // Step 3: Filter inner surface using multiple criteria
            // Inner surface should be: concave (dot > threshold) AND within distance range
            const distances = faceData.map(f => f.distance);
            distances.sort((a, b) => a - b);
            const medianDist = distances[Math.floor(distances.length / 2)];
            const q1Dist = distances[Math.floor(distances.length * 0.25)];
            const q3Dist = distances[Math.floor(distances.length * 0.75)];
            
            // Inner surface of concave bowl should be close to centroid (not far)
            // For acetabulum, the centroid is inside the bowl, so inner surface is closer
            const maxDistance = q3Dist;
            
            let candidateFaces = faceData.filter(f => 
                f.dot > 0.5 &&  // Stricter: normal points strongly toward centroid (concave)
                f.distance <= maxDistance  // Inner surface is closer to centroid for concave geometry
            );
            
            console.log(`Initial candidates: ${candidateFaces.length} faces (strict normal + distance filter)`);
            
            // Step 4: Keep only the largest connected component (OPTIMIZED)
            // This eliminates small isolated regions (like the green spots at the bottom)
            console.log(`Building adjacency graph for ${candidateFaces.length} faces...`);
            
            // Helper: convert vertex position to unique key (round to avoid floating point issues)
            const vertexKey = (v) => {
                const precision = 1000; // 0.001mm precision
                return `${Math.round(v.x * precision)},${Math.round(v.y * precision)},${Math.round(v.z * precision)}`;
            };
            
            // Build vertex-to-faces map using position-based keys
            const vertexToFaces = new Map();
            candidateFaces.forEach(f => {
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (!vertexToFaces.has(key)) {
                        vertexToFaces.set(key, []);
                    }
                    vertexToFaces.get(key).push(f.index);
                });
            });
            
            // Build adjacency list: faces are adjacent if they share a vertex position
            const adjacency = new Map();
            candidateFaces.forEach(f => {
                adjacency.set(f.index, new Set());
            });
            
            candidateFaces.forEach(f => {
                // For each vertex in this face, find all other faces that share the same position
                const neighbors = new Set();
                f.vertices.forEach(v => {
                    const key = vertexKey(v);
                    if (vertexToFaces.has(key)) {
                        vertexToFaces.get(key).forEach(neighborIdx => {
                            if (neighborIdx !== f.index) {
                                neighbors.add(neighborIdx);
                            }
                        });
                    }
                });
                
                // Add to adjacency list
                neighbors.forEach(n => adjacency.get(f.index).add(n));
            });
            
            // Find connected components using BFS
            const visited = new Set();
            const components = [];
            
            candidateFaces.forEach(f => {
                if (visited.has(f.index)) return;
                
                const component = [];
                const queue = [f.index];
                visited.add(f.index);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    
                    if (adjacency.has(current)) {
                        for (let neighbor of adjacency.get(current)) {
                            if (!visited.has(neighbor)) {
                                visited.add(neighbor);
                                queue.push(neighbor);
                            }
                        }
                    }
                }
                
                components.push(component);
            });
            
            // Select largest connected component
            components.sort((a, b) => b.length - a.length);
            const largestComponent = components.length > 0 ? components[0] : [];
            
            console.log(`Connected components: ${components.length}, largest has ${largestComponent.length} faces`);
            
            // Step 5: Build final inner surface from largest component
            const innerFaceSet = new Set(largestComponent);
            const innerFaces = largestComponent;
            state.innerSurfaceVertices = [];
            const vertexMap = new Map();
            
            candidateFaces.forEach(f => {
                if (!innerFaceSet.has(f.index)) return;
                
                f.vertices.forEach((v, i) => {
                    const idx = f.indices[i];
                    if (!vertexMap.has(idx)) {
                        const vData = { pos: v.clone(), index: idx };
                        vertexMap.set(idx, vData);
                        state.innerSurfaceVertices.push(vData);
                    }
                });
            });
            
            console.log(`Inner surface isolated: ${innerFaces.length} faces, ${state.innerSurfaceVertices.length} unique vertices`);
            console.log(`Algorithm: Robust normal analysis + connectivity filtering (largest component)`);
            
            // Step 6: Apply transparency to non-selected surfaces (75% transparent = 0.25 opacity)
            // Build index buffer with inner faces first, then outer faces
            const innerIndices = [];
            const outerIndices = [];
            
            for (let faceIdx = 0; faceIdx < faceCount; faceIdx++) {
                const baseIdx = faceIdx * 3; // Each face has 3 vertices
                if (innerFaceSet.has(faceIdx)) {
                    // Inner surface vertices - add to inner list
                    innerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                } else {
                    // Outer surface vertices - add to outer list (will be 75% transparent)
                    outerIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                }
            }
            
            console.log(`Inner indices: ${innerIndices.length}, Outer indices: ${outerIndices.length}`);
            
            // Combine indices: inner first, then outer
            const combinedIndices = [...innerIndices, ...outerIndices];
            
            // Apply new index buffer to geometry
            const geometry = state.geometry;
            geometry.setIndex(combinedIndices);
            
            // Clear existing groups
            geometry.clearGroups();
            
            // Add group for inner surface (opaque) - starts at 0
            if (innerIndices.length > 0) {
                geometry.addGroup(0, innerIndices.length, 0);
                console.log(`Inner group: start=0, count=${innerIndices.length}, materialIndex=0 (opaque)`);
            }
            
            // Add group for outer surface (75% transparent) - starts after inner
            if (outerIndices.length > 0) {
                geometry.addGroup(innerIndices.length, outerIndices.length, 1);
                console.log(`Outer group: start=${innerIndices.length}, count=${outerIndices.length}, materialIndex=1 (75% transparent)`);
            }
            
            // Create materials array: [0] opaque for inner, [1] 75% transparent for outer
            const materials = [
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: false
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // 75% transparent = 25% opaque
                    depthWrite: false
                })
            ];
            
            // Update mesh with multi-material
            state.mesh.material = materials;
            state.mesh.renderOrder = 1; // Ensure proper transparency rendering
            
            updateStatus('complete', `Inner surface isolated: ${innerFaces.length} faces (${((innerFaces.length/faceCount)*100).toFixed(1)}% of mesh), ${state.innerSurfaceVertices.length} vertices`);
            showLoading(false);
            enableButton('btn-detect-wear', true);
        });

        // ALGORITHM 2: Detect Worn/Unworn Zones
        // IMPROVED: Curvature-based detection using Gaussian curvature and saddle points
        // Methodology: Meyer et al. 2003 + rim exclusion + radial deviation analysis
        document.getElementById('btn-detect-wear').addEventListener('click', async () => {
            if (state.innerSurfaceVertices.length === 0) {
                alert('Please isolate inner surface first');
                return;
            }
            
            updateStatus('processing', 'Detecting wear zones using curvature analysis (Gaussian curvature + saddle points)...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const allVertices = state.innerSurfaceVertices;
            console.log(`=== CURVATURE-BASED WEAR DETECTION ===`);
            console.log(`Processing ${allVertices.length} inner surface vertices`);
            
            // Step 1: Build vertex adjacency and face data structures
            console.log('Building mesh topology...');
            const positions = state.geometry.attributes.position.array;
            const normals = state.geometry.attributes.normal.array;
            
            // Vertex-to-faces mapping
            const vertexToFaces = new Map();
            allVertices.forEach(v => {
                vertexToFaces.set(v.index, []);
            });
            
            // Collect faces from inner surface
            const innerVertexIndices = new Set(allVertices.map(v => v.index));
            const faces = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = i / 3;
                const idx2 = i / 3 + 1;
                const idx3 = i / 3 + 2;
                
                // Only process faces that belong to inner surface
                if (!innerVertexIndices.has(idx1) || !innerVertexIndices.has(idx2) || !innerVertexIndices.has(idx3)) {
                    continue;
                }
                
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                const face = {
                    indices: [idx1, idx2, idx3],
                    vertices: [v1, v2, v3]
                };
                
                faces.push(face);
                vertexToFaces.get(idx1).push(face);
                vertexToFaces.get(idx2).push(face);
                vertexToFaces.get(idx3).push(face);
            }
            
            console.log(`Found ${faces.length} faces in inner surface`);
            
            // Step 2: Build vertex neighborhood (1-ring)
            const vertexNeighbors = new Map();
            allVertices.forEach(v => {
                vertexNeighbors.set(v.index, new Set());
            });
            
            faces.forEach(face => {
                const [i1, i2, i3] = face.indices;
                vertexNeighbors.get(i1).add(i2);
                vertexNeighbors.get(i1).add(i3);
                vertexNeighbors.get(i2).add(i1);
                vertexNeighbors.get(i2).add(i3);
                vertexNeighbors.get(i3).add(i1);
                vertexNeighbors.get(i3).add(i2);
            });
            
            // FIXED: Store adjacency map in state for later use (boundary detection)
            state.adjacency = vertexNeighbors;
            
            // Step 3: Calculate Gaussian curvature using Meyer et al. 2003 method
            console.log('Calculating Gaussian curvature (Meyer 2003)...');
            const gaussianCurvatures = new Map();
            
            // Helper: Calculate angle between two vectors
            function angleBetweenVectors(v1, v2) {
                const dot = v1.dot(v2);
                const lengths = v1.length() * v2.length();
                if (lengths < 1e-10) return 0;
                return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
            }
            
            // Helper: Calculate mixed Voronoi area for vertex (Meyer 2003)
            function calculateMixedArea(vertexIdx, vertexPos, adjacentFaces) {
                let mixedArea = 0;
                
                adjacentFaces.forEach(face => {
                    // Find vertex positions in this face
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    
                    // Find index of current vertex in face
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    // Triangle edges from vertex
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    // Triangle area
                    const triangleArea = 0.5 * new THREE.Vector3().crossVectors(e1, e2).length();
                    
                    // Check if triangle is obtuse
                    const angle0 = angleBetweenVectors(e1, e2);
                    const e1neg = e1.clone().negate();
                    const e12 = new THREE.Vector3().subVectors(v2, v1);
                    const angle1 = angleBetweenVectors(e1neg, e12);
                    const e2neg = e2.clone().negate();
                    const e21 = new THREE.Vector3().subVectors(v1, v2);
                    const angle2 = angleBetweenVectors(e2neg, e21);
                    
                    // Meyer 2003: Different area calculation based on triangle type
                    if (angle0 > Math.PI / 2) {
                        // Obtuse at vertex 0 (our vertex)
                        mixedArea += triangleArea / 2;
                    } else if (angle1 > Math.PI / 2 || angle2 > Math.PI / 2) {
                        // Obtuse at other vertex
                        mixedArea += triangleArea / 4;
                    } else {
                        // Non-obtuse: use Voronoi area (simplified: use barycentric)
                        mixedArea += triangleArea / 3;
                    }
                });
                
                return Math.max(mixedArea, 1e-10); // Avoid division by zero
            }
            
            // Calculate Gaussian curvature for each vertex
            allVertices.forEach(v => {
                const vertexIdx = v.index;
                const vertexPos = v.pos;
                const adjacentFaces = vertexToFaces.get(vertexIdx);
                
                if (!adjacentFaces || adjacentFaces.length === 0) {
                    gaussianCurvatures.set(vertexIdx, 0);
                    return;
                }
                
                // Meyer 2003: K = (2π - Σθⱼ) / A_mixed
                // where θⱼ are the angles at this vertex in adjacent triangles
                
                let angleSum = 0;
                adjacentFaces.forEach(face => {
                    const verts = face.vertices;
                    const vertIndices = face.indices;
                    const localIdx = vertIndices.indexOf(vertexIdx);
                    if (localIdx === -1) return;
                    
                    const v0 = verts[localIdx];
                    const v1 = verts[(localIdx + 1) % 3];
                    const v2 = verts[(localIdx + 2) % 3];
                    
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    
                    angleSum += angleBetweenVectors(e1, e2);
                });
                
                const mixedArea = calculateMixedArea(vertexIdx, vertexPos, adjacentFaces);
                const gaussianCurvature = (2 * Math.PI - angleSum) / mixedArea;
                
                gaussianCurvatures.set(vertexIdx, gaussianCurvature);
            });
            
            console.log(`Calculated Gaussian curvature for ${gaussianCurvatures.size} vertices`);
            
            // Step 4: Detect rim/edge vertices to exclude from wear analysis
            console.log('Detecting rim/edge vertices...');
            const rimVertices = new Set();
            
            // Rim detection: vertices with fewer neighbors (boundary) or at extreme distances
            allVertices.forEach(v => {
                const neighbors = vertexNeighbors.get(v.index);
                const faces = vertexToFaces.get(v.index);
                
                // Boundary vertex if neighbor count != face count (open mesh boundary)
                if (neighbors && faces && neighbors.size < faces.length * 2) {
                    rimVertices.add(v.index);
                }
            });
            
            // Also detect rim by radial distance (outer perimeter)
            const centroid = new THREE.Vector3(0, 0, 0);
            allVertices.forEach(v => centroid.add(v.pos));
            centroid.divideScalar(allVertices.length);
            
            const radialDistances = allVertices.map(v => v.pos.distanceTo(centroid));
            radialDistances.sort((a, b) => a - b);
            const maxRadialDist = radialDistances[radialDistances.length - 1];
            const rimThreshold = maxRadialDist * 0.85; // Top 15% radial distance = rim
            
            allVertices.forEach(v => {
                if (v.pos.distanceTo(centroid) > rimThreshold) {
                    rimVertices.add(v.index);
                }
            });
            
            console.log(`Detected ${rimVertices.size} rim vertices (excluded from wear analysis)`);
            
            // Step 5: Fit reference sphere to ALL inner surface vertices (for radial deviation)
            console.log('Fitting reference sphere...');
            let center = new THREE.Vector3(0, 0, 0);
            allVertices.forEach(v => center.add(v.pos));
            center.divideScalar(allVertices.length);
            
            // Initial radius estimate
            let avgRadius = 0;
            allVertices.forEach(v => avgRadius += v.pos.distanceTo(center));
            avgRadius /= allVertices.length;
            
            // Refine sphere fit
            for (let iter = 0; iter < 5; iter++) {
                const newCenter = new THREE.Vector3(0, 0, 0);
                let newRadius = 0;
                
                allVertices.forEach(v => {
                    const dir = new THREE.Vector3().subVectors(v.pos, center).normalize();
                    const pointOnSphere = center.clone().add(dir.multiplyScalar(avgRadius));
                    newCenter.add(pointOnSphere);
                });
                newCenter.divideScalar(allVertices.length);
                
                allVertices.forEach(v => {
                    newRadius += v.pos.distanceTo(newCenter);
                });
                newRadius /= allVertices.length;
                
                center = newCenter;
                avgRadius = newRadius;
            }
            
            console.log(`Reference sphere: center=(${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius=${avgRadius.toFixed(2)}`);
            
            // Step 6: Calculate penetration depths (radial deviation)
            const penetrationDepths = new Array(allVertices.length);
            for (let i = 0; i < allVertices.length; i++) {
                const v = allVertices[i].pos;
                const distance = v.distanceTo(center);
                penetrationDepths[i] = avgRadius - distance; // Positive = inside sphere (worn)
            }
            
            // Step 7: COMBINED SCORING: Curvature + Radial Deviation
            // Worn zones have: negative Gaussian curvature (saddle points) + high penetration
            console.log('Computing combined wear scores (curvature + radial deviation)...');
            
            const wearScores = new Map();
            const validVertices = []; // Vertices not on rim
            
            allVertices.forEach((v, i) => {
                // Exclude rim vertices
                if (rimVertices.has(v.index)) {
                    wearScores.set(v.index, -Infinity); // Never classify rim as worn
                    return;
                }
                
                validVertices.push(v);
                
                const K = gaussianCurvatures.get(v.index) || 0;
                const penetration = penetrationDepths[i];
                
                // Wear score combines:
                // 1. Negative curvature (K < 0) indicates saddle point (wear signature)
                // 2. Positive penetration indicates material loss
                // Score = penetration * (1 + saddleWeight * |K|) if K < 0
                //       = penetration * 0.5                     if K >= 0
                
                let score;
                if (K < 0) {
                    // Saddle point: boost score by curvature magnitude
                    const saddleWeight = 2.0; // Weight for curvature contribution
                    score = penetration * (1 + saddleWeight * Math.abs(K));
                } else {
                    // Not a saddle point: reduce score
                    score = penetration * 0.5;
                }
                
                wearScores.set(v.index, score);
            });
            
            console.log(`Computed wear scores for ${validVertices.length} valid vertices (${rimVertices.size} rim vertices excluded)`);
            
            // Step 8: Classify worn/unworn using IQR on wear scores
            const scores = validVertices.map(v => wearScores.get(v.index)).filter(s => s !== -Infinity);
            scores.sort((a, b) => a - b);
            
            const q1Score = scores[Math.floor(scores.length * 0.25)];
            const q3Score = scores[Math.floor(scores.length * 0.75)];
            const medianScore = scores[Math.floor(scores.length / 2)];  // FIXED: was / 0.5
            const iqrScore = q3Score - q1Score;
            
            // Worn threshold: scores above Q3 + 0.5*IQR (conservative)
            const wornThreshold = q3Score + 0.3 * iqrScore;
            
            console.log(`Wear score stats: Q1=${q1Score.toFixed(4)}, Median=${medianScore.toFixed(4)}, Q3=${q3Score.toFixed(4)}, IQR=${iqrScore.toFixed(4)}`);
            console.log(`Worn threshold: ${wornThreshold.toFixed(4)}`);
            
            // Classify vertices
            state.wornVertices = [];
            state.unwornVertices = [];
            
            allVertices.forEach(v => {
                const score = wearScores.get(v.index);
                if (score > wornThreshold) {
                    state.wornVertices.push(v);
                } else {
                    state.unwornVertices.push(v);
                }
            });
            
            // Ensure reasonable distribution
            if (state.wornVertices.length === 0 || state.wornVertices.length > validVertices.length * 0.5) {
                console.log('Adjusting classification (fallback to top 20% by wear score)...');
                
                // FIXED: Build complete ranking with actual wear scores
                const rankedVertices = validVertices.map(v => ({
                    vertex: v,
                    score: wearScores.get(v.index) || -Infinity
                }));
                
                // Sort by score (highest first = most worn)
                rankedVertices.sort((a, b) => b.score - a.score);
                
                // Worn vertices are the top 20% with highest scores
                const wornCount = Math.floor(validVertices.length * 0.20);
                
                state.wornVertices = rankedVertices.slice(0, wornCount).map(r => r.vertex);
                state.unwornVertices = rankedVertices.slice(wornCount).map(r => r.vertex);
            }
            
            // Step 9: Apply colors to geometry
            const colors = new Float32Array(state.geometry.attributes.position.count * 3);
            
            // Default color (blue)
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259;
                colors[i + 1] = 0.6;
                colors[i + 2] = 0.882;
            }
            
            // Worn vertices (red)
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96;
                colors[idx + 1] = 0.396;
                colors[idx + 2] = 0.396;
            });
            
            // Unworn vertices (green)
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282;
                colors[idx + 1] = 0.733;
                colors[idx + 2] = 0.471;
            });
            
            state.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Keep multi-material: opaque for inner surface (with vertex colors), 75% transparent for outer
            // Update only the inner surface material to use vertex colors
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // Use vertex colors for worn/unworn visualization
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: false  // Inner surface opaque
                }),
                new THREE.MeshPhongMaterial({
                    color: 0x4299e1,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent
                    depthWrite: false
                })
            ];
            
            state.mesh.material = materials;
            state.mesh.renderOrder = 1;
            
            const wornPercent = (state.wornVertices.length / allVertices.length * 100).toFixed(1);
            const unwornPercent = (state.unwornVertices.length / allVertices.length * 100).toFixed(1);
            
            console.log(`=== CLASSIFICATION RESULTS ===`);
            console.log(`Worn: ${state.wornVertices.length} (${wornPercent}%), Unworn: ${state.unwornVertices.length} (${unwornPercent}%)`);
            console.log(`Rim excluded: ${rimVertices.size} vertices`);
            console.log(`Algorithm: Gaussian curvature (Meyer 2003) + radial deviation + rim exclusion`);
            
            updateStatus('complete', `Wear zones detected using curvature analysis: ${state.wornVertices.length} worn (${wornPercent}%), ${state.unwornVertices.length} unworn (${unwornPercent}%)`);
            showLoading(false);
            enableButton('btn-fit-sphere', true);
        });

        // ALGORITHM 3: Fit Unworn Sphere and Detect Transition Plane
        // IMPROVED: Fits sphere ONLY to unworn zone (reference geometry)
        // Generates transition plane containing boundary points between worn/unworn
        document.getElementById('btn-fit-sphere').addEventListener('click', async () => {
            if (state.unwornVertices.length === 0 || state.wornVertices.length === 0) {
                alert('Please detect wear zones first');
                return;
            }
            
            updateStatus('processing', 'Fitting unworn sphere and detecting transition boundary...');
            showLoading(true);
            document.getElementById('sphere-loading-overlay').classList.remove('hidden');
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // IMPROVED Helper function: Gauss-Newton with Levenberg-Marquardt fallback
            function fitSphereRobust(vertices) {
                // Step 1: Initialize center (geometric centroid)
                let center = new THREE.Vector3(0, 0, 0);
                vertices.forEach(p => center.add(p));
                center.divideScalar(vertices.length);
                
                // Step 2: Initialize radius (average distance to center)
                let radius = 0;
                vertices.forEach(p => radius += p.distanceTo(center));
                radius /= vertices.length;
                
                console.log(`Initial sphere: center=(${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius=${radius.toFixed(2)}`);
                
                // Step 3: Gauss-Newton iterations with adaptive damping
                const maxIterations = 20;
                const tolerance = 1e-6;
                let lambda = 0.001; // LM damping factor
                let prevResidual = Infinity;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Compute residuals: r_i = ||p_i - c|| - R
                    let residualSum = 0;
                    const n = vertices.length;
                    
                    // Jacobian matrix: J is n x 4 (partial derivatives w.r.t. cx, cy, cz, R)
                    // For each point p_i: residual = sqrt((px-cx)^2 + (py-cy)^2 + (pz-cz)^2) - R
                    // ∂r/∂cx = -(px-cx)/d, ∂r/∂cy = -(py-cy)/d, ∂r/∂cz = -(pz-cz)/d, ∂r/∂R = -1
                    
                    const J = []; // Jacobian matrix (n x 4)
                    const residuals = []; // Residual vector (n x 1)
                    
                    vertices.forEach(p => {
                        const dx = p.x - center.x;
                        const dy = p.y - center.y;
                        const dz = p.z - center.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        const residual = dist - radius;
                        residuals.push(residual);
                        residualSum += residual * residual;
                        
                        // Jacobian row: [∂r/∂cx, ∂r/∂cy, ∂r/∂cz, ∂r/∂R]
                        if (dist > 1e-10) {
                            J.push([-dx/dist, -dy/dist, -dz/dist, -1]);
                        } else {
                            J.push([0, 0, 0, -1]);
                        }
                    });
                    
                    const currentResidual = Math.sqrt(residualSum / n);
                    console.log(`Iteration ${iter}: RMSE = ${currentResidual.toFixed(6)}, lambda = ${lambda.toFixed(6)}`);
                    
                    // Check convergence
                    if (currentResidual < tolerance || Math.abs(prevResidual - currentResidual) < tolerance * 0.1) {
                        console.log(`Converged after ${iter} iterations`);
                        break;
                    }
                    
                    // Compute J^T * J (4x4 matrix)
                    const JTJ = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                JTJ[j][k] += J[i][j] * J[i][k];
                            }
                        }
                    }
                    
                    // Add Levenberg-Marquardt damping: JTJ + lambda * I
                    for (let i = 0; i < 4; i++) {
                        JTJ[i][i] += lambda;
                    }
                    
                    // Compute J^T * r (4x1 vector)
                    const JTr = [0, 0, 0, 0];
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < 4; j++) {
                            JTr[j] += J[i][j] * residuals[i];
                        }
                    }
                    
                    // Solve (JTJ) * delta = -JTr using Gauss elimination
                    const delta = solveLinearSystem4x4(JTJ, JTr.map(x => -x));
                    
                    if (!delta) {
                        console.log('Singular matrix, increasing lambda');
                        lambda *= 10;
                        continue;
                    }
                    
                    // Update parameters
                    const newCenter = new THREE.Vector3(
                        center.x + delta[0],
                        center.y + delta[1],
                        center.z + delta[2]
                    );
                    const newRadius = radius + delta[3];
                    
                    // Check if update improves residual
                    let newResidualSum = 0;
                    vertices.forEach(p => {
                        const r = p.distanceTo(newCenter) - newRadius;
                        newResidualSum += r * r;
                    });
                    const newResidual = Math.sqrt(newResidualSum / n);
                    
                    if (newResidual < currentResidual) {
                        // Accept update, decrease damping
                        center = newCenter;
                        radius = newRadius;
                        prevResidual = currentResidual;
                        lambda = Math.max(lambda / 10, 1e-10);
                    } else {
                        // Reject update, increase damping (Levenberg-Marquardt)
                        lambda *= 10;
                        if (lambda > 1e6) {
                            console.log('Lambda too large, stopping');
                            break;
                        }
                    }
                }
                
                console.log(`Final sphere: center=(${center.x.toFixed(4)}, ${center.y.toFixed(4)}, ${center.z.toFixed(4)}), radius=${radius.toFixed(4)}`);
                
                return { center, radius };
            }
            
            // Helper: Solve 4x4 linear system using Gauss elimination
            function solveLinearSystem4x4(A, b) {
                // Create augmented matrix
                const n = 4;
                const aug = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    // Swap rows
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    
                    // Check for singular matrix
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        return null;
                    }
                    
                    // Eliminate column
                    for (let k = i + 1; k < n; k++) {
                        const factor = aug[k][i] / aug[i][i];
                        for (let j = i; j <= n; j++) {
                            aug[k][j] -= factor * aug[i][j];
                        }
                    }
                }
                
                // Back substitution
                const x = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = aug[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            }
            
            // Fit ONLY unworn surface (reference geometry for ideal unworn surface)
            // Use selected shape and method: Sphere/Ellipsoid and Gauss-Newton/RANSAC
            const fittingShape = document.getElementById('fitting-shape').value;
            const fittingMethod = document.getElementById('fitting-method').value;
            const isEllipsoid = fittingShape === 'ellipsoid';
            
            // FIXED: Guard against missing wear detection step
            if (!state.wornVertices || !state.unwornVertices || !state.adjacency) {
                alert('Please complete Detect Wear Zones step first. The surface fitting requires worn/unworn classification to be completed.');
                showLoading(false);
                document.getElementById('sphere-loading-overlay').classList.add('hidden');
                return;
            }
            
            console.log(`=== Fitting UNWORN ${fittingShape.toUpperCase()} using ${fittingMethod.toUpperCase()} ===`);
            
            // CRITICAL FIX: Build unwornPositions array iteratively to avoid stack overflow with 313k vertices
            // The .map() causes "Maximum call stack size exceeded" with large arrays
            const unwornPositions = [];
            for (let i = 0; i < state.unwornVertices.length; i++) {
                unwornPositions.push(state.unwornVertices[i].pos);
            }
            console.log(`Prepared ${unwornPositions.length} unworn vertex positions for ${fittingShape} fitting`);
            
            let fittingResult;
            try {
                if (isEllipsoid) {
                    // Ellipsoid fitting (6 parameters: cx, cy, cz, rx, ry, rz)
                    if (fittingMethod === 'ransac') {
                        console.log('Using RANSAC + LM refinement for ellipsoid fitting (robust against outliers)...');
                        fittingResult = FittingService.fitEllipsoidRANSAC(unwornPositions);
                    } else {
                        console.log('Using Gauss-Newton + LM for ellipsoid fitting (fast convergence)...');
                        fittingResult = FittingService.fitEllipsoidGaussNewton(unwornPositions);
                    }
                } else {
                    // Sphere fitting (4 parameters: cx, cy, cz, r)
                    if (fittingMethod === 'ransac') {
                        console.log('Using RANSAC + LM refinement for sphere fitting (robust against outliers)...');
                        fittingResult = FittingService.fitSphereRANSAC(unwornPositions);
                    } else {
                        console.log('Using Gauss-Newton + LM for sphere fitting (fast convergence)...');
                        fittingResult = FittingService.fitSphereGaussNewton(unwornPositions);
                    }
                }
                
                // FIXED: Guard against null results
                if (!fittingResult || !fittingResult.center || !fittingResult.radius) {
                    throw new Error('Surface fitting failed to produce valid results');
                }
                
                state.unwornSphere = {
                    center: fittingResult.center,
                    radius: fittingResult.radius,
                    radii: fittingResult.radii || null,
                    isEllipsoid: isEllipsoid
                };
                state.fittingDiagnostics = fittingResult;
                
                if (isEllipsoid) {
                    console.log(`Final ellipsoid: center=(${fittingResult.center.x.toFixed(4)}, ${fittingResult.center.y.toFixed(4)}, ${fittingResult.center.z.toFixed(4)}), radii=(${fittingResult.radii.x.toFixed(4)}, ${fittingResult.radii.y.toFixed(4)}, ${fittingResult.radii.z.toFixed(4)})`);
                    console.log(`Sphericity: ${fittingResult.sphericityPercent.toFixed(2)}%, Ellipsoidality: ${fittingResult.ellipsoidalityPercent.toFixed(2)}%`);
                } else {
                    console.log(`Final sphere: center=(${fittingResult.center.x.toFixed(4)}, ${fittingResult.center.y.toFixed(4)}, ${fittingResult.center.z.toFixed(4)}), radius=${fittingResult.radius.toFixed(4)}`);
                }
                console.log(`Method: ${fittingResult.method}, RMS Error: ${fittingResult.rmsError.toFixed(6)} mm, Iterations: ${fittingResult.iterations}, Inliers: ${fittingResult.inliers}`);
                
                // CRITICAL: Check if residuals array exists and has reasonable size
                if (!fittingResult.residuals || !Array.isArray(fittingResult.residuals)) {
                    console.warn('No residuals array found in fitting result, skipping diagnostics');
                    fittingResult.residuals = [0]; // Fallback to avoid errors
                }
                console.log(`Processing ${fittingResult.residuals.length} residuals for diagnostics`);
                
                // Update diagnostics panel
                document.getElementById('diag-method').textContent = fittingResult.method;
                document.getElementById('diag-rms').textContent = fittingResult.rmsError.toFixed(6);
                document.getElementById('diag-iterations').textContent = fittingResult.iterations;
                document.getElementById('diag-inliers').textContent = `${fittingResult.inliers} / ${unwornPositions.length}`;
                
                // FIXED: Calculate min/max iteratively to avoid stack overflow with large arrays
                let minResidual = 0;
                let maxResidual = 0;
                if (fittingResult.residuals.length > 0) {
                    minResidual = Infinity;
                    maxResidual = -Infinity;
                    for (let i = 0; i < fittingResult.residuals.length; i++) {
                        if (fittingResult.residuals[i] < minResidual) minResidual = fittingResult.residuals[i];
                        if (fittingResult.residuals[i] > maxResidual) maxResidual = fittingResult.residuals[i];
                    }
                }
                console.log(`Residual range calculated: [${minResidual}, ${maxResidual}]`);
                
                document.getElementById('diag-residual-range').textContent = 
                    `[${minResidual.toFixed(4)}, ${maxResidual.toFixed(4)}]`;
                document.getElementById('diag-convergence').textContent = 
                    fittingResult.iterations < 30 ? 'Converged' : 'Max iterations';
                
                // Calculate unworn area match metric
                // Metric: percentage of unworn vertices within tolerance of fitted surface
                const tolerance = fittingResult.rmsError * 2; // 2x RMS error as tolerance
                let matchingVertices = 0;
                
                if (isEllipsoid) {
                    // For ellipsoid: check distance using ellipsoid equation
                    for (let i = 0; i < unwornPositions.length; i++) {
                        const p = unwornPositions[i];
                        const dx = p.x - fittingResult.center.x;
                        const dy = p.y - fittingResult.center.y;
                        const dz = p.z - fittingResult.center.z;
                        const term_x = dx / fittingResult.radii.x;
                        const term_y = dy / fittingResult.radii.y;
                        const term_z = dz / fittingResult.radii.z;
                        const f = Math.sqrt(term_x*term_x + term_y*term_y + term_z*term_z);
                        const deviation = Math.abs(f - 1.0);
                        if (deviation <= tolerance) {
                            matchingVertices++;
                        }
                    }
                } else {
                    // For sphere: check radial distance
                    for (let i = 0; i < unwornPositions.length; i++) {
                        const dist = unwornPositions[i].distanceTo(fittingResult.center);
                        const deviation = Math.abs(dist - fittingResult.radius);
                        if (deviation <= tolerance) {
                            matchingVertices++;
                        }
                    }
                }
                
                const matchPercentage = (matchingVertices / unwornPositions.length) * 100;
                document.getElementById('diag-unworn-match').textContent = 
                    `${matchPercentage.toFixed(1)}% (within ${tolerance.toFixed(3)}mm)`;
                console.log(`Unworn area match: ${matchPercentage.toFixed(1)}% of ${unwornPositions.length} vertices within ${tolerance.toFixed(3)}mm tolerance`);
                
                // Show/hide ellipsoid-specific metrics
                if (isEllipsoid && fittingResult.isEllipsoid) {
                    document.getElementById('diag-sphericity-container').classList.remove('hidden');
                    document.getElementById('diag-ellipsoidality-container').classList.remove('hidden');
                    document.getElementById('diag-radii-container').classList.remove('hidden');
                    document.getElementById('diag-sphericity').textContent = fittingResult.sphericityPercent.toFixed(2);
                    document.getElementById('diag-ellipsoidality').textContent = fittingResult.ellipsoidalityPercent.toFixed(2);
                    document.getElementById('diag-radii').textContent = 
                        `(${fittingResult.radii.x.toFixed(3)}, ${fittingResult.radii.y.toFixed(3)}, ${fittingResult.radii.z.toFixed(3)})`;
                } else {
                    document.getElementById('diag-sphericity-container').classList.add('hidden');
                    document.getElementById('diag-ellipsoidality-container').classList.add('hidden');
                    document.getElementById('diag-radii-container').classList.add('hidden');
                }
                
                document.getElementById('quality-diagnostics').classList.remove('hidden');
                console.log('Diagnostics panel updated successfully');
            } catch (error) {
                console.error('Sphere fitting error:', error);
                alert(`Sphere fitting failed: ${error.message}. Please try a different method or check your data.`);
                showLoading(false);
                document.getElementById('sphere-loading-overlay').classList.add('hidden');
                return;
            }
            
            // Detect boundary vertices (transition between worn and unworn)
            // IMPROVED: Use radial distance analysis to find true inflection zone
            try {
                console.log('=== Detecting transition boundary (IMPROVED: radial inflection analysis) ===');
                
                // FIXED: Build Sets iteratively to avoid stack overflow with large arrays
                const wornIndices = new Set();
                for (let i = 0; i < state.wornVertices.length; i++) {
                    wornIndices.add(state.wornVertices[i].index);
                }
                const unwornIndices = new Set();
                for (let i = 0; i < state.unwornVertices.length; i++) {
                    unwornIndices.add(state.unwornVertices[i].index);
                }
                const boundaryVertices = [];
            
            // FIXED: Use pre-built adjacency from CurvatureAnalyzer to avoid processing millions of faces
            // state.adjacency was already built during curvature analysis from ONLY inner surface faces
            console.log(`Using pre-built adjacency map with ${state.adjacency.size} vertices`);
            const neighbors = state.adjacency;
            
            // CORRECTED: Find boundary on BOTH sides for complete inflection zone
            // - Unworn vertices that have worn neighbors (unworn side of boundary)
            // - Worn vertices that have unworn neighbors (worn side of boundary)
            // This ensures the plane contains ALL inflection points, not just one side
            // OPTIMIZED: Use for-loop and limit boundary vertices to prevent memory issues
            let boundaryCount = 0;
            const MAX_BOUNDARY_VERTICES = 50000;  // Cap to prevent stack overflow
            
            // First pass: Unworn vertices with worn neighbors
            for (let i = 0; i < state.unwornVertices.length && boundaryCount < MAX_BOUNDARY_VERTICES; i++) {
                const v = state.unwornVertices[i];
                if (!neighbors.has(v.index)) continue;  // Skip if no adjacency info
                
                const neighborSet = neighbors.get(v.index);
                let hasWornNeighbor = false;
                
                for (let neighborIdx of neighborSet) {
                    if (wornIndices.has(neighborIdx)) {
                        hasWornNeighbor = true;
                        break;
                    }
                }
                
                if (hasWornNeighbor) {
                    boundaryVertices.push(v.pos);
                    boundaryCount++;
                }
            }
            
            console.log(`Found ${boundaryCount} boundary vertices from unworn side`);
            
            // Second pass: Worn vertices with unworn neighbors
            const initialCount = boundaryCount;
            for (let i = 0; i < state.wornVertices.length && boundaryCount < MAX_BOUNDARY_VERTICES; i++) {
                const v = state.wornVertices[i];
                if (!neighbors.has(v.index)) continue;  // Skip if no adjacency info
                
                const neighborSet = neighbors.get(v.index);
                let hasUnwornNeighbor = false;
                
                for (let neighborIdx of neighborSet) {
                    if (unwornIndices.has(neighborIdx)) {
                        hasUnwornNeighbor = true;
                        break;
                    }
                }
                
                if (hasUnwornNeighbor) {
                    boundaryVertices.push(v.pos);
                    boundaryCount++;
                }
            }
            
            console.log(`Found ${boundaryCount - initialCount} boundary vertices from worn side`);
            console.log(`Total: ${boundaryVertices.length} boundary vertices at worn/unworn interface (BOTH sides, max=${MAX_BOUNDARY_VERTICES})`);
            
            // Store inflection points for visualization
            state.inflectionPoints = boundaryVertices;
            
            // Fit plane to boundary points using RADIAL method
            // IMPROVED: Use radial direction method for robust plane positioning
            // This ensures the plane passes through the centroid of boundary points
            // with normal pointing in the natural radial wear direction
            if (boundaryVertices.length < 3) {
                console.warn(`Not enough boundary points (${boundaryVertices.length}), using sphere-based fallback plane`);
                // Fallback: Use radial direction plane
                let avgWornDist = state.unwornSphere.radius * 0.9;
                if (state.wornVertices.length > 0) {
                    // FIXED: Calculate average iteratively to avoid stack overflow
                    let sumDist = 0;
                    for (let i = 0; i < state.wornVertices.length; i++) {
                        sumDist += state.wornVertices[i].pos.distanceTo(state.unwornSphere.center);
                    }
                    avgWornDist = sumDist / state.wornVertices.length;
                }
                const defaultRadialDist = (state.unwornSphere.radius + avgWornDist) / 2;
                const radialDir = new THREE.Vector3(0, 0, 1);
                const planePoint = state.unwornSphere.center.clone().add(radialDir.clone().multiplyScalar(defaultRadialDist));
                
                // CRITICAL: Use consistent plane equation form n·x + d = 0
                state.transitionPlane = { 
                    normal: radialDir, 
                    point: planePoint,
                    d: -radialDir.dot(planePoint)
                };
                console.log(`Fallback plane: radial dist=${defaultRadialDist.toFixed(3)} (form: n·x + d = 0)`);
            } else {
                // RADIAL METHOD: Compute centroid of boundary (inflection zone center)
                console.log('Computing transition plane using RADIAL method...');
                const centroid = new THREE.Vector3(0, 0, 0);
                for (let i = 0; i < boundaryVertices.length; i++) {
                    centroid.add(boundaryVertices[i]);
                }
                centroid.divideScalar(boundaryVertices.length);
                
                // Calculate average radial distance from sphere center to boundary
                // This defines the exact radial position of the worn/unworn inflection
                let avgRadialDist = 0;
                for (let i = 0; i < boundaryVertices.length; i++) {
                    avgRadialDist += boundaryVertices[i].distanceTo(state.unwornSphere.center);
                }
                avgRadialDist /= boundaryVertices.length;
                
                console.log(`Boundary average radial distance from sphere center: ${avgRadialDist.toFixed(4)} mm`);
                console.log(`Unworn sphere radius: ${state.unwornSphere.radius.toFixed(4)} mm`);
                console.log(`Radial deviation at boundary: ${(state.unwornSphere.radius - avgRadialDist).toFixed(4)} mm`);
                
                // FIXED: Use radial direction from boundary to sphere center (INWARD direction)
                // This ensures the normal points toward the worn zone (closer to center)
                // so that worn vertices (distance <= 0) are correctly captured by the filter
                const radialNormal = new THREE.Vector3().subVectors(state.unwornSphere.center, centroid);
                
                // Guard against zero-length vector (unlikely but safety check)
                if (radialNormal.lengthSq() < 1e-10) {
                    console.warn('Centroid coincides with sphere center, using fallback direction');
                    radialNormal.set(0, 0, 1);
                }
                radialNormal.normalize();
                
                // Position the plane at the boundary centroid (true inflection zone)
                const normal = radialNormal;
                const point = centroid;
                // CRITICAL: Plane equation is n·x + d = 0, so d = -n·point
                // This ensures consistent signed distance calculations throughout the pipeline
                const d = -normal.dot(point);
                
                state.transitionPlane = { normal, point, d };
                console.log(`RADIAL Transition plane at inflection zone:`);
                console.log(`  Normal (INWARD - toward worn zone): (${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)})`);
                console.log(`  Point (boundary centroid): (${point.x.toFixed(4)}, ${point.y.toFixed(4)}, ${point.z.toFixed(4)})`);
                console.log(`  Plane equation d: ${d.toFixed(4)} (form: n·x + d = 0)`);
                
                // Calculate quality metric: avg distance from boundary points to fitted plane
                let avgPlaneDistance = 0;
                for (let i = 0; i < boundaryVertices.length; i++) {
                    const dist = Math.abs(normal.dot(boundaryVertices[i]) + d);
                    avgPlaneDistance += dist;
                }
                avgPlaneDistance /= boundaryVertices.length;
                console.log(`  Avg distance from boundary to plane: ${avgPlaneDistance.toFixed(6)} mm`);
            }
            
            // Visualize inflection points if enabled
            if (document.getElementById('show-inflection-markers').checked && boundaryVertices.length > 0) {
                console.log(`Visualizing ${boundaryVertices.length} inflection point markers...`);
                // Clear existing markers
                for (let i = 0; i < state.inflectionMarkers.length; i++) {
                    scene.remove(state.inflectionMarkers[i]);
                }
                state.inflectionMarkers = [];
                
                // Add small sphere markers at inflection points
                // OPTIMIZED: Limit to max 1000 markers to avoid performance issues
                const markerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                const step = Math.max(1, Math.floor(boundaryVertices.length / 1000));
                for (let i = 0; i < boundaryVertices.length; i += step) {
                    const pos = boundaryVertices[i];
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(pos);
                    scene.add(marker);
                    state.inflectionMarkers.push(marker);
                }
                console.log(`Added ${state.inflectionMarkers.length} visual markers (step=${step})`);
            }
            
            // Clear and update sphere viewer
            while (sphereScene.children.length > 0) {
                sphereScene.remove(sphereScene.children[0]);
            }
            
            sphereScene.add(sphereAmbientLight);
            sphereScene.add(sphereDirectionalLight);
            
            // Add STL mesh with vertex colors AND transparency for non-isolated surfaces
            const clonedGeometry = state.geometry.clone();
            
            // CRITICAL: geometry.clone() does NOT preserve groups, must copy manually
            // Copy groups from original geometry to preserve inner/outer surface separation
            clonedGeometry.clearGroups();
            if (state.geometry.groups && state.geometry.groups.length > 0) {
                state.geometry.groups.forEach(group => {
                    clonedGeometry.addGroup(group.start, group.count, group.materialIndex);
                });
                console.log(`Copied ${state.geometry.groups.length} geometry groups to cloned geometry`);
            }
            
            // Set up vertex colors for worn/unworn zones
            const colors = new Float32Array(clonedGeometry.attributes.position.count * 3);
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = 0.259; colors[i + 1] = 0.6; colors[i + 2] = 0.882;
            }
            state.wornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.96; colors[idx + 1] = 0.396; colors[idx + 2] = 0.396;
            });
            state.unwornVertices.forEach(v => {
                const idx = v.index * 3;
                colors[idx] = 0.282; colors[idx + 1] = 0.733; colors[idx + 2] = 0.471;
            });
            clonedGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create multi-material setup: inner surface opaque, outer surface 75% transparent
            // This matches the behavior in the main 3D viewer
            // CRITICAL: Both materials MUST have vertexColors:true to share the BufferGeometry correctly
            const materials = [
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7  // Inner surface with vertex colors
                }),
                new THREE.MeshPhongMaterial({
                    vertexColors: true,  // CRITICAL: Must be true to properly share geometry with inner material
                    flatShading: false,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.25,  // Outer surface 75% transparent (25% opaque)
                    depthWrite: false
                })
            ];
            
            const clonedMesh = new THREE.Mesh(clonedGeometry, materials);
            clonedMesh.renderOrder = 1;
            
            // Force proper transparency rendering by ensuring renderer sorts objects
            sphereRenderer.sortObjects = true;
            
            sphereScene.add(clonedMesh);
            
            // Add unworn reference sphere (yellow wireframe)
            const unwornSphereGeom = new THREE.SphereGeometry(state.unwornSphere.radius, 64, 64);
            const wireframeGeom = new THREE.WireframeGeometry(unwornSphereGeom);
            const unwornSphereMat = new THREE.LineBasicMaterial({
                color: 0xffff00,  // Yellow
                linewidth: 0.5
            });
            const unwornSphereMesh = new THREE.LineSegments(wireframeGeom, unwornSphereMat);
            unwornSphereMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornSphereMesh);
            
            // Add unworn sphere center marker
            const unwornCenterGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const unwornCenterMat = new THREE.MeshBasicMaterial({ color: 0x48bb78 });
            const unwornCenterMesh = new THREE.Mesh(unwornCenterGeom, unwornCenterMat);
            unwornCenterMesh.position.copy(state.unwornSphere.center);
            sphereScene.add(unwornCenterMesh);
            
            // Add transition plane at worn/unworn inflection zone
            const planeSize = state.unwornSphere.radius * 4;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,  // Green to mark the inflection boundary
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const planeMesh = new THREE.Mesh(planeGeom, planeMat);
            planeMesh.position.copy(state.transitionPlane.point);
            
            // Orient plane to match normal (radial direction)
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, state.transitionPlane.normal);
            planeMesh.quaternion.copy(quaternion);
            sphereScene.add(planeMesh);
            
            // Add boundary vertices visualization (yellow/gold points at exact inflection)
            const boundaryGeom = new THREE.BufferGeometry();
            const boundaryPositions = new Float32Array(boundaryVertices.length * 3);
            boundaryVertices.forEach((v, i) => {
                boundaryPositions[i * 3] = v.x;
                boundaryPositions[i * 3 + 1] = v.y;
                boundaryPositions[i * 3 + 2] = v.z;
            });
            boundaryGeom.setAttribute('position', new THREE.BufferAttribute(boundaryPositions, 3));
            const boundaryMat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.8 });
            const boundaryPoints = new THREE.Points(boundaryGeom, boundaryMat);
            sphereScene.add(boundaryPoints);
            
            // Position camera
            const size = new THREE.Vector3();
            state.geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            sphereCamera.position.set(maxDim, maxDim, maxDim);
            sphereControls.target.set(0, 0, 0);
            sphereControls.update();
            
            } catch (boundaryError) {
                console.error('Boundary detection error:', boundaryError);
                console.error('Stack:', boundaryError.stack);
                alert(`Boundary detection failed: ${boundaryError.message}. Using simplified plane calculation.`);
                
                // Fallback: Use simple radial plane
                const avgWornDist = state.unwornSphere.radius * 0.9;
                const radialDir = new THREE.Vector3(0, 0, 1);
                const planePoint = state.unwornSphere.center.clone().add(radialDir.clone().multiplyScalar(avgWornDist));
                
                state.transitionPlane = { 
                    normal: radialDir, 
                    point: planePoint,
                    d: radialDir.dot(planePoint)
                };
                state.inflectionPoints = [];
            }
            
            updateStatus('complete', 'Unworn sphere fitted and transition boundary detected');
            showLoading(false);
            document.getElementById('sphere-loading-overlay').classList.add('hidden');
            document.getElementById('btn-download-sphere-view').classList.remove('hidden');
            enableButton('btn-calculate', true);
        });

        // ALGORITHM 4: Calculate Volumetric and Linear Wear
        // NEW METHOD: Volume between transition plane and worn surface, minus spherical cap
        // Formula: V_wear = V(plane to surface) - V(spherical cap)
        document.getElementById('btn-calculate').addEventListener('click', async () => {
            if (!state.unwornSphere || !state.transitionPlane) {
                alert('Please fit unworn sphere and detect transition plane first');
                return;
            }
            
            updateStatus('processing', 'Calculating wear volume: (plane-to-surface) - (spherical cap)...');
            showLoading(true);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            console.log('=== VOLUMETRIC WEAR CALCULATION (CORRECTED METHOD) ===');
            console.log('Formula: V_wear = Volume between fitted sphere and real worn surface (clipped by plane)');
            console.log('Plane equation: n·p = d, where n =', state.transitionPlane.normal, ', d =', state.transitionPlane.d);
            
            const positions = state.geometry.attributes.position.array;
            
            // CRITICAL FIX: Build Set iteratively to avoid stack overflow with 41k vertices
            const wornVertexIndices = new Set();
            for (let i = 0; i < state.wornVertices.length; i++) {
                wornVertexIndices.add(state.wornVertices[i].index);
            }
            
            const planeNormal = state.transitionPlane.normal;
            const planeD = state.transitionPlane.d;
            const sphereCenter = state.unwornSphere.center;
            const sphereRadius = state.unwornSphere.radius;
            
            // Helper: Calculate signed distance from point to plane
            function distanceToPlane(point, planeNormal, planeD) {
                return point.dot(planeNormal) - planeD;
            }
            
            // Helper: Calculate signed tetrahedral volume
            function tetrahedronVolume(v0, v1, v2, v3) {
                const a = new THREE.Vector3().subVectors(v1, v0);
                const b = new THREE.Vector3().subVectors(v2, v0);
                const c = new THREE.Vector3().subVectors(v3, v0);
                const cross = new THREE.Vector3().crossVectors(b, c);
                return a.dot(cross) / 6.0;
            }
            
            // Helper: Project point onto sphere surface (radially)
            function projectToSphere(point, center, radius) {
                const dir = new THREE.Vector3().subVectors(point, center);
                const dist = dir.length();
                if (dist < 0.0001) {
                    // Point too close to center, return arbitrary point on sphere
                    return new THREE.Vector3(center.x + radius, center.y, center.z);
                }
                const normalized = dir.clone().divideScalar(dist);
                return new THREE.Vector3().addVectors(center, normalized.multiplyScalar(radius));
            }
            
            // Helper: Project point onto ellipsoid surface (radially along normalized direction)
            function projectToEllipsoid(point, center, radii) {
                const dir = new THREE.Vector3().subVectors(point, center);
                const dist = dir.length();
                if (dist < 0.0001) {
                    // Point too close to center, return arbitrary point on ellipsoid
                    return new THREE.Vector3(center.x + radii.x, center.y, center.z);
                }
                
                // For ellipsoid projection, we need to find the point on the ellipsoid surface
                // along the ray from center to point. This requires solving a quadratic equation.
                // Parametric line: P(t) = center + t*dir
                // Ellipsoid: (x/rx)² + (y/ry)² + (z/rz)² = 1
                
                // Normalized direction
                const dx = dir.x;
                const dy = dir.y;
                const dz = dir.z;
                
                // Quadratic coefficients for intersection with ellipsoid
                const a = (dx*dx)/(radii.x*radii.x) + (dy*dy)/(radii.y*radii.y) + (dz*dz)/(radii.z*radii.z);
                const t = 1.0 / Math.sqrt(a); // Distance along ray to ellipsoid surface
                
                return new THREE.Vector3(
                    center.x + t * dx,
                    center.y + t * dy,
                    center.z + t * dz
                );
            }
            
            // Helper: Calculate penetration depth for ellipsoid
            // Returns the radial penetration depth from the ellipsoid surface to the point
            function penetrationDepthEllipsoid(point, center, radii) {
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                const dz = point.z - center.z;
                
                // Distance from point to center
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist < 1e-10) {
                    // Point is at center - penetration is average radius
                    return (radii.x + radii.y + radii.z) / 3;
                }
                
                // Ellipsoid equation: (x/rx)² + (y/ry)² + (z/rz)² = 1
                // Normalized distance f: how far along the ray we are relative to the ellipsoid surface
                const f = Math.sqrt(
                    (dx*dx)/(radii.x*radii.x) + 
                    (dy*dy)/(radii.y*radii.y) + 
                    (dz*dz)/(radii.z*radii.z)
                );
                
                // Distance from center to ellipsoid surface along this ray direction
                const distToSurface = dist / f;
                
                // Penetration = surface_distance - actual_distance
                // Positive = point is inside (worn), Negative = point is outside
                const penetration = distToSurface - dist;
                
                return penetration;
            }
            
            // VOLUMETRIC WEAR: Only in WORN zone BOUNDED by transition plane
            // Volume = ∫(penetration · dA) over worn surface triangles BELOW the transition plane
            // This ensures we measure only the volume between the transition plane and the worn inner surface
            console.log('=== Calculating wear volume in WORN zone (bounded by transition plane) ===');
            console.log('Method: Integrate penetration depth × area for triangles between plane and worn surface');
            console.log('CODE VERSION: v2.3 - Triangle clipping implemented');
            
            let volumetricWear = 0;
            let wornTriangleCount = 0;
            let totalClippedTriangles = 0;
            
            // Kahan summation for numerical stability
            let kahanC = 0;
            
            // Helper: Calculate triangle area
            function triangleArea(p1, p2, p3) {
                const v1 = new THREE.Vector3().subVectors(p2, p1);
                const v2 = new THREE.Vector3().subVectors(p3, p1);
                const cross = new THREE.Vector3().crossVectors(v1, v2);
                return cross.length() / 2.0;
            }
            
            // Helper: Clip triangle by plane, return sub-triangles on the worn side (distance <= 0)
            // Returns array of triangles (each as {p1, p2, p3}) that lie on the worn side of the plane
            // CRITICAL: Plane normal points radially INWARD (from boundary to sphere center)
            // Worn vertices are closer to center, in front of the plane, so distance <= 0
            function clipTriangleByPlane(p1, p2, p3, planeNormal, planeD) {
                // Calculate signed distances to plane for all three vertices
                const d1 = distanceToPlane(p1, planeNormal, planeD);
                const d2 = distanceToPlane(p2, planeNormal, planeD);
                const d3 = distanceToPlane(p3, planeNormal, planeD);
                
                // Classify vertices: worn side (distance <= 0) or unworn side (distance > 0)
                // Since normal points INWARD (toward center), worn region (closer to center) has negative/zero distance
                const worn1 = d1 <= 0;
                const worn2 = d2 <= 0;
                const worn3 = d3 <= 0;
                
                const wornCount = (worn1 ? 1 : 0) + (worn2 ? 1 : 0) + (worn3 ? 1 : 0);
                
                // Case 1: All vertices on worn side (distance <= 0) - return entire triangle
                if (wornCount === 3) {
                    return [{ p1, p2, p3 }];
                }
                
                // Case 2: No vertices on worn side - triangle is completely outside, return empty
                if (wornCount === 0) {
                    return [];
                }
                
                // Case 3: Triangle crosses the plane - need to clip it
                // Helper function to find intersection point between two vertices where one is on each side
                function findIntersection(pWorn, pUnworn, dWorn, dUnworn) {
                    // Linear interpolation: intersection at t where d(t) = 0
                    // d(t) = dWorn + t*(dUnworn - dWorn) = 0
                    // t = -dWorn / (dUnworn - dWorn)
                    const t = -dWorn / (dUnworn - dWorn);
                    return new THREE.Vector3().lerpVectors(pWorn, pUnworn, t);
                }
                
                // Case 3a: Two vertices on worn side, one on unworn side
                // Result: One quadrilateral (split into 2 triangles)
                if (wornCount === 2) {
                    let pWorn1, pWorn2, pUnworn, dWorn1, dWorn2, dUnworn;
                    
                    // Identify which vertices are worn and which is unworn
                    if (!worn1) {
                        pUnworn = p1; dUnworn = d1;
                        pWorn1 = p2; dWorn1 = d2;
                        pWorn2 = p3; dWorn2 = d3;
                    } else if (!worn2) {
                        pUnworn = p2; dUnworn = d2;
                        pWorn1 = p1; dWorn1 = d1;
                        pWorn2 = p3; dWorn2 = d3;
                    } else {
                        pUnworn = p3; dUnworn = d3;
                        pWorn1 = p1; dWorn1 = d1;
                        pWorn2 = p2; dWorn2 = d2;
                    }
                    
                    // Find intersection points where edges cross the plane
                    const int1 = findIntersection(pWorn1, pUnworn, dWorn1, dUnworn);
                    const int2 = findIntersection(pWorn2, pUnworn, dWorn2, dUnworn);
                    
                    // Return quadrilateral as two triangles: (pWorn1, int1, int2) and (pWorn1, int2, pWorn2)
                    return [
                        { p1: pWorn1, p2: int1, p3: int2 },
                        { p1: pWorn1, p2: int2, p3: pWorn2 }
                    ];
                }
                
                // Case 3b: One vertex on worn side, two on unworn side
                // Result: One triangle (smaller piece on worn side)
                if (wornCount === 1) {
                    let pWorn, pUnworn1, pUnworn2, dWorn, dUnworn1, dUnworn2;
                    
                    // Identify which vertex is worn and which are unworn
                    if (worn1) {
                        pWorn = p1; dWorn = d1;
                        pUnworn1 = p2; dUnworn1 = d2;
                        pUnworn2 = p3; dUnworn2 = d3;
                    } else if (worn2) {
                        pWorn = p2; dWorn = d2;
                        pUnworn1 = p1; dUnworn1 = d1;
                        pUnworn2 = p3; dUnworn2 = d3;
                    } else {
                        pWorn = p3; dWorn = d3;
                        pUnworn1 = p1; dUnworn1 = d1;
                        pUnworn2 = p2; dUnworn2 = d2;
                    }
                    
                    // Find intersection points where edges cross the plane
                    const int1 = findIntersection(pWorn, pUnworn1, dWorn, dUnworn1);
                    const int2 = findIntersection(pWorn, pUnworn2, dWorn, dUnworn2);
                    
                    // Return the small triangle on the worn side
                    return [{ p1: pWorn, p2: int1, p3: int2 }];
                }
                
                // Should never reach here
                return [];
            }
            
            // Process each triangle in the worn zone
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = (i / 3);
                const idx2 = (i / 3) + 1;
                const idx3 = (i / 3) + 2;
                
                // Check if triangle belongs to worn zone (at least 2 vertices worn)
                const v1Worn = wornVertexIndices.has(idx1);
                const v2Worn = wornVertexIndices.has(idx2);
                const v3Worn = wornVertexIndices.has(idx3);
                const wornCount = (v1Worn ? 1 : 0) + (v2Worn ? 1 : 0) + (v3Worn ? 1 : 0);
                
                if (wornCount < 2) continue; // Skip if not a worn triangle
                
                // Get real surface triangle vertices (from STL)
                const p1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                const p2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                const p3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                
                // CRITICAL: Clip triangle by transition plane to get only the portion on the worn side
                // This correctly handles triangles that cross the plane boundary
                const clippedTriangles = clipTriangleByPlane(p1, p2, p3, planeNormal, planeD);
                
                // Track clipped triangles for debugging
                totalClippedTriangles += clippedTriangles.length;
                
                // Skip if triangle is completely outside the worn region
                if (clippedTriangles.length === 0) continue;
                
                // Process each clipped sub-triangle
                for (const tri of clippedTriangles) {
                    // Calculate penetration depth for each vertex of the clipped triangle
                    let pen1, pen2, pen3;
                    
                    if (state.unwornSphere.isEllipsoid && state.unwornSphere.radii) {
                        // Ellipsoid penetration depth
                        pen1 = penetrationDepthEllipsoid(tri.p1, sphereCenter, state.unwornSphere.radii);
                        pen2 = penetrationDepthEllipsoid(tri.p2, sphereCenter, state.unwornSphere.radii);
                        pen3 = penetrationDepthEllipsoid(tri.p3, sphereCenter, state.unwornSphere.radii);
                    } else {
                        // Sphere penetration depth
                        pen1 = sphereRadius - tri.p1.distanceTo(sphereCenter);
                        pen2 = sphereRadius - tri.p2.distanceTo(sphereCenter);
                        pen3 = sphereRadius - tri.p3.distanceTo(sphereCenter);
                    }
                    
                    // Average penetration over the clipped triangle
                    const avgPenetration = (pen1 + pen2 + pen3) / 3.0;
                    
                    // Only include triangles with positive average penetration (actually worn)
                    if (avgPenetration <= 0) continue;
                    
                    // Calculate triangle area
                    const area = triangleArea(tri.p1, tri.p2, tri.p3);
                    
                    // Volume contribution = average_penetration × area
                    const volumeContribution = avgPenetration * area;
                    
                    // Kahan summation to minimize floating-point error
                    const y = volumeContribution - kahanC;
                    const t = volumetricWear + y;
                    kahanC = (t - volumetricWear) - y;
                    volumetricWear = t;
                    
                    wornTriangleCount++;
                }
            }
            
            console.log(`Total clipped sub-triangles generated: ${totalClippedTriangles}`);
            console.log(`Processed ${wornTriangleCount} worn triangles (filtered by transition plane)`);
            console.log(`Volumetric wear (sphere to worn surface, bounded by plane): ${volumetricWear.toFixed(4)} mm³`);
            
            // For backward compatibility with visualization code
            const volumePlaneToSurface = volumetricWear;
            const sphericalCapVolume = 0;
            
            console.log('=== FINAL RESULT ===');
            console.log(`Volumetric wear = ${volumePlaneToSurface.toFixed(4)} - ${sphericalCapVolume.toFixed(4)} = ${volumetricWear.toFixed(4)} mm³`);
            
            // LINEAR WEAR: Calculate PERPENDICULAR penetration depths (radial distance from ideal sphere)
            // CORRECTED: Only measure in the space between transition plane and real inner surface
            // This frames the measurement within the worn zone, from the plane to the inner face
            console.log('=== LINEAR WEAR (Perpendicular Penetration Depth - Framed by Transition Plane) ===');
            const penetrationDepths = [];
            let filteredWornCount = 0;
            let maxPenetrationVertex = null;
            let maxPenetrationValue = 0;
            
            state.wornVertices.forEach(v => {
                // Filter: Only include vertices on the WORN side of the transition plane
                // CRITICAL: Plane normal points radially INWARD (from boundary to center)
                // Worn vertices are closer to center, in front of the plane, so distance <= 0
                const distToTransitionPlane = distanceToPlane(v.pos, planeNormal, planeD);
                
                // Only measure vertices that are on the worn side (negative/zero distance, in front of plane)
                if (distToTransitionPlane <= 0) {
                    // Calculate penetration depth based on surface type
                    let penetration;
                    
                    if (state.unwornSphere.isEllipsoid && state.unwornSphere.radii) {
                        // Ellipsoid penetration
                        penetration = penetrationDepthEllipsoid(v.pos, state.unwornSphere.center, state.unwornSphere.radii);
                    } else {
                        // Sphere penetration (radial distance)
                        const distToCenter = v.pos.distanceTo(state.unwornSphere.center);
                        penetration = state.unwornSphere.radius - distToCenter;
                    }
                    
                    // Only include positive penetrations (actual wear)
                    if (penetration > 0) {
                        penetrationDepths.push(penetration);
                        filteredWornCount++;
                        
                        // Track vertex with maximum penetration for visualization
                        if (penetration > maxPenetrationValue) {
                            maxPenetrationValue = penetration;
                            maxPenetrationVertex = v.pos.clone();
                        }
                    }
                }
            });
            
            console.log(`Filtered worn vertices within transition plane frame: ${filteredWornCount} / ${state.wornVertices.length}`);
            
            // Calculate statistics - FIXED: Iterative min/max to avoid stack overflow
            let meanPenetration = 0;
            let maxPenetration = 0;
            let minPenetration = 0;
            
            if (penetrationDepths.length > 0) {
                meanPenetration = penetrationDepths.reduce((a, b) => a + b, 0) / penetrationDepths.length;
                maxPenetration = penetrationDepths[0];
                minPenetration = penetrationDepths[0];
                
                for (let i = 1; i < penetrationDepths.length; i++) {
                    if (penetrationDepths[i] > maxPenetration) maxPenetration = penetrationDepths[i];
                    if (penetrationDepths[i] < minPenetration) minPenetration = penetrationDepths[i];
                }
            }
            
            console.log(`Mean perpendicular penetration: ${meanPenetration.toFixed(4)} mm`);
            console.log(`Max perpendicular penetration: ${maxPenetration.toFixed(4)} mm (deepest point)`);
            console.log(`Min perpendicular penetration: ${minPenetration.toFixed(4)} mm`);
            
            // Calculate areas for reference
            const wornArea = state.wornVertices.length * 0.1;
            const unwornArea = state.unwornVertices.length * 0.1;
            
            // VISUALIZATION: Add wear volume mesh to sphere viewer in BRIGHT ORANGE
            console.log('=== Creating wear volume visualization (bright orange) ===');
            
            // Create mesh showing the exact volume being calculated (worn surface below plane)
            const wearVolumePositions = [];
            const wearVolumeIndices = [];
            let vertexCount = 0;
            
            // Build geometry for worn triangles below the transition plane
            for (let i = 0; i < positions.length; i += 9) {
                const idx1 = (i / 3);
                const idx2 = (i / 3) + 1;
                const idx3 = (i / 3) + 2;
                
                const isWornFace = wornVertexIndices.has(idx1) || 
                                   wornVertexIndices.has(idx2) || 
                                   wornVertexIndices.has(idx3);
                
                if (!isWornFace) continue;
                
                const p1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                const p2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                const p3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                
                // Check if triangle is on the worn side
                // CRITICAL: Worn side has distance <= 0 (closer to center, in front of plane)
                const dist1 = distanceToPlane(p1, planeNormal, planeD);
                const dist2 = distanceToPlane(p2, planeNormal, planeD);
                const dist3 = distanceToPlane(p3, planeNormal, planeD);
                
                // Skip if all vertices are on unworn side (distance > 0, beyond plane)
                if (dist1 > 0 && dist2 > 0 && dist3 > 0) continue;
                
                // Add this worn triangle to the visualization
                wearVolumePositions.push(p1.x, p1.y, p1.z);
                wearVolumePositions.push(p2.x, p2.y, p2.z);
                wearVolumePositions.push(p3.x, p3.y, p3.z);
                wearVolumeIndices.push(vertexCount, vertexCount+1, vertexCount+2);
                vertexCount += 3;
            }
            
            if (wearVolumePositions.length > 0) {
                const wearVolumeGeom = new THREE.BufferGeometry();
                wearVolumeGeom.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(wearVolumePositions), 3));
                wearVolumeGeom.setIndex(wearVolumeIndices);
                wearVolumeGeom.computeVertexNormals();
                
                const wearVolumeMat = new THREE.MeshPhongMaterial({
                    color: 0xff6600,  // BRIGHT ORANGE for high visibility
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    emissive: 0xff3300,  // Add glow effect
                    emissiveIntensity: 0.3
                });
                
                const wearVolumeMesh = new THREE.Mesh(wearVolumeGeom, wearVolumeMat);
                sphereScene.add(wearVolumeMesh);
                
                console.log(`Wear volume visualization added: ${vertexCount} vertices, bright orange color`);
                console.log(`This shows the EXACT volume being calculated as volumetric wear`);
            }
            
            // VISUALIZATION: Add maximum linear wear line (from sphere surface to deepest worn point)
            // First, clean up any existing max wear line objects from previous runs
            if (state.maxWearLineObjects.length > 0) {
                state.maxWearLineObjects.forEach(obj => {
                    sphereScene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                state.maxWearLineObjects = [];
                console.log('Cleaned up previous max wear line visualization objects');
            }
            
            if (maxPenetrationVertex && maxPenetration > 0) {
                console.log('=== Adding maximum linear wear visualization ===');
                
                // Calculate the point on the fitted sphere surface (accurate radial projection)
                // Direction from sphere center to the deepest worn point
                const directionToVertex = new THREE.Vector3().subVectors(maxPenetrationVertex, state.unwornSphere.center);
                const normalizedDirection = directionToVertex.normalize();
                
                // Project onto fitted sphere surface using the unworn sphere's center and radius
                const sphereSurfacePoint = state.unwornSphere.center.clone().add(
                    normalizedDirection.clone().multiplyScalar(state.unwornSphere.radius)
                );
                
                // Create line geometry from sphere surface to worn surface
                const lineGeometry = new THREE.BufferGeometry();
                const linePositions = new Float32Array([
                    sphereSurfacePoint.x, sphereSurfacePoint.y, sphereSurfacePoint.z,
                    maxPenetrationVertex.x, maxPenetrationVertex.y, maxPenetrationVertex.z
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
                
                // Create bright cyan/magenta line material for high contrast
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,  // Bright magenta/purple for maximum visibility
                    linewidth: 5,  // Increased thickness for better visibility
                    opacity: 1.0,
                    transparent: false
                });
                
                const maxWearLine = new THREE.Line(lineGeometry, lineMaterial);
                sphereScene.add(maxWearLine);
                state.maxWearLineObjects.push(maxWearLine);  // Track for cleanup
                
                // Add sphere marker at the worn surface point (deepest point)
                // REDUCED SIZE: Much finer markers for sub-millimeter measurements (0.1-0.2mm typical)
                const wornPointMarkerGeom = new THREE.SphereGeometry(0.15, 12, 12);  // Reduced from 0.6 to 0.15
                const wornPointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,  // Match line color
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.6
                });
                const wornPointMarker = new THREE.Mesh(wornPointMarkerGeom, wornPointMarkerMat);
                wornPointMarker.position.copy(maxPenetrationVertex);
                sphereScene.add(wornPointMarker);
                state.maxWearLineObjects.push(wornPointMarker);  // Track for cleanup
                
                // Add sphere marker at the fitted sphere surface point (start of measurement)
                const spherePointMarkerGeom = new THREE.SphereGeometry(0.12, 12, 12);  // Reduced from 0.5 to 0.12
                const spherePointMarkerMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,  // Bright cyan for distinction
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.6
                });
                const spherePointMarker = new THREE.Mesh(spherePointMarkerGeom, spherePointMarkerMat);
                spherePointMarker.position.copy(sphereSurfacePoint);
                sphereScene.add(spherePointMarker);
                state.maxWearLineObjects.push(spherePointMarker);  // Track for cleanup
                
                console.log(`Maximum linear wear line added:`);
                console.log(`  From fitted sphere surface: (${sphereSurfacePoint.x.toFixed(3)}, ${sphereSurfacePoint.y.toFixed(3)}, ${sphereSurfacePoint.z.toFixed(3)})`);
                console.log(`  To deepest worn point: (${maxPenetrationVertex.x.toFixed(3)}, ${maxPenetrationVertex.y.toFixed(3)}, ${maxPenetrationVertex.z.toFixed(3)})`);
                console.log(`  Penetration distance: ${maxPenetration.toFixed(4)} mm`);
                console.log(`  Line color: Bright magenta/purple | Markers: Magenta (worn) + Cyan (sphere)`);
            } else {
                console.log('No positive penetration detected, skipping maximum linear wear visualization');
                // Ensure array is cleared to avoid memory leaks when no new line is created
                state.maxWearLineObjects = [];
            }
            
            state.wearData = {
                volumetricWear: Math.max(0, volumetricWear),
                volumePlaneToSurface,
                sphericalCapVolume,
                linearWearMean: meanPenetration,
                linearWearMax: maxPenetration,
                linearWearMin: minPenetration,
                unwornSphereCenter: state.unwornSphere.center,
                unwornSphereRadius: state.unwornSphere.radius,
                transitionPlaneNormal: state.transitionPlane.normal,
                transitionPlaneD: state.transitionPlane.d,
                wornArea,
                unwornArea
            };
            
            // Update UI
            document.getElementById('metric-volume').textContent = volumetricWear.toFixed(4) + ' mm³';
            document.getElementById('metric-linear-mean').textContent = meanPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-max').textContent = maxPenetration.toFixed(4) + ' mm';
            document.getElementById('metric-linear-min').textContent = minPenetration.toFixed(4) + ' mm';
            document.getElementById('sphere-center').textContent = 
                `(${state.unwornSphere.center.x.toFixed(2)}, ${state.unwornSphere.center.y.toFixed(2)}, ${state.unwornSphere.center.z.toFixed(2)}) mm`;
            document.getElementById('sphere-radius').textContent = 
                `${state.unwornSphere.radius.toFixed(4)} mm`;
            document.getElementById('worn-area').textContent = wornArea.toFixed(2) + ' mm²';
            document.getElementById('unworn-area').textContent = unwornArea.toFixed(2) + ' mm²';
            
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('results-data').classList.remove('hidden');
            
            // DIAGNOSTIC: Show alert if results are zero
            if (volumetricWear === 0 && meanPenetration === 0) {
                console.warn('⚠️ RESULTADOS EN CERO - DIAGNÓSTICO:');
                console.warn(`  - Vértices desgastados detectados: ${state.wornVertices.length}`);
                console.warn(`  - Vértices no desgastados detectados: ${state.unwornVertices.length}`);
                console.warn(`  - Triángulos procesados: ${wornTriangleCount}`);
                console.warn(`  - Triángulos recortados generados: ${totalClippedTriangles}`);
                console.warn(`  - Radio de esfera: ${state.unwornSphere.radius.toFixed(4)} mm`);
                console.warn(`  - Vértices desgastados filtrados (dentro del plano): ${filteredWornCount}`);
                
                let diagnosticMsg = '⚠️ RESULTADOS EN CERO - Posibles causas:\n\n';
                
                if (state.wornVertices.length === 0) {
                    diagnosticMsg += '❌ NO SE DETECTARON ZONAS DESGASTADAS\n';
                    diagnosticMsg += '   El algoritmo de curvatura no encontró desgaste.\n';
                    diagnosticMsg += '   → Posible solución: Verificar que el archivo STL tenga desgaste real.\n\n';
                } else if (wornTriangleCount === 0) {
                    diagnosticMsg += '❌ TRIÁNGULOS DESGASTADOS EXCLUIDOS POR EL PLANO\n';
                    diagnosticMsg += '   El plano de transición está cortando todos los triángulos.\n';
                    diagnosticMsg += '   → Revisar la orientación del plano en la consola.\n\n';
                } else if (filteredWornCount === 0) {
                    diagnosticMsg += '❌ VÉRTICES DESGASTADOS FUERA DEL MARCO DEL PLANO\n';
                    diagnosticMsg += '   Todos los vértices están del lado equivocado del plano.\n';
                    diagnosticMsg += '   → Posible error en cálculo del plano de transición.\n\n';
                } else {
                    diagnosticMsg += '❌ PENETRACIÓN NEGATIVA O CERO\n';
                    diagnosticMsg += '   La esfera de referencia está mal ajustada.\n';
                    diagnosticMsg += '   → Intentar con otro método de ajuste (RANSAC vs Gauss-Newton).\n\n';
                }
                
                diagnosticMsg += 'Ver consola del navegador (F12) para más detalles.';
                alert(diagnosticMsg);
            }
            
            updateStatus('complete', 'Wear calculation complete');
            showLoading(false);
        });

        // Export CSV
        document.getElementById('btn-export-csv').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            const data = state.wearData;
            const csv = [
                'Metric,Value,Unit',
                `Volumetric Wear (plane-surface minus spherical-cap),${data.volumetricWear.toFixed(6)},mm³`,
                `Volume Plane to Surface,${data.volumePlaneToSurface.toFixed(6)},mm³`,
                `Volume Spherical Cap,${data.sphericalCapVolume.toFixed(6)},mm³`,
                `Linear Wear Mean Penetration,${data.linearWearMean.toFixed(6)},mm`,
                `Linear Wear Max Penetration,${data.linearWearMax.toFixed(6)},mm`,
                `Linear Wear Min Penetration,${data.linearWearMin.toFixed(6)},mm`,
                `Unworn Sphere Center X,${data.unwornSphereCenter.x.toFixed(6)},mm`,
                `Unworn Sphere Center Y,${data.unwornSphereCenter.y.toFixed(6)},mm`,
                `Unworn Sphere Center Z,${data.unwornSphereCenter.z.toFixed(6)},mm`,
                `Unworn Sphere Radius,${data.unwornSphereRadius.toFixed(6)},mm`,
                `Transition Plane Normal X,${data.transitionPlaneNormal.x.toFixed(6)},-`,
                `Transition Plane Normal Y,${data.transitionPlaneNormal.y.toFixed(6)},-`,
                `Transition Plane Normal Z,${data.transitionPlaneNormal.z.toFixed(6)},-`,
                `Transition Plane D,${data.transitionPlaneD.toFixed(6)},mm`,
                `Worn Zone Area,${data.wornArea.toFixed(4)},mm²`,
                `Unworn Zone Area,${data.unwornArea.toFixed(4)},mm²`
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acetabular_wear_analysis.csv';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Export JSON with full metadata
        document.getElementById('btn-export-json').addEventListener('click', () => {
            if (!state.wearData || !state.fittingDiagnostics) {
                alert('Please complete analysis first');
                return;
            }
            
            const data = state.wearData;
            const diag = state.fittingDiagnostics;
            
            // Build comprehensive JSON export
            const exportData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    systemVersion: '2.0-Enhanced',
                    analysisMethod: 'Gaussian Curvature + PCA + ' + diag.method
                },
                wearMetrics: {
                    volumetric: {
                        total: data.volumetricWear,
                        planeToSurface: data.volumePlaneToSurface,
                        sphericalCap: data.sphericalCapVolume,
                        unit: 'mm³'
                    },
                    linear: {
                        mean: data.linearWearMean,
                        max: data.linearWearMax,
                        min: data.linearWearMin,
                        unit: 'mm'
                    }
                },
                unwornSphere: {
                    center: {
                        x: data.unwornSphereCenter.x,
                        y: data.unwornSphereCenter.y,
                        z: data.unwornSphereCenter.z
                    },
                    radius: data.unwornSphereRadius,
                    unit: 'mm'
                },
                transitionPlane: {
                    normal: {
                        x: data.transitionPlaneNormal.x,
                        y: data.transitionPlaneNormal.y,
                        z: data.transitionPlaneNormal.z
                    },
                    d: data.transitionPlaneD,
                    method: 'PCA (Principal Component Analysis)',
                    unit: 'mm'
                },
                zoneAreas: {
                    worn: data.wornArea,
                    unworn: data.unwornArea,
                    unit: 'mm²'
                },
                fittingDiagnostics: {
                    method: diag.method,
                    iterations: diag.iterations,
                    rmsError: diag.rmsError,
                    inlierCount: diag.inliers,
                    totalPoints: state.unwornVertices.length,
                    inlierRatio: diag.inliers / state.unwornVertices.length,
                    residualStatistics: {
                        min: diag.residuals.reduce((min, val) => val < min ? val : min, Infinity),
                        max: diag.residuals.reduce((max, val) => val > max ? val : max, -Infinity),
                        mean: diag.residuals.reduce((a, b) => a + b, 0) / diag.residuals.length,
                        unit: 'mm'
                    }
                },
                curvatureAnalysis: {
                    method: 'Meyer et al. 2003 Gaussian Curvature',
                    rimExclusion: true,
                    combinedScoring: 'Curvature + Radial Deviation'
                },
                inflectionPoints: {
                    count: state.inflectionPoints.length,
                    visualized: state.inflectionMarkers.length
                }
            };
            
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `acetabular_wear_analysis_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('JSON export completed with full metadata');
        });

        // Export PDF Report
        document.getElementById('btn-export-pdf').addEventListener('click', () => {
            if (!state.wearData) {
                alert('Please complete analysis first');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const data = state.wearData;
            const diag = state.fittingDiagnostics;
            
            // Title
            doc.setFontSize(20);
            doc.setTextColor(102, 126, 234);
            doc.text('Acetabular Wear Analysis Report', 105, 20, { align: 'center' });
            
            // Date
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text(`Generated: ${new Date().toLocaleString()}`, 105, 28, { align: 'center' });
            
            // Section 1: Wear Metrics
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('Wear Metrics', 20, 45);
            doc.setFontSize(10);
            let y = 55;
            doc.text(`Volumetric Wear: ${data.volumetricWear.toFixed(4)} mm³`, 25, y);
            y += 8;
            doc.text(`Mean Linear Wear: ${data.linearWearMean.toFixed(4)} mm`, 25, y);
            y += 6;
            doc.text(`Maximum Penetration: ${data.linearWearMax.toFixed(4)} mm`, 25, y);
            y += 6;
            doc.text(`Minimum Penetration: ${data.linearWearMin.toFixed(4)} mm`, 25, y);
            
            // Section 2: Sphere Parameters
            y += 15;
            doc.setFontSize(14);
            doc.text('Unworn Sphere Parameters', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Center: (${data.unwornSphereCenter.x.toFixed(2)}, ${data.unwornSphereCenter.y.toFixed(2)}, ${data.unwornSphereCenter.z.toFixed(2)}) mm`, 25, y);
            y += 6;
            doc.text(`Radius: ${data.unwornSphereRadius.toFixed(4)} mm`, 25, y);
            
            // Section 3: Fitting Quality
            if (diag) {
                y += 15;
                doc.setFontSize(14);
                doc.text('Fitting Quality Diagnostics', 20, y);
                doc.setFontSize(10);
                y += 10;
                doc.text(`Method: ${diag.method}`, 25, y);
                y += 6;
                doc.text(`RMS Error: ${diag.rmsError.toFixed(6)} mm`, 25, y);
                y += 6;
                doc.text(`Iterations: ${diag.iterations}`, 25, y);
                y += 6;
                doc.text(`Inliers: ${diag.inliers} / ${state.unwornVertices.length} (${((diag.inliers / state.unwornVertices.length) * 100).toFixed(1)}%)`, 25, y);
            }
            
            // Section 4: Zone Areas
            y += 15;
            doc.setFontSize(14);
            doc.text('Zone Areas', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Worn Zone: ${data.wornArea.toFixed(2)} mm²`, 25, y);
            y += 6;
            doc.text(`Unworn Zone: ${data.unwornArea.toFixed(2)} mm²`, 25, y);
            
            // Section 5: Transition Plane
            y += 15;
            doc.setFontSize(14);
            doc.text('Transition Plane', 20, y);
            doc.setFontSize(10);
            y += 10;
            doc.text(`Normal: (${data.transitionPlaneNormal.x.toFixed(4)}, ${data.transitionPlaneNormal.y.toFixed(4)}, ${data.transitionPlaneNormal.z.toFixed(4)})`, 25, y);
            y += 6;
            doc.text(`D coefficient: ${data.transitionPlaneD.toFixed(4)}`, 25, y);
            
            // Footer
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text('Acetabular Wear Analysis System v2.4', 105, 285, { align: 'center' });
            
            // Save
            doc.save(`acetabular_wear_report_${new Date().toISOString().split('T')[0]}.pdf`);
            console.log('PDF report generated successfully');
        });

        // Download Sphere Visualization Elements
        document.getElementById('btn-download-sphere-view').addEventListener('click', () => {
            if (!state.unwornSphere || !state.transitionPlane) {
                alert('Please complete sphere fitting first');
                return;
            }
            
            // Helper function to convert geometry to STL string
            function geometryToSTL(geometry, name = 'model') {
                const positions = geometry.attributes.position.array;
                let stl = `solid ${name}\n`;
                
                for (let i = 0; i < positions.length; i += 9) {
                    const v1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                    const v2 = new THREE.Vector3(positions[i+3], positions[i+4], positions[i+5]);
                    const v3 = new THREE.Vector3(positions[i+6], positions[i+7], positions[i+8]);
                    
                    const e1 = new THREE.Vector3().subVectors(v2, v1);
                    const e2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(e1, e2).normalize();
                    
                    stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                }
                
                stl += `endsolid ${name}\n`;
                return stl;
            }
            
            // Helper function to download text file
            function downloadFile(content, filename, type = 'text/plain') {
                const blob = new Blob([content], { type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            // 1. Export original STL (inner surface)
            if (state.geometry) {
                const stlContent = geometryToSTL(state.geometry, 'inner_surface');
                downloadFile(stlContent, 'inner_surface.stl');
            }
            
            // 2. Export fitted sphere as STL
            const sphereGeom = new THREE.SphereGeometry(state.unwornSphere.radius, 64, 64);
            sphereGeom.translate(state.unwornSphere.center.x, state.unwornSphere.center.y, state.unwornSphere.center.z);
            const sphereStl = geometryToSTL(sphereGeom, 'fitted_sphere');
            downloadFile(sphereStl, 'fitted_sphere.stl');
            
            // 3. Export transition plane as STL
            const planeSize = state.unwornSphere.radius * 4;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
            planeGeom.translate(state.transitionPlane.point.x, state.transitionPlane.point.y, state.transitionPlane.point.z);
            
            // Orient plane
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, state.transitionPlane.normal);
            planeGeom.applyQuaternion(quaternion);
            
            const planeStl = geometryToSTL(planeGeom, 'transition_plane');
            downloadFile(planeStl, 'transition_plane.stl');
            
            // 4. Export inflection points as CSV
            if (state.inflectionPoints && state.inflectionPoints.length > 0) {
                let csvContent = 'X,Y,Z\n';
                state.inflectionPoints.forEach(p => {
                    csvContent += `${p.x},${p.y},${p.z}\n`;
                });
                downloadFile(csvContent, 'inflection_points.csv', 'text/csv');
            }
            
            // 5. Export metadata as JSON
            const metadata = {
                unwornSphere: {
                    center: { x: state.unwornSphere.center.x, y: state.unwornSphere.center.y, z: state.unwornSphere.center.z },
                    radius: state.unwornSphere.radius
                },
                transitionPlane: {
                    normal: { x: state.transitionPlane.normal.x, y: state.transitionPlane.normal.y, z: state.transitionPlane.normal.z },
                    point: { x: state.transitionPlane.point.x, y: state.transitionPlane.point.y, z: state.transitionPlane.point.z },
                    d: state.transitionPlane.d
                },
                inflectionPointsCount: state.inflectionPoints.length,
                exportDate: new Date().toISOString()
            };
            downloadFile(JSON.stringify(metadata, null, 2), 'sphere_view_metadata.json', 'application/json');
            
            alert('5 files downloaded:\n- inner_surface.stl\n- fitted_sphere.stl\n- transition_plane.stl\n- inflection_points.csv\n- sphere_view_metadata.json');
        });

        // Export Interactive HTML
        document.getElementById('btn-export-html').addEventListener('click', () => {
            if (!state.unwornSphere || !state.transitionPlane || !state.wearData) {
                alert('Please complete analysis first (all 4 steps)');
                return;
            }
            
            // Capture current sphere scene data
            const sceneData = {
                geometry: state.geometry ? state.geometry.clone() : null,
                unwornSphere: state.unwornSphere,
                transitionPlane: state.transitionPlane,
                wearData: state.wearData,
                wornVertices: state.wornVertices,
                unwornVertices: state.unwornVertices,
                inflectionPoints: state.inflectionPoints || []
            };
            
            // Helper to serialize geometry to JSON
            function serializeGeometry(geom) {
                if (!geom) return null;
                return {
                    positions: Array.from(geom.attributes.position.array),
                    indices: geom.index ? Array.from(geom.index.array) : null,
                    colors: geom.attributes.color ? Array.from(geom.attributes.color.array) : null
                };
            }
            
            const geometryData = serializeGeometry(sceneData.geometry);
            
            // Pre-calculate wear metrics for embedding in HTML
            const volumetricWear = sceneData.wearData.volumetricWear.toFixed(4);
            const linearWearMean = sceneData.wearData.linearWearMean.toFixed(4);
            const linearWearMax = sceneData.wearData.linearWearMax.toFixed(4);
            const sphereRadius = sceneData.unwornSphere.radius.toFixed(4);
            const wornArea = sceneData.wearData.wornArea.toFixed(2);
            const unwornArea = sceneData.wearData.unwornArea.toFixed(2);
            
            // Create standalone HTML document with embedded data
            const dataJSON = JSON.stringify({
                geometryData,
                unwornSphere: sceneData.unwornSphere,
                transitionPlane: sceneData.transitionPlane,
                inflectionPoints: sceneData.inflectionPoints.map(p => ({x: p.x, y: p.y, z: p.z}))
            });
            
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acetabular Wear Analysis - 3D Visualization</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    <\/script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: white;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: #1e293b;
            max-width: 350px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #667eea;
        }
        .metric {
            margin: 8px 0;
            font-size: 13px;
        }
        .metric strong {
            color: #667eea;
        }
        .controls-hint {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
            font-size: 11px;
            color: #64748b;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info-panel">
        <h1>🔬 Wear Analysis Results</h1>
        <div class="metric"><strong>Volumetric Wear:</strong> ${volumetricWear} mm³</div>
        <div class="metric"><strong>Mean Linear Wear:</strong> ${linearWearMean} mm</div>
        <div class="metric"><strong>Max Penetration:</strong> ${linearWearMax} mm</div>
        <div class="metric"><strong>Sphere Radius:</strong> ${sphereRadius} mm</div>
        <div class="metric"><strong>Worn Area:</strong> ${wornArea} mm²</div>
        <div class="metric"><strong>Unworn Area:</strong> ${unwornArea} mm²</div>
        <div class="controls-hint">
            <strong>Controls:</strong><br>
            Left click + drag: Rotate<br>
            Right click + drag: Pan<br>
            Scroll: Zoom
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const sceneData = ${dataJSON};
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e293b);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 30, 30);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // Reconstruct geometry from data
        if (sceneData.geometryData && sceneData.geometryData.positions) {
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(sceneData.geometryData.positions), 3));
            if (sceneData.geometryData.indices) {
                geom.setIndex(new THREE.BufferAttribute(new Uint32Array(sceneData.geometryData.indices), 1));
            }
            if (sceneData.geometryData.colors) {
                geom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(sceneData.geometryData.colors), 3));
            }
            geom.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: sceneData.geometryData.colors ? true : false,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            const mesh = new THREE.Mesh(geom, material);
            scene.add(mesh);
        }
        
        // Add fitted sphere (wireframe)
        const sphereGeom = new THREE.SphereGeometry(sceneData.unwornSphere.radius, 64, 64);
        const sphereMat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            wireframe: true,
            transparent: true,
            opacity: 0.4
        });
        const sphereMesh = new THREE.Mesh(sphereGeom, sphereMat);
        sphereMesh.position.set(
            sceneData.unwornSphere.center.x,
            sceneData.unwornSphere.center.y,
            sceneData.unwornSphere.center.z
        );
        scene.add(sphereMesh);
        
        // Add transition plane
        const planeSize = sceneData.unwornSphere.radius * 4;
        const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
        const planeMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const planeMesh = new THREE.Mesh(planeGeom, planeMat);
        planeMesh.position.set(
            sceneData.transitionPlane.point.x,
            sceneData.transitionPlane.point.y,
            sceneData.transitionPlane.point.z
        );
        const up = new THREE.Vector3(0, 0, 1);
        const normal = new THREE.Vector3(
            sceneData.transitionPlane.normal.x,
            sceneData.transitionPlane.normal.y,
            sceneData.transitionPlane.normal.z
        );
        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal);
        planeMesh.applyQuaternion(quaternion);
        scene.add(planeMesh);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    <\/script>
</body>
</html>`;
            
            // Download HTML file
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acetabular_wear_3d_' + new Date().toISOString().split('T')[0] + '.html';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('Interactive HTML exported successfully');
            alert('Interactive HTML file downloaded!\\n\\nOpen it in any browser to view the 3D visualization with orbit controls.');
        });
    </script>
</body>
</html>
